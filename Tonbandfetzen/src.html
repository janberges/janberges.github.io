<html lang='en'><head><meta charset='utf-8'><title>src</title><link rel='stylesheet' type='text/css' href='style.css'></head><body><h1>src</h1>
<h2>aiff.f90</h2>
<pre id='vimCodeElement'>
<span class="PreProc">module</span> aiff
   <span class="PreProc">use</span> bytes, <span class="PreProc">only</span>: c, r
   <span class="PreProc">use</span> constants, <span class="PreProc">only</span>: audio, dp, eof, i2, i4, stderr
   <span class="PreProc">use</span> extended, <span class="PreProc">only</span>: decode, encode
   <span class="Type">implicit</span> <span class="Type">none</span>
   <span class="Type">private</span>

   <span class="Type">public</span> :: read_aiff, write_aiff

<span class="PreProc">contains</span>

   <span class="PreProc">subroutine</span> read_aiff(path, s)
      <span class="Type">character</span>(<span class="Statement">*</span>), <span class="Type">intent</span>(<span class="Type">in</span>) :: path
      <span class="Type">type</span>(audio), <span class="Type">intent</span>(<span class="Type">out</span>) :: s

      <span class="Type">integer</span> :: i, fun, error
      <span class="Type">character</span>(<span class="Constant">1</span>) :: byte
      <span class="Type">character</span>(<span class="Constant">4</span>) :: ckID, formType, applicationSignature
      <span class="Type">character</span>(<span class="Constant">10</span>) :: extended
      <span class="Type">integer</span>(i4) :: ckSize, offset, blockSize
      <span class="Type">integer</span>(i2) :: sampleSize

      <span class="Statement">open</span> (<span class="Statement">newunit</span><span class="Statement">=</span>fun, <span class="Statement">file</span><span class="Statement">=</span>path, <span class="Statement">iostat</span><span class="Statement">=</span>error, <span class="Special">&amp;</span>
         <span class="Statement">action</span><span class="Statement">=</span><span class="Constant">'read'</span>, <span class="Statement">status</span><span class="Statement">=</span><span class="Constant">'old'</span>, <span class="Statement">access</span><span class="Statement">=</span><span class="Constant">'stream'</span>)

      <span class="Statement">if</span> (error <span class="Statement">.ne.</span> <span class="Constant">0</span>) <span class="Statement">then</span>
         <span class="Statement">write</span> (stderr, <span class="Constant">&quot;('Error: Cannot read AIFF file ''', A, '''.')&quot;</span>) path
         <span class="Statement">stop</span>
      <span class="Statement">end if</span>

      <span class="Statement">do</span>
         <span class="Statement">read</span> (fun, <span class="Statement">iostat</span><span class="Statement">=</span>error) ckID, ckSize
         <span class="Statement">if</span> (error <span class="Statement">.eq.</span> eof) <span class="Statement">exit</span>

         ckSize <span class="Statement">=</span> r(ckSize)

         <span class="Statement">select case</span> (ckID)
         <span class="Statement">case</span> (<span class="Constant">'FORM'</span>)
            <span class="Statement">read</span> (fun) formType

         <span class="Statement">case</span> (<span class="Constant">'COMM'</span>)
            <span class="Statement">read</span> (fun) s%channels, s%points, sampleSize, extended

            s%channels <span class="Statement">=</span> r(s%channels)
            s%points <span class="Statement">=</span> r(s%points)
            sampleSize <span class="Statement">=</span> r(sampleSize)
            s%rate <span class="Statement">=</span> decode(extended)

            <span class="Statement">if</span> (sampleSize <span class="Statement">.ne.</span> <span class="Constant">16_i2</span>) <span class="Statement">then</span>
               <span class="Statement">write</span> (stderr, <span class="Constant">&quot;('Error: Only 16 bits supported.')&quot;</span>)
               <span class="Statement">stop</span>
            <span class="Statement">end if</span>

         <span class="Statement">case</span> (<span class="Constant">'SSND'</span>)
            <span class="Statement">allocate</span>(s%sound(s%channels, s%points))
            <span class="Statement">read</span> (fun) offset, blockSize, s%sound

            offset <span class="Statement">=</span> r(offset)
            blockSize <span class="Statement">=</span> r(blockSize)
            s%sound <span class="Statement">=</span> r(s%sound)

         <span class="Statement">case</span> (<span class="Constant">'APPL'</span>)
            <span class="Statement">read</span> (fun) applicationSignature

            <span class="Statement">if</span> (applicationSignature <span class="Statement">.eq.</span> <span class="Constant">'FETZ'</span>) <span class="Statement">then</span>
               <span class="Statement">read</span> (fun) extended
               s%amplitude <span class="Statement">=</span> decode(extended)
            <span class="Statement">else</span>
               <span class="Statement">read</span> (fun) (byte, i <span class="Statement">=</span> <span class="Constant">1</span>, ckSize <span class="Statement">-</span> <span class="Constant">4</span>)
            <span class="Statement">end if</span>

         <span class="Statement">case</span> (<span class="Constant">'ID3 '</span>)
            <span class="Statement">allocate</span>(<span class="Type">character</span>(ckSize) :: s%meta)
            <span class="Statement">read</span> (fun) s%meta

         <span class="Statement">case</span> <span class="Statement">default</span>
            <span class="Statement">do</span> i <span class="Statement">=</span> <span class="Constant">1</span>, ckSize
               <span class="Statement">read</span> (fun, <span class="Statement">iostat</span><span class="Statement">=</span>error) byte

               <span class="Statement">if</span> (error <span class="Statement">.ne.</span> <span class="Constant">0</span>) <span class="Statement">then</span>
                  <span class="Statement">write</span> (stderr, <span class="Constant">&quot;('Error: Corrupt AIFF file ''', A, '''.')&quot;</span>) <span class="Special">&amp;</span>
                     path
                  <span class="Statement">stop</span>
               <span class="Statement">end if</span>
            <span class="Statement">end do</span>
         <span class="Statement">end select</span>
      <span class="Statement">end do</span>

      <span class="Statement">close</span> (fun)
   <span class="PreProc">end subroutine</span> read_aiff

   <span class="PreProc">subroutine</span> write_aiff(path, s)
      <span class="Type">character</span>(<span class="Statement">*</span>), <span class="Type">intent</span>(<span class="Type">in</span>) :: path
      <span class="Type">type</span>(audio), <span class="Type">intent</span>(<span class="Type">in</span>) :: s

      <span class="Type">integer</span> :: fun, error
      <span class="Type">integer</span>(i4), <span class="Type">parameter</span> :: commSize <span class="Statement">=</span> <span class="Constant">18_i4</span>, applSize <span class="Statement">=</span> <span class="Constant">14_i4</span>
      <span class="Type">integer</span>(i4), <span class="Type">parameter</span> :: offset <span class="Statement">=</span> <span class="Constant">0_i4</span>, blockSize <span class="Statement">=</span> <span class="Constant">0_i4</span>
      <span class="Type">integer</span>(i4) :: formSize, ssndSize
      <span class="Type">integer</span>(i2), <span class="Type">parameter</span> :: sampleSize <span class="Statement">=</span> <span class="Constant">16_i2</span>
      <span class="Type">integer</span>(i2) :: blockAlign

      blockAlign <span class="Statement">=</span> <span class="Constant">2_i2</span> <span class="Statement">*</span> s%channels

      ssndSize <span class="Statement">=</span> <span class="Constant">8_i4</span> <span class="Statement">+</span> blockAlign <span class="Statement">*</span> s%points
      formSize <span class="Statement">=</span> <span class="Constant">4_i4</span> <span class="Statement">+</span> <span class="Constant">8_i4</span> <span class="Statement">+</span> commSize <span class="Statement">+</span> <span class="Constant">8_i4</span> <span class="Statement">+</span> ssndSize

      <span class="Statement">if</span> (s%amplitude <span class="Statement">.ne.</span> <span class="Constant">1.0_dp</span>) formSize <span class="Statement">=</span> formSize <span class="Statement">+</span> <span class="Constant">8_i4</span> <span class="Statement">+</span> applSize

      <span class="Statement">if</span> (<span class="Identifier">allocated</span>(s%meta)) formSize <span class="Statement">=</span> formSize <span class="Statement">+</span> <span class="Constant">8_i4</span> <span class="Statement">+</span> <span class="Identifier">len</span>(s%meta)

      <span class="Statement">if</span> (path <span class="Statement">.eq.</span> <span class="Constant">'stdout'</span> <span class="Statement">.or.</span> path <span class="Statement">.eq.</span> <span class="Constant">'http'</span>) <span class="Statement">then</span>
         <span class="Statement">if</span> (path <span class="Statement">.eq.</span> <span class="Constant">'http'</span>) <span class="Statement">then</span>
            <span class="Statement">write</span> (<span class="Statement">*</span>, <span class="Constant">&quot;('Content-Type: audio/x-aiff')&quot;</span>)
            <span class="Statement">write</span> (<span class="Statement">*</span>, <span class="Constant">&quot;('Content-Length: ', I0, /)&quot;</span>) formSize <span class="Statement">+</span> <span class="Constant">8</span>
         <span class="Statement">end if</span>

         <span class="Statement">write</span> (<span class="Statement">*</span>, <span class="Constant">'(*(A))'</span>, <span class="Statement">advance</span><span class="Statement">=</span><span class="Constant">'no'</span>) <span class="Special">&amp;</span>
            <span class="Constant">'FORM'</span>, c(r(formSize)), <span class="Constant">'AIFF'</span>, <span class="Special">&amp;</span>
            <span class="Constant">'COMM'</span>, c(r(commSize)), c(r(s%channels)), <span class="Special">&amp;</span>
            c(r(s%points)), c(r(sampleSize)), encode(s%rate), <span class="Special">&amp;</span>
            <span class="Constant">'SSND'</span>, c(r(ssndSize)), c(r(offset)), c(r(blockSize)), <span class="Special">&amp;</span>
            c(r(s%sound))

         <span class="Statement">if</span> (s%amplitude <span class="Statement">.ne.</span> <span class="Constant">1.0_dp</span>) <span class="Statement">write</span> (<span class="Statement">*</span>, <span class="Constant">'(*(A))'</span>, <span class="Statement">advance</span><span class="Statement">=</span><span class="Constant">'no'</span>) <span class="Special">&amp;</span>
            <span class="Constant">'APPL'</span>, c(r(applSize)), <span class="Constant">'FETZ'</span>,  encode(s%amplitude)

         <span class="Statement">if</span> (<span class="Identifier">allocated</span>(s%meta)) <span class="Statement">write</span> (<span class="Statement">*</span>, <span class="Constant">'(*(A))'</span>, <span class="Statement">advance</span><span class="Statement">=</span><span class="Constant">'no'</span>) <span class="Special">&amp;</span>
            <span class="Constant">'ID3 '</span>, c(r(<span class="Identifier">len</span>(s%meta, i4))), s%meta
      <span class="Statement">else</span>
         <span class="Statement">open</span> (<span class="Statement">newunit</span><span class="Statement">=</span>fun, <span class="Statement">file</span><span class="Statement">=</span>path, <span class="Statement">iostat</span><span class="Statement">=</span>error, <span class="Special">&amp;</span>
            <span class="Statement">action</span><span class="Statement">=</span><span class="Constant">'write'</span>, <span class="Statement">status</span><span class="Statement">=</span><span class="Constant">'replace'</span>, <span class="Statement">access</span><span class="Statement">=</span><span class="Constant">'stream'</span>)

         <span class="Statement">if</span> (error <span class="Statement">.ne.</span> <span class="Constant">0</span>) <span class="Statement">then</span>
            <span class="Statement">write</span> (stderr, <span class="Constant">&quot;('Error: Cannot write AIFF file ''', A, '''.')&quot;</span>) <span class="Special">&amp;</span>
               path
            <span class="Statement">stop</span>
         <span class="Statement">end if</span>

         <span class="Statement">write</span> (fun) <span class="Constant">'FORM'</span>, r(formSize), <span class="Constant">'AIFF'</span>, <span class="Special">&amp;</span>
            <span class="Constant">'COMM'</span>, r(commSize), r(s%channels), <span class="Special">&amp;</span>
            r(s%points), r(sampleSize), encode(s%rate), <span class="Special">&amp;</span>
            <span class="Constant">'SSND'</span>, r(ssndSize), r(offset), r(blockSize), <span class="Special">&amp;</span>
            r(s%sound)

         <span class="Statement">if</span> (s%amplitude <span class="Statement">.ne.</span> <span class="Constant">1.0_dp</span>) <span class="Statement">write</span> (fun) <span class="Special">&amp;</span>
            <span class="Constant">'APPL'</span>, r(applSize), <span class="Constant">'FETZ'</span>, encode(s%amplitude)

         <span class="Statement">if</span> (<span class="Identifier">allocated</span>(s%meta)) <span class="Statement">write</span> (fun) <span class="Special">&amp;</span>
            <span class="Constant">'ID3 '</span>, r(<span class="Identifier">len</span>(s%meta, i4)), s%meta

         <span class="Statement">close</span> (fun)
      <span class="Statement">end if</span>
   <span class="PreProc">end subroutine</span> write_aiff
<span class="PreProc">end module</span> aiff
</pre>
<h2>aiff2riff.f90</h2>
<pre id='vimCodeElement'>
<span class="PreProc">subroutine</span> aiff2riff
   <span class="PreProc">use</span> aiff, <span class="PreProc">only</span>: read_aiff
   <span class="PreProc">use</span> constants, <span class="PreProc">only</span>: audio
   <span class="PreProc">use</span> io, <span class="PreProc">only</span>: command_argument
   <span class="PreProc">use</span> riff, <span class="PreProc">only</span>: write_riff
   <span class="Type">implicit</span> <span class="Type">none</span>

   <span class="Type">type</span>(audio) :: s

   <span class="Identifier">call</span> read_aiff(command_argument(<span class="Statement">-</span><span class="Constant">2</span>, <span class="Constant">'/dev/stdin'</span>), s)
   <span class="Identifier">call</span> write_riff(command_argument(<span class="Statement">-</span><span class="Constant">1</span>, <span class="Constant">'/dev/stdout'</span>), s)
<span class="PreProc">end subroutine</span> aiff2riff
</pre>
<h2>bytes.f90</h2>
<pre id='vimCodeElement'>
<span class="PreProc">module</span> bytes
   <span class="PreProc">use</span> constants, <span class="PreProc">only</span>: i1, i2, i4
   <span class="Type">implicit</span> <span class="Type">none</span>
   <span class="Type">private</span>

   <span class="Type">public</span> :: c, r

   <span class="PreProc">interface</span> c
      <span class="Type">module</span> <span class="Type">procedure</span> chars_i2, chars_i4
   <span class="PreProc">end interface</span> c

   <span class="PreProc">interface</span> r
      <span class="Type">module</span> <span class="Type">procedure</span> reverse_i2, reverse_i4
   <span class="PreProc">end interface</span> r

<span class="PreProc">contains</span>

   <span class="Type">elemental</span> <span class="PreProc">function</span> chars_i2(i) <span class="PreProc">result</span>(o)
      <span class="Type">integer</span>(i2), <span class="Type">intent</span>(<span class="Type">in</span>) :: i
      <span class="Type">character</span>(<span class="Constant">2</span>) :: o

      o <span class="Statement">=</span> <span class="Identifier">transfer</span>(i, o)
   <span class="PreProc">end function</span> chars_i2

   <span class="Type">elemental</span> <span class="PreProc">function</span> chars_i4(i) <span class="PreProc">result</span>(o)
      <span class="Type">integer</span>(i4), <span class="Type">intent</span>(<span class="Type">in</span>) :: i
      <span class="Type">character</span>(<span class="Constant">4</span>) :: o

      o <span class="Statement">=</span> <span class="Identifier">transfer</span>(i, o)
   <span class="PreProc">end function</span> chars_i4

   <span class="Type">elemental</span> <span class="PreProc">function</span> reverse_i2(i) <span class="PreProc">result</span>(o)
      <span class="Type">integer</span>(i2), <span class="Type">intent</span>(<span class="Type">in</span>) :: i
      <span class="Type">integer</span>(i2) :: o
      <span class="Type">integer</span>(i1) :: j(<span class="Constant">2</span>)

      j <span class="Statement">=</span> <span class="Identifier">transfer</span>(i, j)
      j <span class="Statement">=</span> j(<span class="Constant">2</span>:<span class="Constant">1</span>:<span class="Statement">-</span><span class="Constant">1</span>)
      o <span class="Statement">=</span> <span class="Identifier">transfer</span>(j, o)
   <span class="PreProc">end function</span> reverse_i2

   <span class="Type">elemental</span> <span class="PreProc">function</span> reverse_i4(i) <span class="PreProc">result</span>(o)
      <span class="Type">integer</span>(i4), <span class="Type">intent</span>(<span class="Type">in</span>) :: i
      <span class="Type">integer</span>(i4) :: o
      <span class="Type">integer</span>(i1) :: j(<span class="Constant">4</span>)

      j <span class="Statement">=</span> <span class="Identifier">transfer</span>(i, j)
      j <span class="Statement">=</span> j(<span class="Constant">4</span>:<span class="Constant">1</span>:<span class="Statement">-</span><span class="Constant">1</span>)
      o <span class="Statement">=</span> <span class="Identifier">transfer</span>(j, o)
   <span class="PreProc">end function</span> reverse_i4
<span class="PreProc">end module</span> bytes
</pre>
<h2>cgi.f90</h2>
<pre id='vimCodeElement'>
<span class="Comment">! For standalone use on server, compile with FFLAGS='-static -O3'.</span>
<span class="Comment">! Syntax highlighting in textarea inspired by Will Boyd's article:</span>
<span class="Comment">! <a href="https://codersblock.com/blog/highlight-text-inside-a-textarea/">https://codersblock.com/blog/highlight-text-inside-a-textarea/</a></span>

<span class="PreProc">program</span> tz_dot_cgi
   <span class="PreProc">use</span> constants, <span class="PreProc">only</span>: audio, dp
   <span class="PreProc">use</span> interpreter, <span class="PreProc">only</span>: play
   <span class="PreProc">use</span> io, <span class="PreProc">only</span>: environment_variable
   <span class="PreProc">use</span> riff, <span class="PreProc">only</span>: write_riff
   <span class="PreProc">use</span> tab, <span class="PreProc">only</span>: preprocess
   <span class="Type">implicit</span> <span class="Type">none</span>

   <span class="Type">type</span>(audio) :: music

   <span class="Type">character</span>(:), <span class="Type">allocatable</span> :: query
   <span class="Type">integer</span>, <span class="Type">parameter</span> :: limit <span class="Statement">=</span> <span class="Constant">1000000</span>

   query <span class="Statement">=</span> decode(environment_variable(<span class="Constant">'QUERY_STRING'</span>))

   <span class="Statement">if</span> (query <span class="Statement">.eq.</span> <span class="Constant">' '</span>) <span class="Statement">then</span>
      <span class="Statement">write</span> (<span class="Statement">*</span>, <span class="Constant">'(A, /, *(:, /, A))'</span>) <span class="Constant">&quot;Content-type: text/html&quot;</span>, <span class="Special">&amp;</span>
         <span class="Constant">&quot;&lt;!DOCTYPE html&gt;&quot;</span>, <span class="Special">&amp;</span>
         <span class="Constant">&quot;&lt;html lang='en'&gt;&quot;</span>, <span class="Special">&amp;</span>
         <span class="Constant">&quot;  &lt;head&gt;&quot;</span>, <span class="Special">&amp;</span>
         <span class="Constant">&quot;    &lt;meta charset='utf-8'&gt;&quot;</span>, <span class="Special">&amp;</span>
         <span class="Constant">&quot;    &lt;title&gt;Tonbandfetzen&lt;/title&gt;&quot;</span>, <span class="Special">&amp;</span>
         <span class="Constant">&quot;    &lt;link rel='icon' type='image/svg+xml' sizes='any'&quot;</span>, <span class="Special">&amp;</span>
         <span class="Constant">&quot;      href='<a href="https://io.janberges.de/Tonbandfetzen/logo.svg">https://io.janberges.de/Tonbandfetzen/logo.svg</a>'&gt;&quot;</span>, <span class="Special">&amp;</span>
         <span class="Constant">&quot;    &lt;style&gt;&quot;</span>, <span class="Special">&amp;</span>
         <span class="Constant">&quot;      body {&quot;</span>, <span class="Special">&amp;</span>
         <span class="Constant">&quot;        font: 12px sans-serif;&quot;</span>, <span class="Special">&amp;</span>
         <span class="Constant">&quot;        color: #cccccc;&quot;</span>, <span class="Special">&amp;</span>
         <span class="Constant">&quot;        background: #222222;&quot;</span>, <span class="Special">&amp;</span>
         <span class="Constant">&quot;      }&quot;</span>, <span class="Special">&amp;</span>
         <span class="Constant">&quot;      #color {&quot;</span>, <span class="Special">&amp;</span>
         <span class="Constant">&quot;        position: absolute;&quot;</span>, <span class="Special">&amp;</span>
         <span class="Constant">&quot;        color: #ffffff;&quot;</span>, <span class="Special">&amp;</span>
         <span class="Constant">&quot;        background: #333333;&quot;</span>, <span class="Special">&amp;</span>
         <span class="Constant">&quot;      }&quot;</span>, <span class="Special">&amp;</span>
         <span class="Constant">&quot;      #mel {&quot;</span>, <span class="Special">&amp;</span>
         <span class="Constant">&quot;        position: relative;&quot;</span>, <span class="Special">&amp;</span>
         <span class="Constant">&quot;        color: transparent;&quot;</span>, <span class="Special">&amp;</span>
         <span class="Constant">&quot;        background: transparent;&quot;</span>, <span class="Special">&amp;</span>
         <span class="Constant">&quot;        caret-color: #ffffff;&quot;</span>, <span class="Special">&amp;</span>
         <span class="Constant">&quot;      }&quot;</span>, <span class="Special">&amp;</span>
         <span class="Constant">&quot;      #color, #mel, #play, #wav {&quot;</span>, <span class="Special">&amp;</span>
         <span class="Constant">&quot;        display: block;&quot;</span>, <span class="Special">&amp;</span>
         <span class="Constant">&quot;        box-sizing: border-box;&quot;</span>, <span class="Special">&amp;</span>
         <span class="Constant">&quot;        width: 600px;&quot;</span>, <span class="Special">&amp;</span>
         <span class="Constant">&quot;      }&quot;</span>, <span class="Special">&amp;</span>
         <span class="Constant">&quot;      #color, #mel {&quot;</span>, <span class="Special">&amp;</span>
         <span class="Constant">&quot;        height: 300px;&quot;</span>, <span class="Special">&amp;</span>
         <span class="Constant">&quot;        resize: none;&quot;</span>, <span class="Special">&amp;</span>
         <span class="Constant">&quot;        overflow-y: auto;&quot;</span>, <span class="Special">&amp;</span>
         <span class="Constant">&quot;        padding: 5px;&quot;</span>, <span class="Special">&amp;</span>
         <span class="Constant">&quot;        border: 0;&quot;</span>, <span class="Special">&amp;</span>
         <span class="Constant">&quot;        margin: 0;&quot;</span>, <span class="Special">&amp;</span>
         <span class="Constant">&quot;        font: bold 16px monospace;&quot;</span>, <span class="Special">&amp;</span>
         <span class="Constant">&quot;        white-space: pre-wrap;&quot;</span>, <span class="Special">&amp;</span>
         <span class="Constant">&quot;        word-wrap: break-word;&quot;</span>, <span class="Special">&amp;</span>
         <span class="Constant">&quot;      }&quot;</span>, <span class="Special">&amp;</span>
         <span class="Constant">&quot;      #play, #wav { margin-bottom: 5mm }&quot;</span>, <span class="Special">&amp;</span>
         <span class="Constant">&quot;      .N { color: #bf8040 }&quot;</span>, <span class="Special">&amp;</span>
         <span class="Constant">&quot;      .L { color: #afdf00 }&quot;</span>, <span class="Special">&amp;</span>
         <span class="Constant">&quot;      .C { color: #da193b }&quot;</span>, <span class="Special">&amp;</span>
         <span class="Constant">&quot;      a { color: inherit }&quot;</span>, <span class="Special">&amp;</span>
         <span class="Constant">&quot;      a:hover { text-decoration: none }&quot;</span>, <span class="Special">&amp;</span>
         <span class="Constant">&quot;    &lt;/style&gt;&quot;</span>, <span class="Special">&amp;</span>
         <span class="Constant">&quot;    &lt;script&gt;&quot;</span>, <span class="Special">&amp;</span>
         <span class="Constant">&quot;      // @license </span><span class="Special">&amp;</span>
<span class="Constant">         </span><span class="Special">&amp;</span><span class="Constant">magnet:?xt=urn:btih:90dc5c0be029de84e523b9b3922520e79e0e6f08</span><span class="Special">&amp;</span>
<span class="Constant">         </span><span class="Special">&amp;&amp;</span><span class="Constant">dn=cc0.txt CC0-1.0&quot;</span>, <span class="Special">&amp;</span>
         <span class="Constant">&quot;      function enter() {&quot;</span>, <span class="Special">&amp;</span>
         <span class="Constant">&quot;        document.getElementById('play').disabled = false&quot;</span>, <span class="Special">&amp;</span>
         <span class="Constant">&quot;        var m = document.getElementById('mel').value&quot;</span>, <span class="Special">&amp;</span>
         <span class="Constant">&quot;        m = m.replace(/</span><span class="Special">&amp;</span><span class="Constant">/g, '</span><span class="Special">&amp;</span><span class="Constant">AMP;')&quot;</span>, <span class="Special">&amp;</span>
         <span class="Constant">&quot;        m = m.replace(/&lt;/g, '</span><span class="Special">&amp;</span><span class="Constant">LT;')&quot;</span>, <span class="Special">&amp;</span>
         <span class="Constant">&quot;        m = m.replace(/[\d.:]+/g, '&lt;SPAN CLASS=&quot;&quot;N&quot;&quot;&gt;$</span><span class="Special">&amp;</span><span class="Constant">&lt;/SPAN&gt;')&quot;</span>, <span class="Special">&amp;</span>
         <span class="Constant">&quot;        m = m.replace(/[a-z#]+/g, '&lt;SPAN CLASS=&quot;&quot;L&quot;&quot;&gt;$</span><span class="Special">&amp;</span><span class="Constant">&lt;/SPAN&gt;')&quot;</span>, <span class="Special">&amp;</span>
         <span class="Constant">&quot;        m = m.replace(/\n$/g, '$</span><span class="Special">&amp;&amp;</span><span class="Constant">nbsp;')&quot;</span>, <span class="Special">&amp;</span>
         <span class="Constant">&quot;        m = m.replace(/\*[^*]*\*?/g, function(c) {&quot;</span>, <span class="Special">&amp;</span>
         <span class="Constant">&quot;          c = c.replace(/&lt;.+?&gt;/g, '')&quot;</span>, <span class="Special">&amp;</span>
         <span class="Constant">&quot;          return '&lt;SPAN CLASS=&quot;&quot;C&quot;&quot;&gt;' + c + '&lt;/SPAN&gt;'&quot;</span>, <span class="Special">&amp;</span>
         <span class="Constant">&quot;        })&quot;</span>, <span class="Special">&amp;</span>
         <span class="Constant">&quot;        document.getElementById('color').innerHTML = m&quot;</span>, <span class="Special">&amp;</span>
         <span class="Constant">&quot;      }&quot;</span>, <span class="Special">&amp;</span>
         <span class="Constant">&quot;      function move() {&quot;</span>, <span class="Special">&amp;</span>
         <span class="Constant">&quot;        document.getElementById('color').scrollTop =&quot;</span>, <span class="Special">&amp;</span>
         <span class="Constant">&quot;          document.getElementById('mel').scrollTop&quot;</span>, <span class="Special">&amp;</span>
         <span class="Constant">&quot;      }&quot;</span>, <span class="Special">&amp;</span>
         <span class="Constant">&quot;      function play() {&quot;</span>, <span class="Special">&amp;</span>
         <span class="Constant">&quot;        document.getElementById('play').disabled = true&quot;</span>, <span class="Special">&amp;</span>
         <span class="Constant">&quot;        document.getElementById('wav').src = '?'&quot;</span>, <span class="Special">&amp;</span>
         <span class="Constant">&quot;          + encodeURIComponent(&quot;</span>, <span class="Special">&amp;</span>
         <span class="Constant">&quot;            document.getElementById('mel').value)&quot;</span>, <span class="Special">&amp;</span>
         <span class="Constant">&quot;        document.getElementById('wav').load()&quot;</span>, <span class="Special">&amp;</span>
         <span class="Constant">&quot;      }&quot;</span>, <span class="Special">&amp;</span>
         <span class="Constant">&quot;      // @license-end&quot;</span>, <span class="Special">&amp;</span>
         <span class="Constant">&quot;    &lt;/script&gt;&quot;</span>, <span class="Special">&amp;</span>
         <span class="Constant">&quot;  &lt;/head&gt;&quot;</span>, <span class="Special">&amp;</span>
         <span class="Constant">&quot;  &lt;body onload='enter()'&gt;&quot;</span>, <span class="Special">&amp;</span>
         <span class="Constant">&quot;    &lt;div id='color'&gt;&lt;/div&gt;&quot;</span>, <span class="Special">&amp;</span>
         <span class="Constant">&quot;    &lt;textarea id='mel' spellcheck='false'&quot;</span>, <span class="Special">&amp;</span>
         <span class="Constant">&quot;      oninput='enter()' onscroll='move()'&gt;&quot;</span>, <span class="Special">&amp;</span>
         <span class="Constant">&quot;$22050&quot;</span>, <span class="Special">&amp;</span>
         <span class="Constant">&quot;*Harmonic series and cadence*&quot;</span>, <span class="Special">&amp;</span>
         <span class="Constant">&quot;T pyth&quot;</span>, <span class="Special">&amp;</span>
         <span class="Constant">&quot;X synth&quot;</span>, <span class="Special">&amp;</span>
         <span class="Constant">&quot;M A2'8&quot;</span>, <span class="Special">&amp;</span>
         <span class="Constant">&quot;W ,5 A2' A3' E4' A4' C#v5' E5' Gz5' A5'&quot;</span>, <span class="Special">&amp;</span>
         <span class="Constant">&quot;E4|----0~~~|---2~~~~|-----0~~|----0~~~|&quot;</span>, <span class="Special">&amp;</span>
         <span class="Constant">&quot;B3|---2~~~~|--3~~~~~|----0~~~|---2~~~~|&quot;</span>, <span class="Special">&amp;</span>
         <span class="Constant">&quot;G3|--2~~~~~|-2~~~~~~|---1~~~~|--2~~~~~|&quot;</span>, <span class="Special">&amp;</span>
         <span class="Constant">&quot;D3|-2~~~~~~|0~~~~~~~|--2~~~~~|-2~~~~~~|&quot;</span>, <span class="Special">&amp;</span>
         <span class="Constant">&quot;A2|0~~~~~~~|--------|-2~~~~~~|0~~~~~~~|&quot;</span>, <span class="Special">&amp;</span>
         <span class="Constant">&quot;E2|--------|--------|0~~~~~~~|--------|&lt;/textarea&gt;&quot;</span>, <span class="Special">&amp;</span>
         <span class="Constant">&quot;    &lt;button id='play' onclick='play()'&gt;Interpret&lt;/button&gt;&quot;</span>, <span class="Special">&amp;</span>
         <span class="Constant">&quot;    &lt;audio id='wav' controls autoplay&gt;Sorry&lt;/audio&gt;&quot;</span>, <span class="Special">&amp;</span>
         <span class="Constant">&quot;    Please have a look at the&quot;</span>, <span class="Special">&amp;</span>
         <span class="Constant">&quot;    &lt;a href='<a href="https://io.janberges.de/Tonbandfetzen/">https://io.janberges.de/Tonbandfetzen/</a>'&gt;</span><span class="Special">&amp;</span>
<span class="Constant">         </span><span class="Special">&amp;</span><span class="Constant">documentation&lt;/a&gt; and the&quot;</span>, <span class="Special">&amp;</span>
         <span class="Constant">&quot;    &lt;a href='<a href="https://github.com/janberges/Tonbandfetzen">https://github.com/janberges/Tonbandfetzen</a>'&gt;</span><span class="Special">&amp;</span>
<span class="Constant">         </span><span class="Special">&amp;</span><span class="Constant">source code&lt;/a&gt;.&quot;</span>, <span class="Special">&amp;</span>
         <span class="Constant">&quot;  &lt;/body&gt;&quot;</span>, <span class="Special">&amp;</span>
         <span class="Constant">&quot;&lt;/html&gt;&quot;</span>
   <span class="Statement">else</span>
      <span class="Identifier">call</span> play(preprocess(query), music, limit)

      <span class="Statement">if</span> (music%points <span class="Statement">.eq.</span> <span class="Constant">0</span>) <span class="Identifier">call</span> play(<span class="Constant">&quot;$22050 |1:6 E3' C3'&quot;</span>, music)

      music%amplitude <span class="Statement">=</span> <span class="Constant">1.0_dp</span>

      <span class="Identifier">call</span> write_riff(<span class="Constant">'http'</span>, music)
   <span class="Statement">end if</span>

<span class="PreProc">contains</span>

   <span class="PreProc">function</span> decode(code) <span class="PreProc">result</span>(url)
      <span class="Type">character</span>(:), <span class="Type">allocatable</span> :: url

      <span class="Type">character</span>(<span class="Statement">*</span>), <span class="Type">intent</span>(<span class="Type">in</span>) :: code

      <span class="Type">integer</span> :: i, n

      url <span class="Statement">=</span> code

      i <span class="Statement">=</span> <span class="Constant">1</span>
      <span class="Statement">do</span>
         n <span class="Statement">=</span> <span class="Identifier">index</span>(url(i:), <span class="Constant">'%'</span>)
         <span class="Statement">if</span> (n <span class="Statement">.eq.</span> <span class="Constant">0</span>) <span class="Statement">exit</span>
         i <span class="Statement">=</span> n <span class="Statement">+</span> i

         <span class="Statement">read</span> (url(i:i <span class="Statement">+</span> <span class="Constant">1</span>), <span class="Constant">'(Z2)'</span>) n
         url <span class="Statement">=</span> url(:i <span class="Statement">-</span> <span class="Constant">2</span>) <span class="Statement">//</span> <span class="Identifier">char</span>(n) <span class="Statement">//</span> url(i <span class="Statement">+</span> <span class="Constant">2</span>:)
      <span class="Statement">end do</span>
   <span class="PreProc">end function</span> decode
<span class="PreProc">end program</span> tz_dot_cgi
</pre>
<h2>constants.f90</h2>
<pre id='vimCodeElement'>
<span class="PreProc">module</span> constants
   <span class="PreProc">use</span>, <span class="Type">intrinsic</span> :: <span class="Constant">iso_fortran_env</span>, <span class="PreProc">only</span>: <span class="Special">&amp;</span>
      dp <span class="Statement">=&gt;</span> real64, <span class="Special">&amp;</span>
      eof <span class="Statement">=&gt;</span> <span class="Constant">iostat_end</span>, <span class="Special">&amp;</span>
      eol <span class="Statement">=&gt;</span> <span class="Constant">iostat_eor</span>, <span class="Special">&amp;</span>
      i1 <span class="Statement">=&gt;</span> int8, <span class="Special">&amp;</span>
      i2 <span class="Statement">=&gt;</span> int16, <span class="Special">&amp;</span>
      i4 <span class="Statement">=&gt;</span> int32, <span class="Special">&amp;</span>
      i8 <span class="Statement">=&gt;</span> int64, <span class="Special">&amp;</span>
      stderr <span class="Statement">=&gt;</span> <span class="Constant">error_unit</span>, <span class="Special">&amp;</span>
      stdin <span class="Statement">=&gt;</span> <span class="Constant">input_unit</span>, <span class="Special">&amp;</span>
      stdout <span class="Statement">=&gt;</span> <span class="Constant">output_unit</span>
   <span class="Type">implicit</span> <span class="Type">none</span>
   <span class="Type">public</span>

   <span class="Type">integer</span>(i2), <span class="Type">parameter</span> :: i2max <span class="Statement">=</span> <span class="Identifier">huge</span>(<span class="Constant">1_i2</span>) <span class="Comment">! 2 ** 15 - 1</span>

   <span class="Identifier">real</span>(dp), <span class="Type">parameter</span> :: pi <span class="Statement">=</span> <span class="Constant">4.0_dp</span> <span class="Statement">*</span> <span class="Identifier">atan</span>(<span class="Constant">1.0_dp</span>)

   <span class="Type">type</span> audio
      <span class="Type">integer</span>(i2) :: channels
      <span class="Type">integer</span>(i4) :: points

      <span class="Identifier">real</span>(dp) :: rate
      <span class="Identifier">real</span>(dp) :: amplitude <span class="Statement">=</span> <span class="Constant">1.0_dp</span>

      <span class="Type">integer</span>(i2), <span class="Type">allocatable</span> :: sound(:, :)

      <span class="Type">character</span>(:), <span class="Type">allocatable</span> :: meta
   <span class="Type">end type</span> audio
<span class="PreProc">end module</span> constants
</pre>
<h2>extended.f90</h2>
<pre id='vimCodeElement'>
<span class="PreProc">module</span> extended
   <span class="PreProc">use</span> constants, <span class="PreProc">only</span>: dp
   <span class="Type">implicit</span> <span class="Type">none</span>
   <span class="Type">private</span>

   <span class="Type">public</span> :: decode, encode

<span class="PreProc">contains</span>

   <span class="PreProc">function</span> decode(code) <span class="PreProc">result</span>(x)
      <span class="Identifier">real</span>(dp) :: x

      <span class="Type">character</span>(<span class="Statement">*</span>), <span class="Type">intent</span>(<span class="Type">in</span>) :: code

      <span class="Type">integer</span> :: byte, bytes(<span class="Constant">10</span>), bit, digit, sgn, power
      <span class="Identifier">real</span>(dp) :: mantissa

      <span class="Statement">do</span> byte <span class="Statement">=</span> <span class="Constant">1</span>, <span class="Constant">10</span>
         bytes(byte) <span class="Statement">=</span> <span class="Identifier">ichar</span>(code(byte:byte))
      <span class="Statement">end do</span>

      sgn <span class="Statement">=</span> <span class="Identifier">merge</span>(<span class="Statement">-</span><span class="Constant">1</span>, <span class="Constant">1</span>, <span class="Identifier">btest</span>(bytes(<span class="Constant">1</span>), <span class="Constant">7</span>))
      mantissa <span class="Statement">=</span> <span class="Constant">0.0_dp</span>
      power <span class="Statement">=</span> <span class="Statement">-</span><span class="Constant">16383</span>

      digit <span class="Statement">=</span> <span class="Constant">0</span>
      <span class="Statement">do</span> byte <span class="Statement">=</span> <span class="Constant">2</span>, <span class="Constant">1</span>, <span class="Statement">-</span><span class="Constant">1</span>
         <span class="Statement">do</span> bit <span class="Statement">=</span> <span class="Constant">0</span>, <span class="Constant">5</span> <span class="Statement">+</span> byte
            <span class="Statement">if</span> (<span class="Identifier">btest</span>(bytes(byte), bit)) <span class="Statement">then</span>
               power <span class="Statement">=</span> power <span class="Statement">+</span> <span class="Constant">2</span> <span class="Statement">**</span> digit
            <span class="Statement">end if</span>
            digit <span class="Statement">=</span> digit <span class="Statement">+</span> <span class="Constant">1</span>
         <span class="Statement">end do</span>
      <span class="Statement">end do</span>

      digit <span class="Statement">=</span> <span class="Constant">0</span>
      <span class="Statement">do</span> byte <span class="Statement">=</span> <span class="Constant">3</span>, <span class="Constant">10</span>
         <span class="Statement">do</span> bit <span class="Statement">=</span> <span class="Constant">7</span>, <span class="Constant">0</span>, <span class="Statement">-</span><span class="Constant">1</span>
            <span class="Statement">if</span> (<span class="Identifier">btest</span>(bytes(byte), bit)) <span class="Statement">then</span>
               mantissa <span class="Statement">=</span> mantissa <span class="Statement">+</span> <span class="Constant">2.0_dp</span> <span class="Statement">**</span> digit
            <span class="Statement">end if</span>
            digit <span class="Statement">=</span> digit <span class="Statement">-</span> <span class="Constant">1</span>
         <span class="Statement">end do</span>
      <span class="Statement">end do</span>

      x <span class="Statement">=</span> sgn <span class="Statement">*</span> mantissa <span class="Statement">*</span> <span class="Constant">2.0_dp</span> <span class="Statement">**</span> power
   <span class="PreProc">end function</span> decode

   <span class="PreProc">function</span> encode(x) <span class="PreProc">result</span>(code)
      <span class="Type">character</span>(<span class="Constant">10</span>) :: code

      <span class="Identifier">real</span>(dp), <span class="Type">intent</span>(<span class="Type">in</span>) :: x

      <span class="Type">integer</span> :: byte, bytes(<span class="Constant">10</span>), bit, power
      <span class="Identifier">real</span>(dp) :: mantissa

      power <span class="Statement">=</span> <span class="Identifier">int</span>(<span class="Identifier">log</span>(<span class="Identifier">abs</span>(x)) <span class="Statement">/</span> <span class="Identifier">log</span>(<span class="Constant">2.0_dp</span>))
      mantissa <span class="Statement">=</span> <span class="Identifier">abs</span>(x) <span class="Statement">/</span> <span class="Constant">2.0_dp</span> <span class="Statement">**</span> power
      power <span class="Statement">=</span> power <span class="Statement">+</span> <span class="Constant">16383</span>

      bytes <span class="Statement">=</span> <span class="Constant">0</span>

      <span class="Statement">if</span> (x <span class="Statement">.lt.</span> <span class="Constant">0.0_dp</span>) bytes(<span class="Constant">1</span>) <span class="Statement">=</span> <span class="Identifier">ibset</span>(bytes(<span class="Constant">1</span>), <span class="Constant">7</span>)

      <span class="Statement">do</span> byte <span class="Statement">=</span> <span class="Constant">2</span>, <span class="Constant">1</span>, <span class="Statement">-</span><span class="Constant">1</span>
         <span class="Statement">do</span> bit <span class="Statement">=</span> <span class="Constant">0</span>, <span class="Constant">5</span> <span class="Statement">+</span> byte
            <span class="Statement">if</span> (<span class="Identifier">modulo</span>(power, <span class="Constant">2</span>) <span class="Statement">.eq.</span> <span class="Constant">1</span>) <span class="Statement">then</span>
               bytes(byte) <span class="Statement">=</span> <span class="Identifier">ibset</span>(bytes(byte), bit)
            <span class="Statement">end if</span>
            power <span class="Statement">=</span> power <span class="Statement">/</span> <span class="Constant">2</span>
         <span class="Statement">end do</span>
      <span class="Statement">end do</span>

      <span class="Statement">do</span> byte <span class="Statement">=</span> <span class="Constant">3</span>, <span class="Constant">10</span>
         <span class="Statement">do</span> bit <span class="Statement">=</span> <span class="Constant">7</span>, <span class="Constant">0</span>, <span class="Statement">-</span><span class="Constant">1</span>
            <span class="Statement">if</span> (mantissa <span class="Statement">.ge.</span> <span class="Constant">1.0_dp</span>) <span class="Statement">then</span>
               mantissa <span class="Statement">=</span> mantissa <span class="Statement">-</span> <span class="Constant">1.0_dp</span>
               bytes(byte) <span class="Statement">=</span> <span class="Identifier">ibset</span>(bytes(byte), bit)
            <span class="Statement">end if</span>
            mantissa <span class="Statement">=</span> <span class="Constant">2.0_dp</span> <span class="Statement">*</span> mantissa
         <span class="Statement">end do</span>
      <span class="Statement">end do</span>

      <span class="Statement">do</span> byte <span class="Statement">=</span> <span class="Constant">1</span>, <span class="Constant">10</span>
         code(byte:byte) <span class="Statement">=</span> <span class="Identifier">char</span>(bytes(byte))
      <span class="Statement">end do</span>
   <span class="PreProc">end function</span> encode
<span class="PreProc">end module</span> extended
</pre>
<h2>fjs.f90</h2>
<pre id='vimCodeElement'>
<span class="Comment">! The Functional Just System (FJS) has been invented by misotanni.</span>
<span class="Comment">! For a complete description, see <a href="https://misotanni.github.io/fjs.">https://misotanni.github.io/fjs.</a></span>
<span class="Comment">! Here, we only use the microtonal accidentals defined by the FJS.</span>

<span class="PreProc">module</span> fjs
   <span class="PreProc">use</span> constants, <span class="PreProc">only</span>: dp
   <span class="Type">implicit</span> <span class="Type">none</span>
   <span class="Type">private</span>

   <span class="Type">public</span> :: accidentals, comma

<span class="PreProc">contains</span>

   <span class="PreProc">function</span> factorize(n) <span class="PreProc">result</span>(primes)
      <span class="Type">integer</span>, <span class="Type">allocatable</span> :: primes(:)
      <span class="Type">integer</span>, <span class="Type">intent</span>(<span class="Type">in</span>) :: n

      <span class="Type">integer</span> :: i, j

      <span class="Statement">allocate</span>(primes(<span class="Constant">1</span>:n))
      primes <span class="Statement">=</span> <span class="Constant">0</span>

      i <span class="Statement">=</span> n
      j <span class="Statement">=</span> <span class="Constant">2</span>

      <span class="Statement">do</span> <span class="Statement">while</span> (i <span class="Statement">.gt.</span> <span class="Constant">1</span>)
         <span class="Statement">if</span> (<span class="Identifier">modulo</span>(i, j) <span class="Statement">.eq.</span> <span class="Constant">0</span>) <span class="Statement">then</span>
            primes(j) <span class="Statement">=</span> primes(j) <span class="Statement">+</span> <span class="Constant">1</span>
            i <span class="Statement">=</span> i <span class="Statement">/</span> j
         <span class="Statement">else</span>
            j <span class="Statement">=</span> j <span class="Statement">+</span> <span class="Constant">1</span>
         <span class="Statement">end if</span>
      <span class="Statement">end do</span>
   <span class="PreProc">end function</span> factorize

   <span class="PreProc">function</span> accidentals(ratio)
      <span class="Type">integer</span>, <span class="Type">allocatable</span> :: accidentals(:)

      <span class="Type">character</span>(<span class="Statement">*</span>), <span class="Type">intent</span>(<span class="Type">in</span>) :: ratio

      <span class="Type">integer</span> :: i, j, error
      <span class="Type">integer</span> :: numerator, denominator
      <span class="Type">integer</span>, <span class="Type">allocatable</span> :: primes(:), tmp(:)

      numerator <span class="Statement">=</span> <span class="Constant">1</span>
      denominator <span class="Statement">=</span> <span class="Constant">1</span>

      i <span class="Statement">=</span> <span class="Identifier">scan</span>(ratio, <span class="Constant">':/'</span>)
      <span class="Statement">if</span> (i <span class="Statement">.eq.</span> <span class="Constant">0</span>) i <span class="Statement">=</span> <span class="Identifier">len</span>(ratio) <span class="Statement">+</span> <span class="Constant">1</span>

      <span class="Statement">read</span> (ratio(:i <span class="Statement">-</span> <span class="Constant">1</span>), <span class="Statement">*</span>, <span class="Statement">iostat</span><span class="Statement">=</span>error) j
      <span class="Statement">if</span> (error <span class="Statement">.eq.</span> <span class="Constant">0</span>) numerator <span class="Statement">=</span> j

      <span class="Statement">read</span> (ratio(i <span class="Statement">+</span> <span class="Constant">1</span>:), <span class="Statement">*</span>, <span class="Statement">iostat</span><span class="Statement">=</span>error) j
      <span class="Statement">if</span> (error <span class="Statement">.eq.</span> <span class="Constant">0</span>) denominator <span class="Statement">=</span> j

      <span class="Statement">allocate</span>(primes(<span class="Constant">1</span>:<span class="Identifier">max</span>(numerator, denominator)))
      primes <span class="Statement">=</span> <span class="Constant">0</span>

      tmp <span class="Statement">=</span> factorize(numerator)
      primes(:<span class="Identifier">size</span>(tmp)) <span class="Statement">=</span> primes(:<span class="Identifier">size</span>(tmp)) <span class="Statement">+</span> tmp

      tmp <span class="Statement">=</span> factorize(denominator)
      primes(:<span class="Identifier">size</span>(tmp)) <span class="Statement">=</span> primes(:<span class="Identifier">size</span>(tmp)) <span class="Statement">-</span> tmp

      <span class="Statement">allocate</span>(accidentals(<span class="Identifier">sum</span>(<span class="Identifier">abs</span>(primes))))

      j <span class="Statement">=</span> <span class="Constant">1</span>
      <span class="Statement">do</span> i <span class="Statement">=</span> <span class="Constant">1</span>, <span class="Identifier">size</span>(primes)
         accidentals(j:) <span class="Statement">=</span> <span class="Identifier">sign</span>(i, primes(i))
         j <span class="Statement">=</span> j <span class="Statement">+</span> <span class="Identifier">abs</span>(primes(i))
      <span class="Statement">end do</span>
   <span class="PreProc">end function</span> accidentals

   <span class="Type">elemental</span> <span class="PreProc">function</span> red(d)
      <span class="Identifier">real</span>(dp) :: red
      <span class="Identifier">real</span>(dp), <span class="Type">intent</span>(<span class="Type">in</span>) :: d

      red <span class="Statement">=</span> d <span class="Statement">/</span> <span class="Constant">2.0_dp</span> <span class="Statement">**</span> <span class="Identifier">floor</span>(<span class="Identifier">log</span>(d) <span class="Statement">/</span> <span class="Identifier">log</span>(<span class="Constant">2.0_dp</span>))
   <span class="PreProc">end function</span> red

   <span class="Type">elemental</span> <span class="PreProc">function</span> reb(d)
      <span class="Identifier">real</span>(dp) :: reb
      <span class="Identifier">real</span>(dp), <span class="Type">intent</span>(<span class="Type">in</span>) :: d

      reb <span class="Statement">=</span> red(<span class="Identifier">sqrt</span>(<span class="Constant">2.0_dp</span>) <span class="Statement">*</span> red(d)) <span class="Statement">/</span> <span class="Identifier">sqrt</span>(<span class="Constant">2.0_dp</span>)
   <span class="PreProc">end function</span> reb

   <span class="Type">elemental</span> <span class="PreProc">function</span> cents(d)
      <span class="Identifier">real</span>(dp) :: cents
      <span class="Identifier">real</span>(dp), <span class="Type">intent</span>(<span class="Type">in</span>) :: d

      cents <span class="Statement">=</span> <span class="Constant">1200.0_dp</span> <span class="Statement">*</span> <span class="Identifier">log</span>(d) <span class="Statement">/</span> <span class="Identifier">log</span>(<span class="Constant">2.0_dp</span>)
   <span class="PreProc">end function</span> cents

   <span class="Type">elemental</span> <span class="PreProc">function</span> error(d)
      <span class="Identifier">real</span>(dp) :: error
      <span class="Identifier">real</span>(dp), <span class="Type">intent</span>(<span class="Type">in</span>) :: d

      error <span class="Statement">=</span> <span class="Identifier">abs</span>(cents(reb(d)))
   <span class="PreProc">end function</span> error

   <span class="Type">elemental</span> <span class="PreProc">function</span> master(d) <span class="PreProc">result</span>(f)
      <span class="Type">integer</span> :: f
      <span class="Identifier">real</span>(dp), <span class="Type">intent</span>(<span class="Type">in</span>) :: d

      <span class="Identifier">real</span>(dp) :: tol

      tol <span class="Statement">=</span> error(<span class="Constant">65.0_dp</span> <span class="Statement">/</span> <span class="Constant">63.0_dp</span>)

      f <span class="Statement">=</span> <span class="Constant">0</span>
      <span class="Statement">do</span> <span class="Statement">while</span> (error(d <span class="Statement">/</span> <span class="Constant">3.0_dp</span> <span class="Statement">**</span> f) <span class="Statement">.ge.</span> tol)
         f <span class="Statement">=</span> <span class="Statement">-</span>f
         <span class="Statement">if</span> (f <span class="Statement">.ge.</span> <span class="Constant">0</span>) f <span class="Statement">=</span> f <span class="Statement">+</span> <span class="Constant">1</span>
      <span class="Statement">end do</span>
   <span class="PreProc">end function</span> master

   <span class="Type">elemental</span> <span class="PreProc">function</span> comma(p)
      <span class="Identifier">real</span>(dp) :: comma
      <span class="Type">integer</span>, <span class="Type">intent</span>(<span class="Type">in</span>) :: p

      <span class="Identifier">real</span>(dp), <span class="Type">parameter</span> :: Pyth_comma <span class="Statement">=</span> <span class="Constant">3.0_dp</span> <span class="Statement">**</span> <span class="Constant">12</span> <span class="Statement">/</span> <span class="Constant">2.0_dp</span> <span class="Statement">**</span> <span class="Constant">19</span>
      <span class="Type">integer</span> :: d

      d <span class="Statement">=</span> <span class="Identifier">abs</span>(p)

      <span class="Statement">if</span> (d <span class="Statement">.eq.</span> <span class="Constant">3</span>) <span class="Statement">then</span>
         comma <span class="Statement">=</span> Pyth_comma
      <span class="Statement">else</span>
         comma <span class="Statement">=</span> reb(d <span class="Statement">/</span> <span class="Constant">3.0_dp</span> <span class="Statement">**</span> master(<span class="Identifier">real</span>(d, dp)))
      <span class="Statement">end if</span>

      <span class="Statement">if</span> (p <span class="Statement">.lt.</span> <span class="Constant">0</span>) comma <span class="Statement">=</span> <span class="Constant">1.0_dp</span> <span class="Statement">/</span> comma
   <span class="PreProc">end function</span> comma
<span class="PreProc">end module</span> fjs
</pre>
<h2>guitar.f90</h2>
<pre id='vimCodeElement'>
<span class="PreProc">subroutine</span> guitar
   <span class="PreProc">use</span> constants, <span class="PreProc">only</span>: stderr
   <span class="PreProc">use</span> io, <span class="PreProc">only</span>: command_argument, slurp
   <span class="PreProc">use</span> tab, <span class="PreProc">only</span>: preprocess
   <span class="Type">implicit</span> <span class="Type">none</span>

   <span class="Type">integer</span> :: fun, error

   <span class="Type">character</span>(:), <span class="Type">allocatable</span> :: path, notes

   notes <span class="Statement">=</span> preprocess(slurp(command_argument(<span class="Constant">1</span>, <span class="Constant">'/dev/stdin'</span>)))

   path <span class="Statement">=</span> command_argument(<span class="Constant">2</span>, <span class="Constant">'/dev/stdout'</span>)

   <span class="Statement">if</span> (path <span class="Statement">.eq.</span> <span class="Constant">'stdout'</span>) <span class="Statement">then</span>
      <span class="Statement">write</span> (<span class="Statement">*</span>, <span class="Constant">'(A)'</span>, <span class="Statement">advance</span><span class="Statement">=</span><span class="Constant">'no'</span>) notes
   <span class="Statement">else</span>
      <span class="Statement">open</span> (<span class="Statement">newunit</span><span class="Statement">=</span>fun, <span class="Statement">file</span><span class="Statement">=</span>path, <span class="Statement">iostat</span><span class="Statement">=</span>error, <span class="Special">&amp;</span>
         <span class="Statement">action</span><span class="Statement">=</span><span class="Constant">'write'</span>, <span class="Statement">status</span><span class="Statement">=</span><span class="Constant">'replace'</span>, <span class="Statement">access</span><span class="Statement">=</span><span class="Constant">'stream'</span>)

      <span class="Statement">if</span> (error <span class="Statement">.ne.</span> <span class="Constant">0</span>) <span class="Statement">then</span>
         <span class="Statement">write</span> (stderr, <span class="Constant">&quot;('Error: Cannot write file ''', A, '''.')&quot;</span>) path
         <span class="Statement">stop</span>
      <span class="Statement">end if</span>

      <span class="Statement">write</span> (fun) notes
      <span class="Statement">close</span> (fun)
   <span class="Statement">end if</span>
<span class="PreProc">end subroutine</span> guitar
</pre>
<h2>harmonics.f90</h2>
<pre id='vimCodeElement'>
<span class="PreProc">subroutine</span> harmonics
   <span class="PreProc">use</span> constants, <span class="PreProc">only</span>: dp
   <span class="PreProc">use</span> io, <span class="PreProc">only</span>: command_argument
   <span class="PreProc">use</span> samples, <span class="PreProc">only</span>: sample
   <span class="PreProc">use</span> spectra, <span class="PreProc">only</span>: fourier
   <span class="Type">implicit</span> <span class="Type">none</span>

   <span class="Type">integer</span> :: n
   <span class="Type">integer</span>, <span class="Type">parameter</span> :: nmax <span class="Statement">=</span> <span class="Constant">99</span>

   <span class="Identifier">real</span>(dp) :: wave(<span class="Constant">2</span> <span class="Statement">*</span> nmax), amplitude, phase
   <span class="Type">complex</span>(dp) :: spectrum(nmax)

   <span class="Identifier">call</span> sample(wave, <span class="Constant">'wave'</span>, command_argument(<span class="Constant">1</span>, <span class="Constant">'circular'</span>))

   <span class="Identifier">call</span> fourier(wave, spectrum)

   <span class="Statement">write</span> (<span class="Statement">*</span>, <span class="Constant">&quot;(/ 'f(t) = sum r[n] cos(n omega t - phi[n])' /)&quot;</span>)
   <span class="Statement">write</span> (<span class="Statement">*</span>, <span class="Constant">'(A2, 2A15)'</span>) <span class="Constant">'n'</span>, <span class="Constant">'r[n]'</span>, <span class="Constant">'phi[n]'</span>

   <span class="Statement">do</span> n <span class="Statement">=</span> <span class="Constant">1</span>, <span class="Identifier">size</span>(spectrum)
      amplitude <span class="Statement">=</span> <span class="Constant">2.0_dp</span> <span class="Statement">*</span> <span class="Identifier">abs</span>(spectrum(n))

      <span class="Statement">if</span> (amplitude <span class="Statement">.lt.</span> <span class="Constant">1e-10_dp</span>) <span class="Statement">cycle</span>

      phase <span class="Statement">=</span> <span class="Identifier">atan2</span>(<span class="Identifier">aimag</span>(spectrum(n)), <span class="Identifier">real</span>(spectrum(n)))

      <span class="Statement">write</span> (<span class="Statement">*</span>, <span class="Constant">'(I2, 2F15.10)'</span>) n, amplitude, phase
   <span class="Statement">end do</span>
<span class="PreProc">end subroutine</span> harmonics
</pre>
<h2>id3.f90</h2>
<pre id='vimCodeElement'>
<span class="PreProc">module</span> id3
   <span class="PreProc">use</span> constants, <span class="PreProc">only</span>: dp, eof, i1, stderr
   <span class="PreProc">use</span> io, <span class="PreProc">only</span>: slurp
   <span class="PreProc">use</span> paths, <span class="PreProc">only</span>: extension
   <span class="Type">implicit</span> <span class="Type">none</span>
   <span class="Type">private</span>

   <span class="Type">public</span> :: read_id3, write_id3

<span class="PreProc">contains</span>

   <span class="PreProc">subroutine</span> read_id3(id3)
      <span class="Type">character</span>(<span class="Statement">*</span>), <span class="Type">intent</span>(<span class="Type">in</span>) :: id3

      <span class="Type">integer</span> :: i, n, flags, tagSize, frameSize
      <span class="Type">integer</span>(i1) :: version, revision
      <span class="Type">character</span>(<span class="Constant">3</span>) :: tagID
      <span class="Type">character</span>(<span class="Constant">4</span>) :: frameID
      <span class="Type">character</span>(:), <span class="Type">allocatable</span> :: feature, text

      tagID <span class="Statement">=</span> id3(<span class="Constant">1</span>:<span class="Constant">3</span>)

      <span class="Statement">if</span> (tagID <span class="Statement">.eq.</span> <span class="Constant">'TAG'</span>) <span class="Statement">then</span>
         <span class="Statement">write</span> (stderr, <span class="Constant">&quot;('Warning: ID3v1 not supported.')&quot;</span>) feature
         <span class="Statement">return</span>
      <span class="Statement">end if</span>

      version <span class="Statement">=</span> <span class="Identifier">ichar</span>(id3(<span class="Constant">4</span>:<span class="Constant">4</span>), i1)
      revision <span class="Statement">=</span> <span class="Identifier">ichar</span>(id3(<span class="Constant">5</span>:<span class="Constant">5</span>), i1)

      <span class="Statement">if</span> (version <span class="Statement">.le.</span> <span class="Constant">2</span>) <span class="Statement">then</span>
         <span class="Statement">write</span> (stderr, <span class="Constant">&quot;('Warning: ', A, 'v2.', I0, ' not supported.')&quot;</span>) <span class="Special">&amp;</span>
            tagID, version
         <span class="Statement">return</span>
      <span class="Statement">end if</span>

      <span class="Statement">write</span> (stderr, <span class="Constant">&quot;('Metadata format: ', A, 'v2.', I0, '.', I0)&quot;</span>) <span class="Special">&amp;</span>
         tagID, version, revision

      flags <span class="Statement">=</span> <span class="Identifier">ichar</span>(id3(<span class="Constant">6</span>:<span class="Constant">6</span>))

      <span class="Statement">do</span> i <span class="Statement">=</span> <span class="Constant">7</span>, <span class="Constant">4</span>, <span class="Statement">-</span><span class="Constant">1</span>
         <span class="Statement">if</span> (<span class="Identifier">btest</span>(flags, i)) <span class="Statement">then</span>
            <span class="Statement">select case</span> (i)
            <span class="Statement">case</span> (<span class="Constant">7</span>)
               feature <span class="Statement">=</span> <span class="Constant">'unsynchronisation'</span>
            <span class="Statement">case</span> (<span class="Constant">6</span>)
               feature <span class="Statement">=</span> <span class="Constant">'extended header'</span>
            <span class="Statement">case</span> (<span class="Constant">5</span>)
               feature <span class="Statement">=</span> <span class="Constant">'experimental tag'</span>
            <span class="Statement">case</span> (<span class="Constant">4</span>)
               feature <span class="Statement">=</span> <span class="Constant">'footer'</span>
            <span class="Statement">end select</span>

            <span class="Statement">write</span> (stderr, <span class="Constant">&quot;('Warning: ID3 ', A, ' not supported.')&quot;</span>) feature
            <span class="Statement">return</span>
         <span class="Statement">end if</span>
      <span class="Statement">end do</span>

      i <span class="Statement">=</span> <span class="Constant">10</span>

      tagSize <span class="Statement">=</span> decode_size(id3(<span class="Constant">7</span>:<span class="Constant">10</span>))

      <span class="Statement">do</span> <span class="Statement">while</span> (i <span class="Statement">.lt.</span> <span class="Constant">10</span> <span class="Statement">+</span> tagSize)
         <span class="Statement">if</span> (<span class="Identifier">ichar</span>(id3(i <span class="Statement">+</span> <span class="Constant">1</span>:i <span class="Statement">+</span> <span class="Constant">1</span>)) <span class="Statement">.eq.</span> <span class="Constant">0</span>) <span class="Statement">exit</span>

         frameID <span class="Statement">=</span> id3(i <span class="Statement">+</span> <span class="Constant">1</span>:i <span class="Statement">+</span> <span class="Constant">4</span>)

         <span class="Statement">select case</span> (frameID)
         <span class="Statement">case</span> (<span class="Constant">'APIC'</span>)
            feature <span class="Statement">=</span> <span class="Constant">'picture'</span>
         <span class="Statement">case</span> (<span class="Constant">'COMM'</span>)
            feature <span class="Statement">=</span> <span class="Constant">'comment'</span>
         <span class="Statement">case</span> (<span class="Constant">'PRIV'</span>)
            feature <span class="Statement">=</span> <span class="Constant">'private'</span>
         <span class="Statement">case</span> (<span class="Constant">'TALB'</span>)
            feature <span class="Statement">=</span> <span class="Constant">'album'</span>
         <span class="Statement">case</span> (<span class="Constant">'TCOM'</span>)
            feature <span class="Statement">=</span> <span class="Constant">'composer'</span>
         <span class="Statement">case</span> (<span class="Constant">'TCON'</span>)
            feature <span class="Statement">=</span> <span class="Constant">'genre'</span>
         <span class="Statement">case</span> (<span class="Constant">'TCOP'</span>)
            feature <span class="Statement">=</span> <span class="Constant">'copyright'</span>
         <span class="Statement">case</span> (<span class="Constant">'TENC'</span>)
            feature <span class="Statement">=</span> <span class="Constant">'encoded by'</span>
         <span class="Statement">case</span> (<span class="Constant">'TIT2'</span>)
            feature <span class="Statement">=</span> <span class="Constant">'title'</span>
         <span class="Statement">case</span> (<span class="Constant">'TLEN'</span>)
            feature <span class="Statement">=</span> <span class="Constant">'duration/ms'</span>
         <span class="Statement">case</span> (<span class="Constant">'TOPE'</span>)
            feature <span class="Statement">=</span> <span class="Constant">'original artist'</span>
         <span class="Statement">case</span> (<span class="Constant">'TPE1'</span>)
            feature <span class="Statement">=</span> <span class="Constant">'artist'</span>
         <span class="Statement">case</span> (<span class="Constant">'TPE2'</span>)
            feature <span class="Statement">=</span> <span class="Constant">'album artist'</span>
         <span class="Statement">case</span> (<span class="Constant">'TPOS'</span>)
            feature <span class="Statement">=</span> <span class="Constant">'disc number'</span>
         <span class="Statement">case</span> (<span class="Constant">'TRCK'</span>)
            feature <span class="Statement">=</span> <span class="Constant">'track number'</span>
         <span class="Statement">case</span> (<span class="Constant">'TYER'</span>)
            feature <span class="Statement">=</span> <span class="Constant">'year'</span>
         <span class="Statement">case</span> (<span class="Constant">'WAAA'</span>:<span class="Constant">'WXXX'</span>)
            feature <span class="Statement">=</span> <span class="Constant">'website'</span>
         <span class="Statement">case</span> <span class="Statement">default</span>
            feature <span class="Statement">=</span> <span class="Constant">'unknown'</span>
         <span class="Statement">end select</span>

         frameSize <span class="Statement">=</span> decode_size(id3(i <span class="Statement">+</span> <span class="Constant">5</span>:i <span class="Statement">+</span> <span class="Constant">8</span>), synchsafe<span class="Statement">=</span>version <span class="Statement">.eq.</span> <span class="Constant">4_i1</span>)

         flags <span class="Statement">=</span> <span class="Identifier">ichar</span>(id3(i <span class="Statement">+</span> <span class="Constant">9</span>:i <span class="Statement">+</span> <span class="Constant">9</span>))

         <span class="Statement">if</span> (<span class="Identifier">btest</span>(flags, <span class="Constant">6</span>)) <span class="Statement">write</span> (stderr, <span class="Constant">&quot;(A, ' tag-bound')&quot;</span>) frameID
         <span class="Statement">if</span> (<span class="Identifier">btest</span>(flags, <span class="Constant">5</span>)) <span class="Statement">write</span> (stderr, <span class="Constant">&quot;(A, ' file-bound')&quot;</span>) frameID
         <span class="Statement">if</span> (<span class="Identifier">btest</span>(flags, <span class="Constant">4</span>)) <span class="Statement">write</span> (stderr, <span class="Constant">&quot;(A, ' read-only')&quot;</span>) frameID

         flags <span class="Statement">=</span> <span class="Identifier">ichar</span>(id3(i <span class="Statement">+</span> <span class="Constant">10</span>:i <span class="Statement">+</span> <span class="Constant">10</span>))

         <span class="Statement">if</span> (<span class="Identifier">btest</span>(flags, <span class="Constant">6</span>)) <span class="Statement">write</span> (stderr, <span class="Constant">&quot;(A, ' grouped')&quot;</span>) frameID
         <span class="Statement">if</span> (<span class="Identifier">btest</span>(flags, <span class="Constant">3</span>)) <span class="Statement">write</span> (stderr, <span class="Constant">&quot;(A, ' compressed')&quot;</span>) frameID
         <span class="Statement">if</span> (<span class="Identifier">btest</span>(flags, <span class="Constant">2</span>)) <span class="Statement">write</span> (stderr, <span class="Constant">&quot;(A, ' encrypted')&quot;</span>) frameID
         <span class="Statement">if</span> (<span class="Identifier">btest</span>(flags, <span class="Constant">1</span>)) <span class="Statement">write</span> (stderr, <span class="Constant">&quot;(A, ' unsyrchronised')&quot;</span>) frameID
         <span class="Statement">if</span> (<span class="Identifier">btest</span>(flags, <span class="Constant">0</span>)) <span class="Statement">write</span> (stderr, <span class="Constant">&quot;(A, ' states length')&quot;</span>) frameID

         i <span class="Statement">=</span> i <span class="Statement">+</span> <span class="Constant">10</span>

         <span class="Statement">if</span> (frameID(<span class="Constant">1</span>:<span class="Constant">1</span>) <span class="Statement">.eq.</span> <span class="Constant">'T'</span>) <span class="Statement">then</span>
            text <span class="Statement">=</span> id3(i <span class="Statement">+</span> <span class="Constant">2</span>:i <span class="Statement">+</span> frameSize)

            <span class="Statement">select case</span> (<span class="Identifier">ichar</span>(id3(i <span class="Statement">+</span> <span class="Constant">1</span>:i <span class="Statement">+</span> <span class="Constant">1</span>)))
            <span class="Statement">case</span> (<span class="Constant">0</span>) <span class="Comment">! ISO-8859-1</span>
               text <span class="Statement">=</span> encode_utf8(decode_iso8859_1(text))
            <span class="Statement">case</span> (<span class="Constant">1</span>, <span class="Constant">2</span>) <span class="Comment">! UTF-16, UTF-16BE</span>
               text <span class="Statement">=</span> encode_utf8(decode_utf16(text))
            <span class="Statement">case</span> (<span class="Constant">3</span>) <span class="Comment">! UTF-8</span>
               <span class="Statement">continue</span>
            <span class="Statement">end select</span>

            <span class="Statement">do</span>
               n <span class="Statement">=</span> <span class="Identifier">index</span>(text, <span class="Identifier">char</span>(<span class="Constant">0</span>))

               <span class="Statement">if</span> (n <span class="Statement">.eq.</span> <span class="Constant">0</span>) <span class="Statement">exit</span>

               <span class="Statement">if</span> (n <span class="Statement">.eq.</span> <span class="Identifier">len</span>(text)) <span class="Statement">then</span>
                  text <span class="Statement">=</span> text(:n <span class="Statement">-</span> <span class="Constant">1</span>)
               <span class="Statement">else</span>
                  text <span class="Statement">=</span> text(:n <span class="Statement">-</span> <span class="Constant">1</span>) <span class="Statement">//</span> <span class="Constant">'/'</span> <span class="Statement">//</span> text(n <span class="Statement">+</span> <span class="Constant">1</span>:)
               <span class="Statement">end if</span>
            <span class="Statement">end do</span>
         <span class="Statement">else</span>
            text <span class="Statement">=</span> <span class="Identifier">repeat</span>(<span class="Constant">' '</span>, <span class="Constant">64</span>)
            <span class="Statement">write</span> (text, <span class="Constant">&quot;(I0, ' bytes')&quot;</span>) frameSize
            text <span class="Statement">=</span> <span class="Identifier">trim</span>(text)
         <span class="Statement">end if</span>

         <span class="Statement">if</span> (feature <span class="Statement">.ne.</span> <span class="Constant">'unknown'</span>) <span class="Statement">then</span>
            <span class="Statement">write</span> (stderr, <span class="Constant">&quot;(A, ' (', A, '): ', A)&quot;</span>) frameID, feature, text
         <span class="Statement">else</span>
            <span class="Statement">write</span> (stderr, <span class="Constant">&quot;(A, ': ', A)&quot;</span>) frameID, text
         <span class="Statement">end if</span>

         i <span class="Statement">=</span> i <span class="Statement">+</span> frameSize
      <span class="Statement">end do</span>
   <span class="PreProc">end subroutine</span> read_id3

   <span class="PreProc">function</span> write_id3(path) <span class="PreProc">result</span>(id3)
      <span class="Type">character</span>(:), <span class="Type">allocatable</span> :: id3

      <span class="Type">character</span>(<span class="Statement">*</span>), <span class="Type">intent</span>(<span class="Type">in</span>) :: path

      <span class="Type">character</span>(<span class="Constant">4</span>) :: frameID
      <span class="Type">character</span>(<span class="Constant">256</span>) :: buffer
      <span class="Type">character</span>(:), <span class="Type">allocatable</span> :: text, mime

      <span class="Type">integer</span>(i1), <span class="Type">parameter</span> :: version <span class="Statement">=</span> <span class="Constant">4_i1</span>
      <span class="Type">integer</span>(i1), <span class="Type">parameter</span> :: revision <span class="Statement">=</span> <span class="Constant">0_i1</span>
      <span class="Type">integer</span>(i1), <span class="Type">parameter</span> :: flags <span class="Statement">=</span> <span class="Constant">0_i1</span>
      <span class="Type">integer</span>(i1), <span class="Type">parameter</span> :: encoding <span class="Statement">=</span> <span class="Constant">3_i1</span>

      <span class="Type">integer</span> :: fun, error
      <span class="Type">logical</span> :: exists

      <span class="Statement">inquire</span> (<span class="Statement">file</span><span class="Statement">=</span>path, <span class="Statement">exist</span><span class="Statement">=</span>exists)

      id3 <span class="Statement">=</span> <span class="Constant">''</span>

      <span class="Statement">if</span> (exists) <span class="Statement">then</span>
         <span class="Statement">open</span> (<span class="Statement">newunit</span><span class="Statement">=</span>fun, <span class="Statement">file</span><span class="Statement">=</span>path, <span class="Statement">action</span><span class="Statement">=</span><span class="Constant">'read'</span>, <span class="Statement">status</span><span class="Statement">=</span><span class="Constant">'old'</span>, <span class="Special">&amp;</span>
            <span class="Statement">iostat</span><span class="Statement">=</span>error)

         <span class="Statement">if</span> (error <span class="Statement">.ne.</span> <span class="Constant">0</span>) <span class="Statement">then</span>
            <span class="Statement">write</span> (stderr, <span class="Constant">&quot;('Error: Cannot read ID3 file ''', A, '''.')&quot;</span>) path
            <span class="Statement">stop</span>
         <span class="Statement">end if</span>

         <span class="Statement">do</span>
            <span class="Statement">read</span> (fun, <span class="Constant">'(A4, 1X, A)'</span>, <span class="Statement">iostat</span><span class="Statement">=</span>error) frameID, buffer
            text <span class="Statement">=</span> <span class="Identifier">trim</span>(buffer)

            <span class="Statement">if</span> (error <span class="Statement">.eq.</span> eof) <span class="Statement">exit</span>

            <span class="Statement">if</span> (frameID <span class="Statement">.eq.</span> <span class="Constant">'APIC'</span>) <span class="Statement">then</span>
               <span class="Statement">select case</span>(extension(text))
               <span class="Statement">case</span> (<span class="Constant">'jpeg'</span>, <span class="Constant">'jpg'</span>, <span class="Constant">'JPEG'</span>, <span class="Constant">'JPG'</span>)
                  mime <span class="Statement">=</span> <span class="Constant">'image/jpeg'</span>
               <span class="Statement">case</span> (<span class="Constant">'png'</span>, <span class="Constant">'PNG'</span>)
                  mime <span class="Statement">=</span> <span class="Constant">'image/png'</span>
               <span class="Statement">case</span> (<span class="Constant">'svg'</span>, <span class="Constant">'SVG'</span>)
                  mime <span class="Statement">=</span> <span class="Constant">'image/svg+xml'</span>
               <span class="Statement">case</span> (<span class="Constant">'tiff'</span>, <span class="Constant">'tif'</span>, <span class="Constant">'TIFF'</span>, <span class="Constant">'TIF'</span>)
                  mime <span class="Statement">=</span> <span class="Constant">'image/tiff'</span>
               <span class="Statement">case</span> (<span class="Constant">'gif'</span>, <span class="Constant">'GIF'</span>)
                  mime <span class="Statement">=</span> <span class="Constant">'image/gif'</span>
               <span class="Statement">case</span> (<span class="Constant">'bmp'</span>, <span class="Constant">'BMP'</span>)
                  mime <span class="Statement">=</span> <span class="Constant">'image/bmp'</span>
               <span class="Statement">end select</span>

               text <span class="Statement">=</span> mime <span class="Statement">//</span> <span class="Identifier">char</span>(<span class="Constant">0</span>) <span class="Statement">//</span> <span class="Identifier">char</span>(<span class="Constant">3</span>) <span class="Statement">//</span> <span class="Constant">'cover'</span> <span class="Statement">//</span> <span class="Identifier">char</span>(<span class="Constant">0</span>) <span class="Special">&amp;</span>
                  <span class="Statement">//</span> slurp(text)
            <span class="Statement">else</span> <span class="Statement">if</span> (frameID(<span class="Constant">1</span>:<span class="Constant">1</span>) <span class="Statement">.ne.</span> <span class="Constant">'T'</span>) <span class="Statement">then</span>
               <span class="Statement">write</span> (stderr, <span class="Constant">&quot;('Warning: ', A, ' not supported.')&quot;</span>) frameID
               <span class="Statement">continue</span>
            <span class="Statement">end if</span>

            id3 <span class="Statement">=</span> id3 <span class="Statement">//</span> frameID <span class="Statement">//</span> encode_size(<span class="Constant">1</span> <span class="Statement">+</span> <span class="Identifier">len</span>(text), <span class="Special">&amp;</span>
               synchsafe<span class="Statement">=</span>version <span class="Statement">.eq.</span> <span class="Constant">4_i1</span>) <span class="Statement">//</span> <span class="Identifier">char</span>(flags) <span class="Statement">//</span> <span class="Identifier">char</span>(flags) <span class="Special">&amp;</span>
               <span class="Statement">//</span> <span class="Identifier">char</span>(encoding) <span class="Statement">//</span> text
         <span class="Statement">end do</span>

         <span class="Statement">close</span> (fun)
      <span class="Statement">end if</span>

      <span class="Statement">if</span> (<span class="Identifier">len</span>(id3) <span class="Statement">.gt.</span> <span class="Constant">0</span>) id3 <span class="Statement">=</span> <span class="Constant">'ID3'</span> <span class="Statement">//</span> <span class="Identifier">char</span>(version) <span class="Statement">//</span> <span class="Identifier">char</span>(revision) <span class="Special">&amp;</span>
         <span class="Statement">//</span> <span class="Identifier">char</span>(flags) <span class="Statement">//</span> encode_size(<span class="Identifier">len</span>(id3)) <span class="Statement">//</span> id3
   <span class="PreProc">end function</span> write_id3

   <span class="PreProc">function</span> decode_size(code, synchsafe) <span class="PreProc">result</span>(s)
      <span class="Type">integer</span> :: s

      <span class="Type">character</span>(<span class="Statement">*</span>), <span class="Type">intent</span>(<span class="Type">in</span>) :: code
      <span class="Type">logical</span>, <span class="Type">intent</span>(<span class="Type">in</span>), <span class="Type">optional</span> :: synchsafe

      <span class="Type">integer</span> :: byte, base

      base <span class="Statement">=</span> <span class="Constant">128</span>

      <span class="Statement">if</span> (<span class="Identifier">present</span>(synchsafe)) <span class="Statement">then</span>
         <span class="Statement">if</span> (<span class="Statement">.not.</span> synchsafe) base <span class="Statement">=</span> <span class="Constant">256</span>
      <span class="Statement">end if</span>

      s <span class="Statement">=</span> <span class="Constant">0</span>
      <span class="Statement">do</span> byte <span class="Statement">=</span> <span class="Constant">1</span>, <span class="Constant">4</span>
         s <span class="Statement">=</span> s <span class="Statement">+</span> <span class="Identifier">ichar</span>(code(byte:byte)) <span class="Statement">*</span> base <span class="Statement">**</span> (<span class="Constant">4</span> <span class="Statement">-</span> byte)
      <span class="Statement">end do</span>
   <span class="PreProc">end function</span> decode_size

   <span class="PreProc">function</span> encode_size(s, synchsafe) <span class="PreProc">result</span>(code)
      <span class="Type">character</span>(<span class="Constant">4</span>) :: code

      <span class="Type">integer</span>, <span class="Type">intent</span>(<span class="Type">in</span>) :: s
      <span class="Type">logical</span>, <span class="Type">intent</span>(<span class="Type">in</span>), <span class="Type">optional</span> :: synchsafe

      <span class="Type">integer</span> :: byte, base

      base <span class="Statement">=</span> <span class="Constant">128</span>

      <span class="Statement">if</span> (<span class="Identifier">present</span>(synchsafe)) <span class="Statement">then</span>
         <span class="Statement">if</span> (<span class="Statement">.not.</span> synchsafe) base <span class="Statement">=</span> <span class="Constant">256</span>
      <span class="Statement">end if</span>

      <span class="Statement">do</span> byte <span class="Statement">=</span> <span class="Constant">1</span>, <span class="Constant">4</span>
         code(byte:byte) <span class="Statement">=</span> <span class="Identifier">char</span>(<span class="Identifier">modulo</span>(s <span class="Statement">/</span> base <span class="Statement">**</span> (<span class="Constant">4</span> <span class="Statement">-</span> byte), base))
      <span class="Statement">end do</span>
   <span class="PreProc">end function</span> encode_size

   <span class="PreProc">function</span> decode_iso8859_1(code) <span class="PreProc">result</span>(unicode)
      <span class="Type">integer</span>, <span class="Type">allocatable</span> :: unicode(:)

      <span class="Type">character</span>(<span class="Statement">*</span>), <span class="Type">intent</span>(<span class="Type">in</span>) :: code

      <span class="Type">integer</span> :: byte

      <span class="Statement">allocate</span>(unicode(<span class="Identifier">len</span>(code)))

      <span class="Statement">do</span> byte <span class="Statement">=</span> <span class="Constant">1</span>, <span class="Identifier">len</span>(code)
         unicode(byte) <span class="Statement">=</span> <span class="Identifier">ichar</span>(code(byte:byte))
      <span class="Statement">end do</span>
   <span class="PreProc">end function</span> decode_iso8859_1

   <span class="PreProc">function</span> decode_utf16(code) <span class="PreProc">result</span>(unicode)
      <span class="Type">integer</span>, <span class="Type">allocatable</span> :: unicode(:)

      <span class="Type">character</span>(<span class="Statement">*</span>), <span class="Type">intent</span>(<span class="Type">in</span>) :: code

      <span class="Type">integer</span> :: c, s, v
      <span class="Type">logical</span> :: be

      <span class="Statement">allocate</span>(unicode(<span class="Identifier">len</span>(code) <span class="Statement">/</span> <span class="Constant">2</span>))

      be <span class="Statement">=</span> <span class="Constant">.true.</span>

      v <span class="Statement">=</span> <span class="Constant">1</span>
      <span class="Statement">do</span> c <span class="Statement">=</span> <span class="Constant">1</span>, <span class="Identifier">len</span>(code), <span class="Constant">2</span>
         <span class="Statement">if</span> (be) <span class="Statement">then</span>
            s <span class="Statement">=</span> <span class="Identifier">ichar</span>(code(c:c)) <span class="Statement">*</span> <span class="Constant">256</span> <span class="Statement">+</span> <span class="Identifier">ichar</span>(code(c <span class="Statement">+</span> <span class="Constant">1</span>:c <span class="Statement">+</span> <span class="Constant">1</span>))
         <span class="Statement">else</span>
            s <span class="Statement">=</span> <span class="Identifier">ichar</span>(code(c <span class="Statement">+</span> <span class="Constant">1</span>:c <span class="Statement">+</span> <span class="Constant">1</span>)) <span class="Statement">*</span> <span class="Constant">256</span> <span class="Statement">+</span> <span class="Identifier">ichar</span>(code(c:c))
         <span class="Statement">end if</span>

         <span class="Statement">if</span> (s <span class="Statement">.eq.</span> <span class="Constant">65279</span>) <span class="Statement">then</span> <span class="Comment">! FEFF (BOM)</span>
            <span class="Statement">continue</span>
         <span class="Statement">else</span> <span class="Statement">if</span> (s <span class="Statement">.eq.</span> <span class="Constant">65534</span>) <span class="Statement">then</span> <span class="Comment">! FFFE (wrong BOM)</span>
            be <span class="Statement">=</span> <span class="Statement">.not.</span> be
         <span class="Statement">else</span> <span class="Statement">if</span> (<span class="Constant">55296</span> <span class="Statement">.le.</span> s <span class="Statement">.and.</span> s <span class="Statement">.lt.</span> <span class="Constant">56320</span>) <span class="Statement">then</span> <span class="Comment">! high surrogate</span>
            unicode(v) <span class="Statement">=</span> <span class="Constant">1024</span> <span class="Statement">*</span> (s <span class="Statement">-</span> <span class="Constant">55296</span>)
         <span class="Statement">else</span> <span class="Statement">if</span> (<span class="Constant">56320</span> <span class="Statement">.le.</span> s <span class="Statement">.and.</span> s <span class="Statement">.lt.</span> <span class="Constant">57344</span>) <span class="Statement">then</span> <span class="Comment">! low surrogate</span>
            unicode(v) <span class="Statement">=</span> <span class="Constant">65536</span> <span class="Statement">+</span> s <span class="Statement">-</span> <span class="Constant">56320</span> <span class="Statement">+</span> unicode(v)
            v <span class="Statement">=</span> v <span class="Statement">+</span> <span class="Constant">1</span>
         <span class="Statement">else</span> <span class="Comment">! basic multilingual plane</span>
            unicode(v) <span class="Statement">=</span> s
            v <span class="Statement">=</span> v <span class="Statement">+</span> <span class="Constant">1</span>
         <span class="Statement">end if</span>
      <span class="Statement">end do</span>

      unicode <span class="Statement">=</span> unicode(:v <span class="Statement">-</span> <span class="Constant">1</span>)
   <span class="PreProc">end function</span> decode_utf16

   <span class="PreProc">function</span> encode_utf8(unicode) <span class="PreProc">result</span>(code)
      <span class="Type">character</span>(:), <span class="Type">allocatable</span> :: code

      <span class="Type">integer</span>, <span class="Type">intent</span>(<span class="Type">in</span>) :: unicode(:)

      <span class="Type">integer</span> :: c, i, j, n, v

      code <span class="Statement">=</span> <span class="Constant">''</span>

      <span class="Statement">do</span> v <span class="Statement">=</span> <span class="Identifier">lbound</span>(unicode, <span class="Constant">1</span>), <span class="Identifier">ubound</span>(unicode, <span class="Constant">1</span>)
         <span class="Statement">if</span> (unicode(v) <span class="Statement">.lt.</span> <span class="Constant">128</span>) <span class="Statement">then</span>
            code <span class="Statement">=</span> code <span class="Statement">//</span> <span class="Identifier">char</span>(unicode(v))
         <span class="Statement">else</span>
            <span class="Statement">do</span> n <span class="Statement">=</span> <span class="Constant">1</span>, <span class="Constant">5</span>
               <span class="Statement">if</span> (unicode(v) <span class="Statement">.lt.</span> <span class="Constant">64</span> <span class="Statement">*</span> <span class="Constant">32</span> <span class="Statement">**</span> n) <span class="Statement">then</span>
                  <span class="Statement">do</span> i <span class="Statement">=</span> n, <span class="Constant">0</span>, <span class="Statement">-</span><span class="Constant">1</span>
                     c <span class="Statement">=</span> <span class="Constant">128</span> <span class="Statement">+</span> <span class="Identifier">modulo</span>(unicode(v) <span class="Statement">/</span> <span class="Constant">64</span> <span class="Statement">**</span> i, <span class="Constant">64</span>)
                     <span class="Statement">if</span> (i <span class="Statement">.eq.</span> n) <span class="Statement">then</span>
                        <span class="Statement">do</span> j <span class="Statement">=</span> <span class="Constant">1</span>, n
                           c <span class="Statement">=</span> c <span class="Statement">+</span> <span class="Constant">128</span> <span class="Statement">/</span> <span class="Constant">2</span> <span class="Statement">**</span> j
                        <span class="Statement">end do</span>
                     <span class="Statement">end if</span>
                     code <span class="Statement">=</span> code <span class="Statement">//</span> <span class="Identifier">char</span>(c)
                  <span class="Statement">end do</span>
                  <span class="Statement">exit</span>
               <span class="Statement">end if</span>
            <span class="Statement">end do</span>
         <span class="Statement">end if</span>
      <span class="Statement">end do</span>
   <span class="PreProc">end function</span> encode_utf8
<span class="PreProc">end module</span> id3
</pre>
<h2>inspect.f90</h2>
<pre id='vimCodeElement'>
<span class="PreProc">subroutine</span> inspect
   <span class="PreProc">use</span> aiff, <span class="PreProc">only</span>: read_aiff
   <span class="PreProc">use</span> constants, <span class="PreProc">only</span>: audio, stderr
   <span class="PreProc">use</span> id3, <span class="PreProc">only</span>: read_id3
   <span class="PreProc">use</span> io, <span class="PreProc">only</span>: command_argument, slurp
   <span class="PreProc">use</span> paths, <span class="PreProc">only</span>: extension
   <span class="PreProc">use</span> riff, <span class="PreProc">only</span>: read_riff
   <span class="Type">implicit</span> <span class="Type">none</span>

   <span class="Type">character</span>(:), <span class="Type">allocatable</span> :: path
   <span class="Type">type</span>(audio) :: s

   path <span class="Statement">=</span> command_argument(<span class="Constant">1</span>, <span class="Constant">'/dev/stdin'</span>)

   <span class="Statement">select case</span> (extension(path))
   <span class="Statement">case</span> (<span class="Constant">'aiff'</span>, <span class="Constant">'aif'</span>, <span class="Constant">'AIFF'</span>, <span class="Constant">'AIF'</span>)
      <span class="Identifier">call</span> read_aiff(path, s)

   <span class="Statement">case</span> (<span class="Constant">'wave'</span>, <span class="Constant">'wav'</span>, <span class="Constant">'WAVE'</span>, <span class="Constant">'WAV'</span>, <span class="Constant">''</span>)
      <span class="Identifier">call</span> read_riff(path, s)

   <span class="Statement">case</span> (<span class="Constant">'mp3'</span>, <span class="Constant">'MP3'</span>)
      <span class="Identifier">call</span> read_id3(slurp(path))
      <span class="Statement">stop</span>

   <span class="Statement">case</span> <span class="Statement">default</span>
      <span class="Statement">write</span> (stderr, <span class="Constant">&quot;('Error: Unknown filename extension.')&quot;</span>)
      <span class="Statement">stop</span>
   <span class="Statement">end select</span>

   <span class="Statement">if</span> (<span class="Identifier">allocated</span>(s%meta)) <span class="Identifier">call</span> read_id3(s%meta)

   <span class="Statement">write</span> (<span class="Statement">*</span>, <span class="Constant">&quot;('Number of channels: ', I0)&quot;</span>) s%channels
   <span class="Statement">write</span> (<span class="Statement">*</span>, <span class="Constant">&quot;('Number of sample points: ', I0)&quot;</span>) s%points
   <span class="Statement">write</span> (<span class="Statement">*</span>, <span class="Constant">&quot;('Sample rate: ', F0.1, ' Hz')&quot;</span>) s%rate
   <span class="Statement">write</span> (<span class="Statement">*</span>, <span class="Constant">&quot;('Duration: ', F0.1, ' s')&quot;</span>) s%points <span class="Statement">/</span> s%rate
   <span class="Statement">write</span> (<span class="Statement">*</span>, <span class="Constant">&quot;('Amplitude: ', F0.1)&quot;</span>) s%amplitude
<span class="PreProc">end subroutine</span> inspect
</pre>
<h2>interpreter.f90</h2>
<pre id='vimCodeElement'>
<span class="PreProc">module</span> interpreter
   <span class="PreProc">use</span> constants, <span class="PreProc">only</span>: audio, dp, i2, i2max, stderr
   <span class="PreProc">use</span> fjs, <span class="PreProc">only</span>: accidentals, comma
   <span class="PreProc">use</span> io, <span class="PreProc">only</span>: command_argument
   <span class="PreProc">use</span> lcg, <span class="PreProc">only</span>: minstd
   <span class="PreProc">use</span> rationals, <span class="PreProc">only</span>: rational
   <span class="PreProc">use</span> riff, <span class="PreProc">only</span>: read_riff
   <span class="PreProc">use</span> samples, <span class="PreProc">only</span>: sample
   <span class="PreProc">use</span> search, <span class="PreProc">only</span>: focus, get, known, lexical, next, <span class="Special">&amp;</span>
      numeral, remember, reset, revert, set, special
   <span class="PreProc">use</span> synthesis, <span class="PreProc">only</span>: karplus_strong
   <span class="Type">implicit</span> <span class="Type">none</span>
   <span class="Type">private</span>

   <span class="Type">public</span> :: play

<span class="PreProc">contains</span>

   <span class="PreProc">subroutine</span> play(notes, tones, limit)
      <span class="Type">character</span>(<span class="Statement">*</span>), <span class="Type">intent</span>(<span class="Type">in</span>) :: notes
      <span class="Type">type</span>(audio), <span class="Type">intent</span>(<span class="Type">out</span>) :: tones
      <span class="Type">integer</span>, <span class="Type">intent</span>(<span class="Type">in</span>), <span class="Type">optional</span> :: limit

      <span class="Type">character</span>(<span class="Statement">*</span>), <span class="Type">parameter</span> :: initial <span class="Statement">=</span> <span class="Constant">'!&quot;%</span><span class="Special">&amp;</span><span class="Constant">+-=?@ABCDEFGNQSUVWXYZ[]`~'</span>

      <span class="Type">character</span>(:), <span class="Type">allocatable</span> :: symbol, word <span class="Comment">! special/lexical string</span>

      <span class="Identifier">real</span>(dp), <span class="Type">allocatable</span> :: wave(:), rise(:), fall(:) <span class="Comment">! sound samples</span>
      <span class="Identifier">real</span>(dp), <span class="Type">allocatable</span> :: rho(:), tau(:), phi(:) <span class="Comment">! sound segment</span>
      <span class="Identifier">real</span>(dp), <span class="Type">allocatable</span> :: mel(:, :) <span class="Comment">! melody</span>
      <span class="Identifier">real</span>(dp), <span class="Type">allocatable</span> :: work(:, :) <span class="Comment">! temporary data</span>

      <span class="Type">logical</span> :: todo(<span class="Constant">3</span>) <span class="Comment">! samples yet to be initialized?</span>
      <span class="Type">logical</span> :: over <span class="Comment">! end of input reached?</span>

      <span class="Identifier">real</span>(dp) :: x <span class="Comment">! exact time</span>
      <span class="Identifier">real</span>(dp) :: b <span class="Comment">! beat duration</span>

      <span class="Type">integer</span> :: t <span class="Comment">! rounded time</span>
      <span class="Type">integer</span> :: c <span class="Comment">! continuance</span>
      <span class="Type">integer</span> :: p <span class="Comment">! processed time (plus command count)</span>
      <span class="Type">integer</span> :: d <span class="Comment">! note duration</span>

      <span class="Type">integer</span> :: tmin, tmax, cmax <span class="Comment">! extreme times</span>

      <span class="Identifier">real</span>(dp) :: A4 <span class="Comment">! concert pitch</span>

      <span class="Type">integer</span> :: steps <span class="Comment">! notes per octave</span>

      <span class="Identifier">real</span>(dp) :: f <span class="Comment">! frequency f(t)</span>
      <span class="Identifier">real</span>(dp) :: f0 <span class="Comment">! reference frequency</span>
      <span class="Identifier">real</span>(dp) :: fi <span class="Comment">! initial frequency</span>
      <span class="Identifier">real</span>(dp) :: fd <span class="Comment">! f(t + d) / f(t)</span>
      <span class="Identifier">real</span>(dp) :: fb <span class="Comment">! f(t + b) / f(t)</span>
      <span class="Identifier">real</span>(dp) :: f1 <span class="Comment">! f(t + 1) / f(t)</span>

      <span class="Identifier">real</span>(dp) :: a <span class="Comment">! amplitude a(t) = sqrt(L^2 + R^2)</span>
      <span class="Identifier">real</span>(dp) :: a0 <span class="Comment">! reference amplitude</span>
      <span class="Identifier">real</span>(dp) :: ai <span class="Comment">! initial amplitude</span>
      <span class="Identifier">real</span>(dp) :: ad <span class="Comment">! a(t + d) / a(t)</span>
      <span class="Identifier">real</span>(dp) :: ab <span class="Comment">! a(t + b) / a(t)</span>
      <span class="Identifier">real</span>(dp) :: a1 <span class="Comment">! a(t + 1) / a(t)</span>

      <span class="Identifier">real</span>(dp) :: r <span class="Comment">! amplitudes ratio r(t) = R:L</span>
      <span class="Identifier">real</span>(dp) :: r0 <span class="Comment">! reference ratio</span>
      <span class="Identifier">real</span>(dp) :: ri <span class="Comment">! initial ratio</span>
      <span class="Identifier">real</span>(dp) :: rd <span class="Comment">! r(t + d) / r(t)</span>
      <span class="Identifier">real</span>(dp) :: rb <span class="Comment">! r(t + b) / r(t)</span>
      <span class="Identifier">real</span>(dp) :: r1 <span class="Comment">! r(t + 1) / r(t)</span>

      <span class="Type">logical</span> :: loudness <span class="Comment">! boost low frequencies?</span>
      <span class="Identifier">real</span>(dp) :: boost <span class="Comment">! amplitude scaling factor</span>

      <span class="Type">logical</span> :: synth, tuned <span class="Comment">! employ Karplus and Strong's synthesizer?</span>
      <span class="Identifier">real</span>(dp) :: blend, decay <span class="Comment">! blend and inverse decay-stretch factors</span>

      <span class="Identifier">real</span>(dp) :: phase <span class="Comment">! turn = 1</span>

      <span class="Type">integer</span> :: i, j, k <span class="Comment">! arbitrary integers/indices</span>
      <span class="Type">logical</span> :: l <span class="Comment">! arbitrary logical</span>

      <span class="Identifier">real</span>(dp) :: s <span class="Comment">! equivalent of a second</span>

      <span class="Comment">! time marks</span>
      <span class="Identifier">real</span>(dp) :: marks(<span class="Constant">0</span>:<span class="Constant">99</span>)
      <span class="Type">logical</span> :: mark_set(<span class="Constant">0</span>:<span class="Constant">99</span>)
      <span class="Identifier">real</span>(dp) :: x1, x2, dx
      <span class="Type">integer</span> :: t1, t2, dt

      <span class="Identifier">real</span>(dp) :: random, factor

      <span class="Comment">! tuning</span>
      <span class="Type">character</span>(:), <span class="Type">allocatable</span> :: tuning

      <span class="Identifier">real</span>(dp), <span class="Type">parameter</span> :: equal_fifth <span class="Statement">=</span> <span class="Constant">2.0_dp</span> <span class="Statement">**</span> (<span class="Constant">7.0_dp</span> <span class="Statement">/</span> <span class="Constant">12.0_dp</span>)
      <span class="Identifier">real</span>(dp), <span class="Type">parameter</span> :: just_fifth <span class="Statement">=</span> <span class="Constant">1.5_dp</span>

      <span class="Type">integer</span> :: keynote, tone, newtone

      <span class="Type">integer</span>, <span class="Type">allocatable</span> :: primes(:)

      <span class="Type">integer</span> :: keycount(<span class="Statement">-</span><span class="Constant">25</span>:<span class="Constant">23</span>)

      tuning <span class="Statement">=</span> <span class="Constant">'equal'</span>
      tone <span class="Statement">=</span> <span class="Constant">0</span>
      keynote <span class="Statement">=</span> <span class="Statement">-</span><span class="Constant">3</span> <span class="Comment">! C</span>

      keycount <span class="Statement">=</span> <span class="Constant">0</span>

      tones%rate <span class="Statement">=</span> <span class="Constant">44100.0_dp</span>
      tones%channels <span class="Statement">=</span> <span class="Statement">-</span><span class="Constant">1_i2</span>

      todo <span class="Statement">=</span> <span class="Constant">.true.</span>

      <span class="Identifier">call</span> focus(notes)

      <span class="Statement">do</span>
         <span class="Statement">select case</span> (next(special, length<span class="Statement">=</span><span class="Constant">1</span>))
         <span class="Statement">case</span> (<span class="Constant">'$'</span>)
            tones%rate <span class="Statement">=</span> n()

         <span class="Statement">case</span> (<span class="Constant">'~'</span>)
            todo(<span class="Constant">1</span>) <span class="Statement">=</span> <span class="Constant">.false.</span>
         <span class="Statement">case</span> (<span class="Constant">'S'</span>)
            todo(<span class="Constant">2</span>) <span class="Statement">=</span> <span class="Constant">.false.</span>
         <span class="Statement">case</span> (<span class="Constant">'Z'</span>)
            todo(<span class="Constant">3</span>) <span class="Statement">=</span> <span class="Constant">.false.</span>
         <span class="Statement">case</span> (<span class="Constant">'N'</span>)
            todo(<span class="Constant">2</span>:<span class="Constant">3</span>) <span class="Statement">=</span> <span class="Constant">.false.</span>

         <span class="Statement">case</span> (<span class="Constant">'*'</span>)
            <span class="Statement">if</span> (next(<span class="Constant">'*'</span>, length<span class="Statement">=</span><span class="Constant">1</span>, barrier<span class="Statement">=</span><span class="Constant">'*'</span>) <span class="Statement">.eq.</span> <span class="Constant">'none'</span>) <span class="Statement">exit</span>

         <span class="Statement">case</span> (<span class="Constant">&quot;'&quot;</span>, <span class="Constant">'none'</span>)
            <span class="Statement">exit</span>
         <span class="Statement">end select</span>
      <span class="Statement">end do</span>

      s <span class="Statement">=</span> tones%rate

      <span class="Statement">if</span> (todo(<span class="Constant">1</span>)) <span class="Identifier">call</span> load(wave, <span class="Constant">'wave'</span>, <span class="Constant">'circular'</span>, <span class="Identifier">nint</span>(<span class="Constant">1.0_dp</span> <span class="Statement">*</span> s))
      <span class="Statement">if</span> (todo(<span class="Constant">2</span>)) <span class="Identifier">call</span> load(rise, <span class="Constant">'fade'</span>, <span class="Constant">'circular'</span>, <span class="Identifier">nint</span>(<span class="Constant">0.1_dp</span> <span class="Statement">*</span> s))
      <span class="Statement">if</span> (todo(<span class="Constant">3</span>)) <span class="Identifier">call</span> load(fall, <span class="Constant">'fade'</span>, <span class="Constant">'circular'</span>, <span class="Identifier">nint</span>(<span class="Constant">0.1_dp</span> <span class="Statement">*</span> s))

      b <span class="Statement">=</span> <span class="Constant">0.5_dp</span> <span class="Statement">*</span> s

      x <span class="Statement">=</span> <span class="Constant">0.0_dp</span>

      t <span class="Statement">=</span> <span class="Constant">0</span>
      c <span class="Statement">=</span> <span class="Constant">0</span>
      p <span class="Statement">=</span> <span class="Constant">0</span>

      tmin <span class="Statement">=</span> t
      tmax <span class="Statement">=</span> t
      cmax <span class="Statement">=</span> c

      <span class="Identifier">call</span> reset
      mark_set <span class="Statement">=</span> <span class="Constant">.false.</span>

      <span class="Statement">do</span>
         symbol <span class="Statement">=</span> next(special, length<span class="Statement">=</span><span class="Constant">1</span>)

         tmin <span class="Statement">=</span> <span class="Identifier">min</span>(tmin, t)
         tmax <span class="Statement">=</span> <span class="Identifier">max</span>(tmax, t)

         <span class="Statement">if</span> (done()) <span class="Statement">then</span>
            cmax <span class="Statement">=</span> <span class="Identifier">max</span>(cmax, c)
            c <span class="Statement">=</span> <span class="Constant">0</span>
         <span class="Statement">end if</span>

         <span class="Statement">select case</span> (symbol)
         <span class="Statement">case</span> (<span class="Constant">'~'</span>, <span class="Constant">'S'</span>, <span class="Constant">'Z'</span>, <span class="Constant">'N'</span>)
            <span class="Statement">if</span> (next(lexical) <span class="Statement">.ne.</span> <span class="Constant">'#'</span>) <span class="Statement">then</span>
               p <span class="Statement">=</span> p <span class="Statement">+</span> <span class="Identifier">nint</span>(n(<span class="Constant">1.0_dp</span>) <span class="Statement">*</span> s)
            <span class="Statement">end if</span>

         <span class="Statement">case</span> (<span class="Constant">'O'</span>)
            tones%channels <span class="Statement">=</span> <span class="Identifier">int</span>(n(), i2)

         <span class="Statement">case</span> (<span class="Constant">'%'</span>, <span class="Constant">'('</span>, <span class="Constant">')'</span>, <span class="Constant">'['</span>, <span class="Constant">']'</span>, <span class="Constant">'{'</span>, <span class="Constant">'}'</span>)
            <span class="Statement">if</span> (tones%channels <span class="Statement">.eq.</span> <span class="Statement">-</span><span class="Constant">1_i2</span>) tones%channels <span class="Statement">=</span> <span class="Constant">2_i2</span>

         <span class="Statement">case</span> (<span class="Constant">&quot;'&quot;</span>)
            x <span class="Statement">=</span> x <span class="Statement">+</span> n(<span class="Constant">1.0_dp</span>) <span class="Statement">*</span> b
            d <span class="Statement">=</span> <span class="Identifier">nint</span>(x) <span class="Statement">-</span> t
            c <span class="Statement">=</span> c <span class="Statement">+</span> d
            t <span class="Statement">=</span> t <span class="Statement">+</span> d
            p <span class="Statement">=</span> p <span class="Statement">+</span> d

         <span class="Statement">case</span> <span class="Statement">default</span>
            <span class="Identifier">call</span> routine_cases
            <span class="Statement">if</span> (over) <span class="Statement">exit</span>
         <span class="Statement">end select</span>

         p <span class="Statement">=</span> p <span class="Statement">+</span> <span class="Constant">1</span>

         <span class="Statement">if</span> (<span class="Identifier">present</span>(limit)) <span class="Statement">then</span>
            <span class="Statement">if</span> (p <span class="Statement">.gt.</span> limit) <span class="Statement">exit</span>
         <span class="Statement">end if</span>
      <span class="Statement">end do</span>

      <span class="Statement">allocate</span>(rho(cmax))
      <span class="Statement">allocate</span>(tau(cmax))
      <span class="Statement">allocate</span>(phi(cmax))

      tones%points <span class="Statement">=</span> tmax <span class="Statement">-</span> tmin

      <span class="Statement">if</span> (tones%channels <span class="Statement">.eq.</span> <span class="Statement">-</span><span class="Constant">1_i2</span>) tones%channels <span class="Statement">=</span> <span class="Constant">1_i2</span>

      <span class="Statement">if</span> (<span class="Identifier">present</span>(limit)) <span class="Statement">then</span>
         <span class="Statement">if</span> (p <span class="Statement">.gt.</span> limit <span class="Statement">.or.</span> tones%points <span class="Statement">.gt.</span> limit) tones%points <span class="Statement">=</span> <span class="Constant">0</span>
      <span class="Statement">end if</span>

      <span class="Statement">allocate</span>(mel(tones%channels, tones%points))

      <span class="Statement">if</span> (tones%points <span class="Statement">.eq.</span> <span class="Constant">0</span>) <span class="Statement">return</span>

      mel <span class="Statement">=</span> <span class="Constant">0.0_dp</span>

      b <span class="Statement">=</span> <span class="Constant">0.5_dp</span> <span class="Statement">*</span> s
      A4 <span class="Statement">=</span> <span class="Constant">440.0_dp</span> <span class="Statement">/</span> s
      steps <span class="Statement">=</span> <span class="Constant">12</span>

      f0 <span class="Statement">=</span> A4
      f <span class="Statement">=</span> f0
      fi <span class="Statement">=</span> f0
      fd <span class="Statement">=</span> <span class="Constant">1.0_dp</span>
      fb <span class="Statement">=</span> <span class="Constant">1.0_dp</span>

      a0 <span class="Statement">=</span> <span class="Constant">1.0_dp</span>
      a <span class="Statement">=</span> a0
      ai <span class="Statement">=</span> a0
      ad <span class="Statement">=</span> <span class="Constant">1.0_dp</span>
      ab <span class="Statement">=</span> <span class="Constant">1.0_dp</span>

      r0 <span class="Statement">=</span> <span class="Constant">1.0_dp</span>
      r <span class="Statement">=</span> r0
      ri <span class="Statement">=</span> r0
      rd <span class="Statement">=</span> <span class="Constant">1.0_dp</span>
      rb <span class="Statement">=</span> <span class="Constant">1.0_dp</span>

      loudness <span class="Statement">=</span> <span class="Constant">.false.</span>

      synth <span class="Statement">=</span> <span class="Constant">.false.</span>
      tuned <span class="Statement">=</span> <span class="Constant">.true.</span>
      blend <span class="Statement">=</span> <span class="Constant">1.0_dp</span>
      decay <span class="Statement">=</span> <span class="Constant">1.0_dp</span>

      phase <span class="Statement">=</span> <span class="Constant">0.0_dp</span>

      x <span class="Statement">=</span> <span class="Constant">0.0_dp</span>

      t <span class="Statement">=</span> <span class="Statement">-</span>tmin
      c <span class="Statement">=</span> <span class="Constant">0</span>

      <span class="Identifier">call</span> reset
      mark_set <span class="Statement">=</span> <span class="Constant">.false.</span>

      <span class="Statement">do</span>
         symbol <span class="Statement">=</span> next(special, length<span class="Statement">=</span><span class="Constant">1</span>)

         <span class="Statement">if</span> (done()) <span class="Statement">then</span>
            f <span class="Statement">=</span> fi
            a <span class="Statement">=</span> ai
            r <span class="Statement">=</span> ri

            rho <span class="Statement">=</span> rho <span class="Statement">*</span> tau

            i <span class="Statement">=</span> <span class="Identifier">min</span>(<span class="Identifier">size</span>(rise), c)

            rho(:i) <span class="Statement">=</span> rho(:i) <span class="Statement">*</span> rise(:i <span class="Statement">-</span> <span class="Constant">1</span>)

            i <span class="Statement">=</span> <span class="Identifier">max</span>(c <span class="Statement">-</span> <span class="Identifier">size</span>(fall) <span class="Statement">+</span> <span class="Constant">1</span>, <span class="Constant">1</span>)

            rho(c:i:<span class="Statement">-</span><span class="Constant">1</span>) <span class="Statement">=</span> rho(c:i:<span class="Statement">-</span><span class="Constant">1</span>) <span class="Statement">*</span> fall(:c <span class="Statement">-</span> i)

            i <span class="Statement">=</span> t <span class="Statement">-</span> c <span class="Statement">+</span> <span class="Constant">1</span>

            <span class="Statement">select case</span> (tones%channels)
            <span class="Statement">case</span> (<span class="Constant">1_i2</span>)
               mel(<span class="Constant">1</span>, i:t) <span class="Statement">=</span> mel(<span class="Constant">1</span>, i:t) <span class="Statement">+</span> rho(:c)

            <span class="Statement">case</span> (<span class="Constant">2_i2</span>)
               mel(<span class="Constant">1</span>, i:t) <span class="Statement">=</span> mel(<span class="Constant">1</span>, i:t) <span class="Statement">+</span> rho(:c) <span class="Statement">*</span> <span class="Identifier">cos</span>(phi(:c))
               mel(<span class="Constant">2</span>, i:t) <span class="Statement">=</span> mel(<span class="Constant">2</span>, i:t) <span class="Statement">+</span> rho(:c) <span class="Statement">*</span> <span class="Identifier">sin</span>(phi(:c))
            <span class="Statement">end select</span>

            c <span class="Statement">=</span> <span class="Constant">0</span>
         <span class="Statement">end if</span>

         <span class="Statement">select case</span> (symbol)
         <span class="Statement">case</span> (<span class="Constant">'~'</span>, <span class="Constant">'S'</span>, <span class="Constant">'Z'</span>, <span class="Constant">'N'</span>)
            word <span class="Statement">=</span> next(lexical)

            <span class="Statement">if</span> (word <span class="Statement">.eq.</span> <span class="Constant">'#'</span>) <span class="Statement">then</span>
               i <span class="Statement">=</span> <span class="Identifier">int</span>(n(<span class="Constant">1.0_dp</span>))
            <span class="Statement">else</span>
               i <span class="Statement">=</span> <span class="Identifier">nint</span>(n(<span class="Constant">1.0_dp</span>) <span class="Statement">*</span> s)
            <span class="Statement">end if</span>

            <span class="Statement">select case</span> (symbol)
            <span class="Statement">case</span> (<span class="Constant">'~'</span>)
               <span class="Identifier">call</span> load(wave, <span class="Constant">'wave'</span>, word, i)
            <span class="Statement">case</span> (<span class="Constant">'S'</span>)
               <span class="Identifier">call</span> load(rise, <span class="Constant">'fade'</span>, word, i)
            <span class="Statement">case</span> (<span class="Constant">'Z'</span>)
               <span class="Identifier">call</span> load(fall, <span class="Constant">'fade'</span>, word, i)
            <span class="Statement">case</span> (<span class="Constant">'N'</span>)
               <span class="Identifier">call</span> load(rise, <span class="Constant">'fade'</span>, word, i)
               fall <span class="Statement">=</span> rise
            <span class="Statement">end select</span>

         <span class="Statement">case</span> (<span class="Constant">'X'</span>)
            word <span class="Statement">=</span> next(lexical)

            <span class="Statement">select case</span> (word)
            <span class="Statement">case</span> (<span class="Constant">'loudness'</span>)
               loudness <span class="Statement">=</span> n(<span class="Constant">1.0_dp</span>) <span class="Statement">.ne.</span> <span class="Constant">0.0_dp</span>

            <span class="Statement">case</span> (<span class="Constant">'synth'</span>)
               synth <span class="Statement">=</span> n(<span class="Constant">1.0_dp</span>) <span class="Statement">.ne.</span> <span class="Constant">0.0_dp</span>

            <span class="Statement">case</span> (<span class="Constant">'blend'</span>)
               blend <span class="Statement">=</span> n(<span class="Constant">1.0_dp</span>)

            <span class="Statement">case</span> (<span class="Constant">'decay'</span>)
               decay <span class="Statement">=</span> n(<span class="Constant">1.0_dp</span>)

            <span class="Statement">case</span> (<span class="Constant">'tuned'</span>)
               tuned <span class="Statement">=</span> n(<span class="Constant">1.0_dp</span>) <span class="Statement">.ne.</span> <span class="Constant">0.0_dp</span>

            <span class="Statement">case</span> (<span class="Constant">'status'</span>)
               <span class="Statement">write</span> (stderr, <span class="Constant">&quot;(*(A10, ':', F16.9, 1X, A, :, /))&quot;</span>) <span class="Special">&amp;</span>
                  <span class="Constant">'Time'</span>, t <span class="Statement">/</span> s, <span class="Constant">'s'</span>, <span class="Special">&amp;</span>
                  <span class="Constant">'Frequency'</span>, f <span class="Statement">*</span> s, <span class="Constant">'Hz'</span>, <span class="Special">&amp;</span>
                  <span class="Constant">'Amplitude'</span>, a, <span class="Constant">'arb. units'</span>, <span class="Special">&amp;</span>
                  <span class="Constant">'Balance'</span>, <span class="Constant">10.0_dp</span> <span class="Statement">*</span> <span class="Identifier">log10</span>(r), <span class="Constant">'dB'</span>, <span class="Special">&amp;</span>
                  <span class="Constant">'Phase'</span>, phase, <span class="Constant">'(mod 1)'</span>

            <span class="Statement">case</span> (<span class="Constant">'report'</span>)
               <span class="Statement">write</span> (stderr, <span class="Constant">&quot;('Note counts:')&quot;</span>)

               <span class="Statement">do</span> i <span class="Statement">=</span> <span class="Identifier">lbound</span>(keycount, <span class="Constant">1</span>), <span class="Identifier">ubound</span>(keycount, <span class="Constant">1</span>)
                  <span class="Statement">if</span> (keycount(i) <span class="Statement">.gt.</span> <span class="Constant">0</span>) <span class="Statement">then</span>
                     j <span class="Statement">=</span> <span class="Identifier">modulo</span>(i <span class="Statement">+</span> <span class="Constant">4</span>, <span class="Constant">7</span>) <span class="Statement">+</span> <span class="Constant">1</span>

                     <span class="Statement">write</span> (stderr, <span class="Constant">&quot;(A)&quot;</span>, <span class="Statement">advance</span><span class="Statement">=</span><span class="Constant">'no'</span>) <span class="Constant">'FCGDAEB'</span>(j:j)

                     j <span class="Statement">=</span> (i <span class="Statement">+</span> <span class="Constant">4</span> <span class="Statement">-</span> (j <span class="Statement">-</span> <span class="Constant">1</span>)) <span class="Statement">/</span> <span class="Constant">7</span>

                     <span class="Statement">if</span> (j <span class="Statement">&lt;</span> <span class="Constant">0</span>) <span class="Statement">write</span> (stderr, <span class="Constant">&quot;(A)&quot;</span>, <span class="Statement">advance</span><span class="Statement">=</span><span class="Constant">'no'</span>) <span class="Special">&amp;</span>
                        <span class="Identifier">repeat</span>(<span class="Constant">'b'</span>, <span class="Statement">-</span>j)

                     <span class="Statement">if</span> (j <span class="Statement">&gt;</span> <span class="Constant">0</span>) <span class="Statement">write</span> (stderr, <span class="Constant">&quot;(A)&quot;</span>, <span class="Statement">advance</span><span class="Statement">=</span><span class="Constant">'no'</span>) <span class="Special">&amp;</span>
                        <span class="Identifier">repeat</span>(<span class="Constant">'#'</span>, j)

                     <span class="Statement">write</span> (stderr, <span class="Constant">&quot;(': ', I0)&quot;</span>) keycount(i)
                  <span class="Statement">end if</span>
               <span class="Statement">end do</span>

               keycount <span class="Statement">=</span> <span class="Constant">0</span>

            <span class="Statement">case</span> (<span class="Constant">'detune'</span>)
               <span class="Identifier">call</span> minstd(random)
               random <span class="Statement">=</span> <span class="Constant">1.0_dp</span> <span class="Statement">-</span> <span class="Constant">2.0_dp</span> <span class="Statement">*</span> random
               random <span class="Statement">=</span> <span class="Constant">2.0_dp</span> <span class="Statement">**</span> (random <span class="Statement">*</span> n() <span class="Statement">/</span> steps)
               A4 <span class="Statement">=</span> A4 <span class="Statement">*</span> random
               f0 <span class="Statement">=</span> f0 <span class="Statement">*</span> random
               fi <span class="Statement">=</span> fi <span class="Statement">*</span> random
               f <span class="Statement">=</span> f <span class="Statement">*</span> random

            <span class="Statement">case</span> (<span class="Constant">'delete'</span>, <span class="Constant">'reverse'</span>, <span class="Constant">'flanger'</span>, <span class="Constant">'vibrato'</span>)
               i <span class="Statement">=</span> <span class="Identifier">int</span>(n())
               j <span class="Statement">=</span> <span class="Identifier">int</span>(n())

               <span class="Statement">if</span> (mark_set(i) <span class="Statement">.and.</span> mark_set(j)) <span class="Statement">then</span>
                  t1 <span class="Statement">=</span> <span class="Identifier">nint</span>(marks(i))
                  t2 <span class="Statement">=</span> <span class="Identifier">nint</span>(marks(j))

                  <span class="Statement">select case</span> (word)
                  <span class="Statement">case</span> (<span class="Constant">'delete'</span>)
                     mel(:, t1 <span class="Statement">+</span> <span class="Constant">1</span>:t2) <span class="Statement">=</span> <span class="Constant">0.0_dp</span>

                  <span class="Statement">case</span> (<span class="Constant">'reverse'</span>)
                     mel(:, t1 <span class="Statement">+</span> <span class="Constant">1</span>:t2) <span class="Statement">=</span> mel(:, t2:t1 <span class="Statement">+</span> <span class="Constant">1</span>:<span class="Statement">-</span><span class="Constant">1</span>)

                  <span class="Statement">case</span> (<span class="Constant">'flanger'</span>, <span class="Constant">'vibrato'</span>)
                     dx <span class="Statement">=</span> n() <span class="Statement">*</span> s

                     factor <span class="Statement">=</span> n() <span class="Statement">*</span> <span class="Identifier">size</span>(wave) <span class="Statement">/</span> (t2 <span class="Statement">-</span> t1 <span class="Statement">-</span> <span class="Constant">1</span>)

                     <span class="Statement">allocate</span>(work(tones%channels, t2 <span class="Statement">-</span> t1))

                     <span class="Statement">do</span> i <span class="Statement">=</span> <span class="Constant">0</span>, t2 <span class="Statement">-</span> t1 <span class="Statement">-</span> <span class="Constant">1</span>
                        work(:, <span class="Constant">1</span> <span class="Statement">+</span> i) <span class="Statement">=</span> mel(:, t1 <span class="Statement">+</span> <span class="Constant">1</span> <span class="Statement">+</span> i <span class="Statement">+</span> <span class="Identifier">nint</span>(dx <span class="Statement">*</span> <span class="Special">&amp;</span>
                           wave(<span class="Identifier">modulo</span>(<span class="Identifier">nint</span>(i <span class="Statement">*</span> factor), <span class="Identifier">size</span>(wave)))))
                     <span class="Statement">end do</span>

                     <span class="Statement">select case</span> (word)
                     <span class="Statement">case</span> (<span class="Constant">'flanger'</span>)
                        mel(:, t1 <span class="Statement">+</span> <span class="Constant">1</span>:t2) <span class="Statement">=</span> mel(:, t1 <span class="Statement">+</span> <span class="Constant">1</span>:t2) <span class="Statement">+</span> work
                     <span class="Statement">case</span> (<span class="Constant">'vibrato'</span>)
                        mel(:, t1 <span class="Statement">+</span> <span class="Constant">1</span>:t2) <span class="Statement">=</span> work
                     <span class="Statement">end select</span>

                     <span class="Statement">deallocate</span>(work)
                  <span class="Statement">end select</span>
               <span class="Statement">end if</span>

            <span class="Statement">case</span> <span class="Statement">default</span>
               <span class="Statement">write</span> (stderr, <span class="Constant">&quot;('Warning: Unknown action ''', A, '''.')&quot;</span>) word
            <span class="Statement">end select</span>

         <span class="Statement">case</span> (<span class="Constant">'T'</span>)
            tuning <span class="Statement">=</span> next(lexical)

            <span class="Statement">select case</span> (tuning)
            <span class="Statement">case</span> (<span class="Constant">'equal'</span>, <span class="Constant">'pyth'</span>, <span class="Constant">'just'</span>, <span class="Constant">'close'</span>)
               <span class="Statement">continue</span>
            <span class="Statement">case</span> <span class="Statement">default</span>
               <span class="Statement">write</span> (stderr, <span class="Constant">&quot;('Warning: Unknown tuning ''', A, '''.')&quot;</span>) tuning
               <span class="Statement">write</span> (stderr, <span class="Constant">&quot;('The tuning ''equal'' is used instead.')&quot;</span>)
               <span class="Statement">write</span> (stderr, <span class="Constant">&quot;('See ''man tz mel'' for list of tunings.')&quot;</span>)
               tuning <span class="Statement">=</span> <span class="Constant">'equal'</span>
            <span class="Statement">end select</span>

         <span class="Statement">case</span> (<span class="Constant">'H'</span>)
            steps <span class="Statement">=</span> <span class="Identifier">nint</span>(n())

         <span class="Statement">case</span> (<span class="Constant">'C'</span>, <span class="Constant">'D'</span>, <span class="Constant">'E'</span>, <span class="Constant">'F'</span>, <span class="Constant">'G'</span>, <span class="Constant">'A'</span>, <span class="Constant">'B'</span>, <span class="Constant">'U'</span>, <span class="Constant">'V'</span>)
            fi <span class="Statement">=</span> f <span class="Comment">! remember current frequency</span>

            f <span class="Statement">=</span> A4

            <span class="Statement">if</span> (<span class="Identifier">index</span>(<span class="Constant">'UV'</span>, symbol) <span class="Statement">.ne.</span> <span class="Constant">0</span>) <span class="Statement">then</span>
               newtone <span class="Statement">=</span> tone <span class="Statement">+</span> sgn(<span class="Constant">'VU'</span>) <span class="Statement">*</span> <span class="Identifier">int</span>(n())
               i <span class="Statement">=</span> keynote <span class="Statement">-</span> <span class="Constant">5</span> <span class="Statement">+</span> <span class="Identifier">modulo</span>(newtone <span class="Statement">*</span> <span class="Constant">7</span> <span class="Statement">-</span> keynote <span class="Statement">+</span> <span class="Constant">5</span>, <span class="Constant">12</span>)
            <span class="Statement">else</span>
               i <span class="Statement">=</span> <span class="Identifier">index</span>(<span class="Constant">'FCGDAEB'</span>, symbol) <span class="Statement">-</span> <span class="Constant">5</span>
            <span class="Statement">end if</span>

            word <span class="Statement">=</span> next(lexical, <span class="Constant">''</span>)

            <span class="Statement">do</span> j <span class="Statement">=</span> <span class="Constant">1</span>, <span class="Identifier">len</span>(word)
               <span class="Statement">select case</span> (word(j:j))
               <span class="Statement">case</span> (<span class="Constant">'b'</span>)
                  i <span class="Statement">=</span> i <span class="Statement">-</span> <span class="Constant">7</span>
               <span class="Statement">case</span> (<span class="Constant">'#'</span>)
                  i <span class="Statement">=</span> i <span class="Statement">+</span> <span class="Constant">7</span>
               <span class="Statement">case</span> (<span class="Constant">'x'</span>)
                  i <span class="Statement">=</span> i <span class="Statement">+</span> <span class="Constant">14</span>
               <span class="Statement">case</span> (<span class="Constant">'v'</span>) <span class="Comment">! syntonic comma down</span>
                  f <span class="Statement">=</span> f <span class="Statement">*</span> comma(<span class="Constant">5</span>)
               <span class="Statement">case</span> (<span class="Constant">'u'</span>) <span class="Comment">! syntonic comma up</span>
                  f <span class="Statement">=</span> f <span class="Statement">*</span> comma(<span class="Statement">-</span><span class="Constant">5</span>)
               <span class="Statement">case</span> (<span class="Constant">'z'</span>) <span class="Comment">! septimal comma down</span>
                  f <span class="Statement">=</span> f <span class="Statement">*</span> comma(<span class="Constant">7</span>)
               <span class="Statement">case</span> (<span class="Constant">'s'</span>) <span class="Comment">! septimal comma up</span>
                  f <span class="Statement">=</span> f <span class="Statement">*</span> comma(<span class="Statement">-</span><span class="Constant">7</span>)
               <span class="Statement">case</span> (<span class="Constant">'j'</span>) <span class="Comment">! 11-comma down</span>
                  f <span class="Statement">=</span> f <span class="Statement">*</span> comma(<span class="Statement">-</span><span class="Constant">11</span>)
               <span class="Statement">case</span> (<span class="Constant">'i'</span>) <span class="Comment">! 11-comma up</span>
                  f <span class="Statement">=</span> f <span class="Statement">*</span> comma(<span class="Constant">11</span>)
               <span class="Statement">case</span> (<span class="Constant">'d'</span>) <span class="Comment">! ditonic comma down</span>
                  f <span class="Statement">=</span> f <span class="Statement">*</span> comma(<span class="Statement">-</span><span class="Constant">3</span>)
               <span class="Statement">case</span> (<span class="Constant">'p'</span>) <span class="Comment">! Pythagorean comma up</span>
                  f <span class="Statement">=</span> f <span class="Statement">*</span> comma(<span class="Constant">3</span>)
            <span class="Statement">end select</span>
            <span class="Statement">end do</span>

            <span class="Statement">if</span> (<span class="Identifier">lbound</span>(keycount, <span class="Constant">1</span>) <span class="Statement">.le.</span> i <span class="Statement">.and.</span> <span class="Special">&amp;</span>
                <span class="Identifier">ubound</span>(keycount, <span class="Constant">1</span>) <span class="Statement">.ge.</span> i) <span class="Statement">then</span>
               keycount(i) <span class="Statement">=</span> keycount(i) <span class="Statement">+</span> <span class="Constant">1</span>
            <span class="Statement">end if</span>

            <span class="Statement">select case</span> (tuning)
            <span class="Statement">case</span> (<span class="Constant">'equal'</span>)
               f <span class="Statement">=</span> f <span class="Statement">*</span> equal_fifth <span class="Statement">**</span> i

            <span class="Statement">case</span> (<span class="Constant">'pyth'</span>)
               f <span class="Statement">=</span> f <span class="Statement">*</span> just_fifth <span class="Statement">**</span> i

            <span class="Statement">case</span> (<span class="Constant">'just'</span>)
               f <span class="Statement">=</span> f <span class="Statement">*</span> just_fifth <span class="Statement">**</span> i
               j <span class="Statement">=</span> i <span class="Statement">+</span> <span class="Identifier">modulo</span>(<span class="Constant">1</span> <span class="Statement">-</span> keynote, <span class="Constant">4</span>)
               j <span class="Statement">=</span> (j <span class="Statement">-</span> <span class="Identifier">modulo</span>(j, <span class="Constant">4</span>)) <span class="Statement">/</span> <span class="Constant">4</span>
               f <span class="Statement">=</span> f <span class="Statement">*</span> comma(<span class="Constant">5</span>) <span class="Statement">**</span> j

            <span class="Statement">case</span> (<span class="Constant">'close'</span>)
               f <span class="Statement">=</span> f <span class="Statement">*</span> just_fifth <span class="Statement">**</span> i
               j <span class="Statement">=</span> i <span class="Statement">+</span> <span class="Identifier">modulo</span>(<span class="Constant">5</span> <span class="Statement">-</span> keynote, <span class="Constant">11</span>)
               j <span class="Statement">=</span> (j <span class="Statement">-</span> <span class="Identifier">modulo</span>(j, <span class="Constant">11</span>)) <span class="Statement">/</span> <span class="Constant">11</span>
               f <span class="Statement">=</span> f <span class="Statement">*</span> comma(<span class="Constant">5</span>) <span class="Statement">**</span> j
            <span class="Statement">end select</span>

            <span class="Comment">! fold back to first octave:</span>
            j <span class="Statement">=</span> <span class="Constant">4</span> <span class="Statement">*</span> i <span class="Statement">+</span> <span class="Constant">5</span>
            j <span class="Statement">=</span> (j <span class="Statement">-</span> <span class="Identifier">modulo</span>(j, <span class="Constant">7</span>)) <span class="Statement">/</span> <span class="Constant">7</span>
            f <span class="Statement">=</span> f <span class="Statement">/</span> <span class="Constant">2.0_dp</span> <span class="Statement">**</span> j

            <span class="Comment">! position on twelve-tone scale:</span>
            j <span class="Statement">=</span> i <span class="Statement">*</span> <span class="Constant">7</span> <span class="Statement">-</span> <span class="Constant">12</span> <span class="Statement">*</span> j

            <span class="Statement">if</span> (<span class="Identifier">index</span>(<span class="Constant">'UV'</span>, symbol) <span class="Statement">.ne.</span> <span class="Constant">0</span>) <span class="Statement">then</span>
               j <span class="Statement">=</span> (newtone <span class="Statement">-</span> j) <span class="Statement">/</span> <span class="Constant">12</span>
            <span class="Statement">else</span>
               word <span class="Statement">=</span> next(numeral, <span class="Constant">'none'</span>)

               tone <span class="Statement">=</span> j

               <span class="Statement">if</span> (word <span class="Statement">.eq.</span> <span class="Constant">'none'</span>) <span class="Statement">then</span>
                  j <span class="Statement">=</span> <span class="Constant">4</span> <span class="Statement">+</span> <span class="Identifier">nint</span>(<span class="Identifier">log</span>(fi <span class="Statement">/</span> f) <span class="Statement">/</span> <span class="Identifier">log</span>(<span class="Constant">2.0_dp</span>))

                  keynote <span class="Statement">=</span> i
               <span class="Statement">else</span>
                  j <span class="Statement">=</span> <span class="Identifier">nint</span>(rational(word))
               <span class="Statement">end if</span>

               tone <span class="Statement">=</span> tone <span class="Statement">+</span> <span class="Constant">12</span> <span class="Statement">*</span> j
            <span class="Statement">end if</span>

            f <span class="Statement">=</span> f <span class="Statement">*</span> <span class="Constant">2.0_dp</span> <span class="Statement">**</span> (j <span class="Statement">-</span> <span class="Constant">4</span>)
            fi <span class="Statement">=</span> f

            word <span class="Statement">=</span> next(numeral, <span class="Constant">'none'</span>)

            <span class="Statement">if</span> (word <span class="Statement">.ne.</span> <span class="Constant">'none'</span>) <span class="Statement">then</span>
               primes <span class="Statement">=</span> accidentals(word)
               <span class="Statement">do</span> j <span class="Statement">=</span> <span class="Constant">1</span>, <span class="Identifier">size</span>(primes)
                  f <span class="Statement">=</span> f <span class="Statement">*</span> comma(primes(j))
               <span class="Statement">end do</span>
            <span class="Statement">end if</span>

            <span class="Statement">if</span> (<span class="Identifier">index</span>(<span class="Constant">'UV'</span>, symbol) <span class="Statement">.eq.</span> <span class="Constant">0</span>) f0 <span class="Statement">=</span> f

         <span class="Statement">case</span> (<span class="Constant">'@'</span>)
            A4 <span class="Statement">=</span> n(s <span class="Statement">/</span> <span class="Identifier">size</span>(wave)) <span class="Statement">/</span> s
            f0 <span class="Statement">=</span> A4
            fi <span class="Statement">=</span> f0
            f <span class="Statement">=</span> fi

         <span class="Statement">case</span> (<span class="Constant">'</span><span class="Special">&amp;</span><span class="Constant">'</span>)
            a0 <span class="Statement">=</span> n()
            ai <span class="Statement">=</span> a0
            a <span class="Statement">=</span> ai

         <span class="Statement">case</span> (<span class="Constant">'%'</span>)
            r0 <span class="Statement">=</span> n()
            ri <span class="Statement">=</span> r0
            r <span class="Statement">=</span> ri

         <span class="Statement">case</span> (<span class="Constant">'R'</span>)
            f0 <span class="Statement">=</span> f
            fi <span class="Statement">=</span> f0
            a0 <span class="Statement">=</span> a
            ai <span class="Statement">=</span> a0
            r0 <span class="Statement">=</span> r
            ri <span class="Statement">=</span> r0

         <span class="Statement">case</span> (<span class="Constant">'Q'</span>)
            fi <span class="Statement">=</span> n() <span class="Statement">*</span> f0
            f <span class="Statement">=</span> fi

         <span class="Statement">case</span> (<span class="Constant">'_'</span>, <span class="Constant">'^'</span>)
            fb <span class="Statement">=</span> <span class="Constant">2.0_dp</span> <span class="Statement">**</span> (sgn(<span class="Constant">'_^'</span>) <span class="Statement">*</span> n() <span class="Statement">/</span> steps)
         <span class="Statement">case</span> (<span class="Constant">'\'</span>, <span class="Constant">'/'</span>)
            fd <span class="Statement">=</span> <span class="Constant">2.0_dp</span> <span class="Statement">**</span> (sgn(<span class="Constant">'\/'</span>) <span class="Statement">*</span> n() <span class="Statement">/</span> steps)
         <span class="Statement">case</span> (<span class="Constant">'-'</span>, <span class="Constant">'+'</span>)
            fi <span class="Statement">=</span> <span class="Constant">2.0_dp</span> <span class="Statement">**</span> (sgn(<span class="Constant">'-+'</span>) <span class="Statement">*</span> n() <span class="Statement">/</span> steps) <span class="Statement">*</span> f0
            f <span class="Statement">=</span> fi

         <span class="Statement">case</span> (<span class="Constant">','</span>, <span class="Constant">';'</span>)
            ab <span class="Statement">=</span> <span class="Constant">10.0_dp</span> <span class="Statement">**</span> (sgn(<span class="Constant">',;'</span>) <span class="Statement">*</span> n() <span class="Statement">*</span> <span class="Constant">0.1_dp</span>)
         <span class="Statement">case</span> (<span class="Constant">'&gt;'</span>, <span class="Constant">'&lt;'</span>)
            ad <span class="Statement">=</span> <span class="Constant">10.0_dp</span> <span class="Statement">**</span> (sgn(<span class="Constant">'&gt;&lt;'</span>) <span class="Statement">*</span> n() <span class="Statement">*</span> <span class="Constant">0.1_dp</span>)
         <span class="Statement">case</span> (<span class="Constant">'?'</span>, <span class="Constant">'!'</span>)
            ai <span class="Statement">=</span> <span class="Constant">10.0_dp</span> <span class="Statement">**</span> (sgn(<span class="Constant">'?!'</span>) <span class="Statement">*</span> n() <span class="Statement">*</span> <span class="Constant">0.1_dp</span>) <span class="Statement">*</span> a0
            a <span class="Statement">=</span> ai

         <span class="Statement">case</span> (<span class="Constant">'{'</span>, <span class="Constant">'}'</span>)
            rb <span class="Statement">=</span> <span class="Constant">10.0_dp</span> <span class="Statement">**</span> (sgn(<span class="Constant">'{}'</span>) <span class="Statement">*</span> n() <span class="Statement">*</span> <span class="Constant">0.1_dp</span>)
         <span class="Statement">case</span> (<span class="Constant">'('</span>, <span class="Constant">')'</span>)
            rd <span class="Statement">=</span> <span class="Constant">10.0_dp</span> <span class="Statement">**</span> (sgn(<span class="Constant">'()'</span>) <span class="Statement">*</span> n() <span class="Statement">*</span> <span class="Constant">0.1_dp</span>)
         <span class="Statement">case</span> (<span class="Constant">'['</span>, <span class="Constant">']'</span>)
            ri <span class="Statement">=</span> <span class="Constant">10.0_dp</span> <span class="Statement">**</span> (sgn(<span class="Constant">'[]'</span>) <span class="Statement">*</span> n() <span class="Statement">*</span> <span class="Constant">0.1_dp</span>) <span class="Statement">*</span> r0
            r <span class="Statement">=</span> ri

         <span class="Statement">case</span> (<span class="Constant">'P'</span>)
            phase <span class="Statement">=</span> n()

         <span class="Statement">case</span> (<span class="Constant">&quot;'&quot;</span>)
            x <span class="Statement">=</span> x <span class="Statement">+</span> n(<span class="Constant">1.0_dp</span>) <span class="Statement">*</span> b
            d <span class="Statement">=</span> <span class="Identifier">nint</span>(x) <span class="Statement">-</span> t

            f1 <span class="Statement">=</span> fd <span class="Statement">**</span> (<span class="Constant">1.0_dp</span> <span class="Statement">/</span> d) <span class="Statement">*</span> fb <span class="Statement">**</span> (<span class="Constant">1.0_dp</span> <span class="Statement">/</span> b)
            fd <span class="Statement">=</span> <span class="Constant">1.0_dp</span>
            a1 <span class="Statement">=</span> ad <span class="Statement">**</span> (<span class="Constant">1.0_dp</span> <span class="Statement">/</span> d) <span class="Statement">*</span> ab <span class="Statement">**</span> (<span class="Constant">1.0_dp</span> <span class="Statement">/</span> b)
            ad <span class="Statement">=</span> <span class="Constant">1.0_dp</span>
            r1 <span class="Statement">=</span> rd <span class="Statement">**</span> (<span class="Constant">1.0_dp</span> <span class="Statement">/</span> d) <span class="Statement">*</span> rb <span class="Statement">**</span> (<span class="Constant">1.0_dp</span> <span class="Statement">/</span> b)
            rd <span class="Statement">=</span> <span class="Constant">1.0_dp</span>

            <span class="Statement">if</span> (loudness) <span class="Statement">then</span>
               boost <span class="Statement">=</span> A4 <span class="Statement">/</span> f
            <span class="Statement">else</span>
               boost <span class="Statement">=</span> <span class="Constant">1.0_dp</span>
            <span class="Statement">end if</span>

            <span class="Statement">do</span> i <span class="Statement">=</span> c <span class="Statement">+</span> <span class="Constant">1</span>, c <span class="Statement">+</span> d
               phase <span class="Statement">=</span> phase <span class="Statement">-</span> <span class="Identifier">floor</span>(phase)

               <span class="Statement">if</span> (synth) <span class="Statement">then</span>
                  <span class="Identifier">call</span> karplus_strong(rho, i, <span class="Constant">1.0_dp</span> <span class="Statement">/</span> f, blend, decay, tuned)
               <span class="Statement">else</span>
                  rho(i) <span class="Statement">=</span> wave(<span class="Identifier">floor</span>(<span class="Identifier">size</span>(wave) <span class="Statement">*</span> phase))
               <span class="Statement">end if</span>

               tau(i) <span class="Statement">=</span> a <span class="Statement">*</span> boost
               phi(i) <span class="Statement">=</span> <span class="Identifier">atan</span>(r)

               phase <span class="Statement">=</span> phase <span class="Statement">+</span> f

               f <span class="Statement">=</span> f <span class="Statement">*</span> f1
               a <span class="Statement">=</span> a <span class="Statement">*</span> a1
               r <span class="Statement">=</span> r <span class="Statement">*</span> r1
            <span class="Statement">end do</span>

            c <span class="Statement">=</span> c <span class="Statement">+</span> d
            t <span class="Statement">=</span> t <span class="Statement">+</span> d

         <span class="Statement">case</span> <span class="Statement">default</span>
            <span class="Identifier">call</span> routine_cases
            <span class="Statement">if</span> (over) <span class="Statement">exit</span>
         <span class="Statement">end select</span>
      <span class="Statement">end do</span>

      tones%amplitude <span class="Statement">=</span> <span class="Identifier">maxval</span>(<span class="Identifier">abs</span>(mel))

      <span class="Statement">if</span> (tones%amplitude <span class="Statement">.ne.</span> <span class="Constant">0.0_dp</span>) mel <span class="Statement">=</span> mel <span class="Statement">/</span> tones%amplitude

      <span class="Statement">if</span> (tones%channels <span class="Statement">.eq.</span> <span class="Constant">2_i2</span>) <span class="Statement">then</span>
         tones%amplitude <span class="Statement">=</span> <span class="Identifier">sqrt</span>(<span class="Constant">2.0_dp</span>) <span class="Statement">*</span> tones%amplitude
      <span class="Statement">end if</span>

      tones%sound <span class="Statement">=</span> <span class="Identifier">nint</span>(i2max <span class="Statement">*</span> mel, i2)

   <span class="PreProc">contains</span>

      <span class="PreProc">function</span> done()
         <span class="Type">logical</span> :: done

         done <span class="Statement">=</span> symbol <span class="Statement">.eq.</span> <span class="Constant">'none'</span>
         done <span class="Statement">=</span> done <span class="Statement">.or.</span> <span class="Identifier">scan</span>(symbol, initial) <span class="Statement">.gt.</span> <span class="Constant">0</span>
         done <span class="Statement">=</span> done <span class="Statement">.and.</span> c <span class="Statement">.gt.</span> <span class="Constant">0</span>
      <span class="PreProc">end function</span> done

      <span class="PreProc">function</span> n(def)
         <span class="Identifier">real</span>(dp) :: n

         <span class="Identifier">real</span>(dp), <span class="Type">intent</span>(<span class="Type">in</span>), <span class="Type">optional</span> :: def

         <span class="Statement">if</span> (<span class="Identifier">present</span>(def)) <span class="Statement">then</span>
            n <span class="Statement">=</span> rational(next(numeral, <span class="Constant">'-1'</span>))
            <span class="Statement">if</span> (n <span class="Statement">.eq.</span> <span class="Statement">-</span><span class="Constant">1.0_dp</span>) n <span class="Statement">=</span> def
         <span class="Statement">else</span>
            n <span class="Statement">=</span> rational(next(numeral))
         <span class="Statement">end if</span>
      <span class="PreProc">end function</span> n

      <span class="PreProc">function</span> sgn(minusplus)
         <span class="Type">integer</span> :: sgn

         <span class="Type">character</span>(<span class="Constant">2</span>), <span class="Type">intent</span>(<span class="Type">in</span>) :: minusplus

         sgn <span class="Statement">=</span> <span class="Constant">2</span> <span class="Statement">*</span> <span class="Identifier">index</span>(minusplus, symbol) <span class="Statement">-</span> <span class="Constant">3</span>
      <span class="PreProc">end function</span> sgn

      <span class="PreProc">subroutine</span> routine_cases
         over <span class="Statement">=</span> <span class="Constant">.false.</span>

         <span class="Statement">select case</span> (symbol)
         <span class="Statement">case</span> (<span class="Constant">'|'</span>)
            b <span class="Statement">=</span> n() <span class="Statement">*</span> s

         <span class="Statement">case</span> (<span class="Constant">'&quot;'</span>, <span class="Constant">'`'</span>)
            x <span class="Statement">=</span> x <span class="Statement">+</span> sgn(<span class="Constant">'`&quot;'</span>) <span class="Statement">*</span> n(<span class="Constant">1.0_dp</span>) <span class="Statement">*</span> b
            t <span class="Statement">=</span> <span class="Identifier">nint</span>(x)

         <span class="Statement">case</span> (<span class="Constant">'M'</span>)
            i <span class="Statement">=</span> <span class="Identifier">int</span>(n(<span class="Constant">0.0_dp</span>))
            marks(i) <span class="Statement">=</span> x
            mark_set(i) <span class="Statement">=</span> <span class="Constant">.true.</span>

         <span class="Statement">case</span> (<span class="Constant">'W'</span>)
            i <span class="Statement">=</span> <span class="Identifier">int</span>(n(<span class="Constant">0.0_dp</span>))
            <span class="Statement">if</span> (mark_set(i)) <span class="Statement">then</span>
               x <span class="Statement">=</span> marks(i)
               t <span class="Statement">=</span> <span class="Identifier">nint</span>(x)
            <span class="Statement">end if</span>

         <span class="Statement">case</span> (<span class="Constant">'Y'</span>)
            i <span class="Statement">=</span> <span class="Identifier">int</span>(n())
            j <span class="Statement">=</span> <span class="Identifier">int</span>(n())

            <span class="Statement">if</span> (mark_set(i) <span class="Statement">.and.</span> mark_set(j)) <span class="Statement">then</span>
               x1 <span class="Statement">=</span> marks(i)
               x2 <span class="Statement">=</span> marks(j)
               dx <span class="Statement">=</span> x2 <span class="Statement">-</span> x1

               <span class="Statement">if</span> (<span class="Identifier">allocated</span>(mel)) <span class="Statement">then</span>
                  t1 <span class="Statement">=</span> <span class="Identifier">nint</span>(x1)
                  t2 <span class="Statement">=</span> <span class="Identifier">nint</span>(x2)
                  dt <span class="Statement">=</span> t2 <span class="Statement">-</span> t1
               <span class="Statement">end if</span>

               <span class="Statement">do</span> i <span class="Statement">=</span> <span class="Constant">1</span>, <span class="Identifier">int</span>(n(<span class="Constant">1.0_dp</span>))
                  x <span class="Statement">=</span> x <span class="Statement">+</span> dx
                  t <span class="Statement">=</span> <span class="Identifier">nint</span>(x)

                  <span class="Statement">if</span> (<span class="Identifier">allocated</span>(mel)) mel(:, t <span class="Statement">-</span> dt <span class="Statement">+</span> <span class="Constant">1</span>:t) <span class="Special">&amp;</span>
                     <span class="Statement">=</span> mel(:, t <span class="Statement">-</span> dt <span class="Statement">+</span> <span class="Constant">1</span>:t) <span class="Statement">+</span> mel(:, t1 <span class="Statement">+</span> <span class="Constant">1</span>:t2)
               <span class="Statement">end do</span>
            <span class="Statement">end if</span>

         <span class="Statement">case</span> (<span class="Constant">'I'</span>)
            <span class="Identifier">call</span> remember(<span class="Identifier">int</span>(n(<span class="Constant">0.0_dp</span>)))

         <span class="Statement">case</span> (<span class="Constant">'J'</span>)
            i <span class="Statement">=</span> <span class="Identifier">int</span>(n(<span class="Constant">0.0_dp</span>))

            <span class="Statement">if</span> (known(i)) <span class="Statement">then</span>
               j <span class="Statement">=</span> <span class="Identifier">int</span>(n(<span class="Constant">1.0_dp</span>))

               <span class="Statement">if</span> (j <span class="Statement">.eq.</span> <span class="Constant">0</span>) j <span class="Statement">=</span> i2max

               <span class="Identifier">call</span> get(k)

               <span class="Statement">if</span> (k <span class="Statement">.lt.</span> j) <span class="Statement">then</span>
                  <span class="Identifier">call</span> set(k <span class="Statement">+</span> <span class="Constant">1</span>)
                  <span class="Identifier">call</span> revert(i)
               <span class="Statement">else</span>
                  <span class="Identifier">call</span> set(<span class="Constant">0</span>)
               <span class="Statement">end if</span>
            <span class="Statement">end if</span>

         <span class="Statement">case</span> (<span class="Constant">'K'</span>, <span class="Constant">'L'</span>)
            <span class="Identifier">call</span> get(i)
            i <span class="Statement">=</span> i <span class="Statement">+</span> <span class="Constant">1</span>
            <span class="Identifier">call</span> set(i)

            <span class="Statement">do</span>
               j <span class="Statement">=</span> <span class="Identifier">int</span>(n(<span class="Statement">-</span><span class="Constant">1.0_dp</span>))
               l <span class="Statement">=</span> i <span class="Statement">.eq.</span> j
               <span class="Statement">if</span> (l <span class="Statement">.or.</span> j <span class="Statement">.eq.</span> <span class="Statement">-</span><span class="Constant">1</span>) <span class="Statement">exit</span>
            <span class="Statement">end do</span>

            <span class="Statement">if</span> (symbol <span class="Statement">.eq.</span> <span class="Constant">'K'</span> <span class="Statement">.eqv.</span> l) <span class="Statement">then</span>
               <span class="Statement">do</span>
                  <span class="Statement">if</span> (next(special, length<span class="Statement">=</span><span class="Constant">1</span>) <span class="Statement">.ne.</span> <span class="Constant">'*'</span>) <span class="Statement">return</span>
                  <span class="Statement">if</span> (next(<span class="Constant">'*'</span>, length<span class="Statement">=</span><span class="Constant">1</span>, barrier<span class="Statement">=</span><span class="Constant">'*'</span>) <span class="Statement">.eq.</span> <span class="Constant">'none'</span>) <span class="Statement">exit</span>
               <span class="Statement">end do</span>

               over <span class="Statement">=</span> <span class="Constant">.true.</span>
            <span class="Statement">end if</span>

         <span class="Statement">case</span> (<span class="Constant">'*'</span>)
            <span class="Statement">if</span> (next(<span class="Constant">'*'</span>, length<span class="Statement">=</span><span class="Constant">1</span>, barrier<span class="Statement">=</span><span class="Constant">'*'</span>) <span class="Statement">.eq.</span> <span class="Constant">'none'</span>) over <span class="Statement">=</span> <span class="Constant">.true.</span>

         <span class="Statement">case</span> (<span class="Constant">'none'</span>)
            over <span class="Statement">=</span> <span class="Constant">.true.</span>
         <span class="Statement">end select</span>
      <span class="PreProc">end subroutine</span> routine_cases
   <span class="PreProc">end subroutine</span> play

   <span class="PreProc">subroutine</span> load(x, what, how, i)
      <span class="Identifier">real</span>(dp), <span class="Type">intent</span>(<span class="Type">out</span>), <span class="Type">allocatable</span> :: x(:)
      <span class="Type">character</span>(<span class="Statement">*</span>), <span class="Type">intent</span>(<span class="Type">in</span>) :: what, how
      <span class="Type">integer</span>, <span class="Type">intent</span>(<span class="Type">in</span>) :: i
      <span class="Type">type</span>(audio) :: s

      <span class="Statement">if</span> (how <span class="Statement">.eq.</span> <span class="Constant">'#'</span>) <span class="Statement">then</span>
         <span class="Statement">if</span> (i <span class="Statement">.gt.</span> <span class="Identifier">command_argument_count</span>() <span class="Statement">-</span> <span class="Constant">3</span>) <span class="Statement">then</span>
            <span class="Statement">write</span> (stderr, <span class="Constant">&quot;('Error: File ', I0, ' missing.')&quot;</span>) i
            <span class="Statement">stop</span>
         <span class="Statement">end if</span>

         <span class="Identifier">call</span> read_riff(command_argument(i, <span class="Constant">'/dev/stdin'</span>), s)

         <span class="Statement">allocate</span>(x(<span class="Constant">0</span>:s%points <span class="Statement">-</span> <span class="Constant">1</span>))

         x <span class="Statement">=</span> s%amplitude <span class="Statement">/</span> i2max <span class="Statement">*</span> s%sound(<span class="Constant">0</span>, :)
      <span class="Statement">else</span>
         <span class="Statement">allocate</span>(x(<span class="Constant">0</span>:i <span class="Statement">-</span> <span class="Constant">1</span>))

         <span class="Identifier">call</span> sample(x, what, how)
      <span class="Statement">end if</span>
   <span class="PreProc">end subroutine</span> load
<span class="PreProc">end module</span> interpreter
</pre>
<h2>intervals.f90</h2>
<pre id='vimCodeElement'>
<span class="PreProc">module</span> intervals
   <span class="PreProc">use</span> constants, <span class="PreProc">only</span>: dp
   <span class="Type">implicit</span> <span class="Type">none</span>
   <span class="Type">private</span>

   <span class="Type">public</span> :: interval

<span class="PreProc">contains</span>

   <span class="PreProc">subroutine</span> interval(x, a, b, n)
      <span class="Identifier">real</span>(dp), <span class="Type">intent</span>(<span class="Type">out</span>) :: x(:)
      <span class="Identifier">real</span>(dp), <span class="Type">intent</span>(<span class="Type">in</span>) :: a, b
      <span class="Type">integer</span>, <span class="Type">intent</span>(<span class="Type">in</span>), <span class="Type">optional</span> :: n
      <span class="Comment">!      n:      0      1      2      3</span>
      <span class="Comment">! binary:     00     01     10     11</span>
      <span class="Comment">! yields:  (a,b)  (a,b]  [a,b)  [a,b]</span>

      <span class="Type">integer</span> :: i, j, k

      i <span class="Statement">=</span> <span class="Identifier">size</span>(x)
      j <span class="Statement">=</span> <span class="Constant">1</span>

      <span class="Statement">if</span> (<span class="Identifier">present</span>(n)) <span class="Statement">then</span>
         <span class="Statement">if</span> (<span class="Identifier">btest</span>(n, <span class="Constant">1</span>)) j <span class="Statement">=</span> j <span class="Statement">-</span> <span class="Constant">1</span>
         <span class="Statement">if</span> (<span class="Identifier">btest</span>(n, <span class="Constant">0</span>)) i <span class="Statement">=</span> i <span class="Statement">-</span> <span class="Constant">1</span>
      <span class="Statement">end if</span>

      <span class="Statement">if</span> (i <span class="Statement">+</span> j <span class="Statement">.eq.</span> <span class="Constant">0</span>) <span class="Statement">then</span>
         i <span class="Statement">=</span> <span class="Constant">1</span>
         j <span class="Statement">=</span> <span class="Constant">1</span>
      <span class="Statement">end if</span>

      <span class="Statement">do</span> k <span class="Statement">=</span> <span class="Constant">1</span>, <span class="Identifier">size</span>(x)
         x(k) <span class="Statement">=</span> i <span class="Statement">*</span> a <span class="Statement">+</span> j <span class="Statement">*</span> b
         i <span class="Statement">=</span> i <span class="Statement">-</span> <span class="Constant">1</span>
         j <span class="Statement">=</span> j <span class="Statement">+</span> <span class="Constant">1</span>
      <span class="Statement">end do</span>

      x <span class="Statement">=</span> x <span class="Statement">/</span> (i <span class="Statement">+</span> j)
   <span class="PreProc">end subroutine</span> interval
<span class="PreProc">end module</span> intervals
</pre>
<h2>io.f90</h2>
<pre id='vimCodeElement'>
<span class="PreProc">module</span> io
   <span class="PreProc">use</span> constants, <span class="PreProc">only</span>: eof, eol, stderr
   <span class="Type">implicit</span> <span class="Type">none</span>
   <span class="Type">private</span>

   <span class="Type">public</span> :: slurp, command_argument, environment_variable

<span class="PreProc">contains</span>

   <span class="PreProc">function</span> slurp(path) <span class="PreProc">result</span>(content)
      <span class="Type">character</span>(:), <span class="Type">allocatable</span> :: content

      <span class="Type">character</span>(<span class="Statement">*</span>), <span class="Type">intent</span>(<span class="Type">in</span>) :: path

      <span class="Type">integer</span> :: fun, i, error
      <span class="Type">logical</span> :: f

      <span class="Type">character</span>, <span class="Type">parameter</span> :: lf <span class="Statement">=</span> <span class="Identifier">new_line</span>(<span class="Constant">'A'</span>)

      f <span class="Statement">=</span> path <span class="Statement">.ne.</span> <span class="Constant">'stdin'</span>

      <span class="Statement">if</span> (f) <span class="Statement">then</span>
         <span class="Statement">open</span> (<span class="Statement">newunit</span><span class="Statement">=</span>fun, <span class="Statement">file</span><span class="Statement">=</span>path, <span class="Statement">iostat</span><span class="Statement">=</span>error, <span class="Special">&amp;</span>
            <span class="Statement">action</span><span class="Statement">=</span><span class="Constant">'read'</span>, <span class="Statement">status</span><span class="Statement">=</span><span class="Constant">'old'</span>, <span class="Statement">access</span><span class="Statement">=</span><span class="Constant">'stream'</span>)

         <span class="Statement">if</span> (error <span class="Statement">.ne.</span> <span class="Constant">0</span>) <span class="Statement">then</span>
            <span class="Statement">write</span> (stderr, <span class="Constant">&quot;('Error: Cannot read file ''', A, '''.')&quot;</span>) path
            <span class="Statement">stop</span>
         <span class="Statement">end if</span>
      <span class="Statement">end if</span>

      <span class="Statement">allocate</span>(<span class="Type">character</span>(<span class="Constant">1048576</span>) :: content)

      <span class="Statement">do</span> i <span class="Statement">=</span> <span class="Constant">1</span>, <span class="Identifier">len</span>(content)
         <span class="Statement">if</span> (f) <span class="Statement">then</span>
            <span class="Statement">read</span> (fun, <span class="Statement">iostat</span><span class="Statement">=</span>error) content(i:i)
         <span class="Statement">else</span>
            <span class="Statement">read</span> (<span class="Statement">*</span>, <span class="Constant">'(A1)'</span>, <span class="Statement">iostat</span><span class="Statement">=</span>error, <span class="Statement">advance</span><span class="Statement">=</span><span class="Constant">'no'</span>) content(i:i)
            <span class="Statement">if</span> (error <span class="Statement">.eq.</span> eol) content(i:i) <span class="Statement">=</span> lf
         <span class="Statement">end if</span>
         <span class="Statement">if</span> (error <span class="Statement">.eq.</span> eof) <span class="Statement">then</span>
            content <span class="Statement">=</span> content(<span class="Constant">1</span>:i <span class="Statement">-</span> <span class="Constant">1</span>)
            <span class="Statement">exit</span>
         <span class="Statement">end if</span>
      <span class="Statement">end do</span>

      <span class="Statement">if</span> (f) <span class="Statement">close</span> (fun)
   <span class="PreProc">end function</span> slurp

   <span class="PreProc">function</span> command_argument(num, def) <span class="PreProc">result</span>(arg)
      <span class="Type">character</span>(:), <span class="Type">allocatable</span> :: arg

      <span class="Type">integer</span>, <span class="Type">intent</span>(<span class="Type">in</span>) :: num
      <span class="Type">character</span>(<span class="Statement">*</span>), <span class="Type">intent</span>(<span class="Type">in</span>) :: def

      <span class="Type">integer</span> :: i, n, length

      i <span class="Statement">=</span> num
      n <span class="Statement">=</span> <span class="Identifier">command_argument_count</span>()

      <span class="Statement">if</span> (<span class="Statement">-</span>n <span class="Statement">.lt.</span> i <span class="Statement">.and.</span> i <span class="Statement">.lt.</span> <span class="Constant">0</span>) i <span class="Statement">=</span> i <span class="Statement">+</span> n

      i <span class="Statement">=</span> i <span class="Statement">+</span> <span class="Constant">1</span>

      <span class="Statement">if</span> (i <span class="Statement">.lt.</span> <span class="Constant">1</span> <span class="Statement">.or.</span> i <span class="Statement">.gt.</span> n) <span class="Statement">then</span>
         arg <span class="Statement">=</span> def
      <span class="Statement">else</span>
         <span class="Identifier">call</span> <span class="Identifier">get_command_argument</span>(i, length<span class="Statement">=</span>length)

         <span class="Statement">allocate</span>(<span class="Type">character</span>(length) :: arg)

         <span class="Identifier">call</span> <span class="Identifier">get_command_argument</span>(i, <span class="Type">value</span><span class="Statement">=</span>arg)

         <span class="Statement">if</span> (arg <span class="Statement">.eq.</span> <span class="Constant">'-'</span>) arg <span class="Statement">=</span> def
      <span class="Statement">end if</span>
   <span class="PreProc">end function</span> command_argument

   <span class="PreProc">function</span> environment_variable(<span class="Statement">name</span>) <span class="PreProc">result</span>(var)
      <span class="Type">character</span>(:), <span class="Type">allocatable</span> :: var

      <span class="Type">character</span>(<span class="Statement">*</span>), <span class="Type">intent</span>(<span class="Type">in</span>) :: <span class="Statement">name</span>

      <span class="Type">integer</span> :: length

      <span class="Identifier">call</span> <span class="Identifier">get_environment_variable</span>(<span class="Statement">name</span>, length<span class="Statement">=</span>length)

      <span class="Statement">allocate</span>(<span class="Type">character</span>(length) :: var)

      <span class="Statement">if</span> (<span class="Identifier">len</span>(var) <span class="Statement">.gt.</span> <span class="Constant">0</span>) <span class="Statement">then</span>
         <span class="Identifier">call</span> <span class="Identifier">get_environment_variable</span>(<span class="Statement">name</span>, <span class="Type">value</span><span class="Statement">=</span>var)
      <span class="Statement">end if</span>
   <span class="PreProc">end function</span> environment_variable
<span class="PreProc">end module</span> io
</pre>
<h2>lcg.f90</h2>
<pre id='vimCodeElement'>
<span class="Comment">! <a href="https://en.wikipedia.org/wiki/MINSTD">https://en.wikipedia.org/wiki/MINSTD</a></span>

<span class="PreProc">module</span> lcg
   <span class="PreProc">use</span> constants, <span class="PreProc">only</span>: dp, i8
   <span class="Type">implicit</span> <span class="Type">none</span>
   <span class="Type">private</span>

   <span class="Type">public</span> :: minstd

   <span class="Type">integer</span>(i8), <span class="Type">parameter</span> :: a <span class="Statement">=</span> <span class="Constant">48271_i8</span>, m <span class="Statement">=</span> <span class="Constant">2147483647_i8</span>
   <span class="Type">integer</span>(i8), <span class="Type">save</span> :: i <span class="Statement">=</span> <span class="Constant">1_i8</span>
   <span class="Identifier">real</span>(dp), <span class="Type">parameter</span> :: s <span class="Statement">=</span> <span class="Constant">1.0_dp</span> <span class="Statement">/</span> m

<span class="PreProc">contains</span>

   <span class="PreProc">subroutine</span> minstd(r)
      <span class="Identifier">real</span>(dp), <span class="Type">intent</span>(<span class="Type">out</span>) :: r

      i <span class="Statement">=</span> <span class="Identifier">modulo</span>(i <span class="Statement">*</span> a, m)
      r <span class="Statement">=</span> s <span class="Statement">*</span> i
   <span class="PreProc">end subroutine</span> minstd
<span class="PreProc">end module</span> lcg
</pre>
<h2>mel.f90</h2>
<pre id='vimCodeElement'>
<span class="PreProc">subroutine</span> mel
   <span class="PreProc">use</span> constants, <span class="PreProc">only</span>: audio
   <span class="PreProc">use</span> interpreter, <span class="PreProc">only</span>: play
   <span class="PreProc">use</span> io, <span class="PreProc">only</span>: command_argument, slurp
   <span class="PreProc">use</span> riff, <span class="PreProc">only</span>: write_riff
   <span class="Type">implicit</span> <span class="Type">none</span>

   <span class="Type">type</span>(audio) :: music

   <span class="Identifier">call</span> play(slurp(command_argument(<span class="Statement">-</span><span class="Constant">2</span>, <span class="Constant">'/dev/stdin'</span>)), music)
   <span class="Identifier">call</span> write_riff(command_argument(<span class="Statement">-</span><span class="Constant">1</span>, <span class="Constant">'/dev/stdout'</span>), music)
<span class="PreProc">end subroutine</span> mel
</pre>
<h2>mono.f90</h2>
<pre id='vimCodeElement'>
<span class="PreProc">subroutine</span> mono
   <span class="PreProc">use</span> constants, <span class="PreProc">only</span>: audio, i2
   <span class="PreProc">use</span> io, <span class="PreProc">only</span>: command_argument
   <span class="PreProc">use</span> riff, <span class="PreProc">only</span>: read_riff, write_riff
   <span class="Type">implicit</span> <span class="Type">none</span>

   <span class="Type">integer</span>(i2) :: c
   <span class="Type">type</span>(audio) :: m, s

   <span class="Identifier">call</span> read_riff(command_argument(<span class="Constant">1</span>, <span class="Constant">'/dev/stdin'</span>), s)

   m%channels <span class="Statement">=</span> <span class="Constant">1_i2</span>
   m%points <span class="Statement">=</span> s%points
   m%rate <span class="Statement">=</span> s%rate
   m%amplitude <span class="Statement">=</span> s%amplitude

   <span class="Statement">do</span> c <span class="Statement">=</span> <span class="Constant">1</span>, s%channels
      m%sound <span class="Statement">=</span> s%sound(c:c, :)

      <span class="Identifier">call</span> write_riff(command_argument(c <span class="Statement">+</span> <span class="Constant">1</span>, <span class="Constant">'/dev/null'</span>), m)
   <span class="Statement">end do</span>
<span class="PreProc">end subroutine</span> mono
</pre>
<h2>paths.f90</h2>
<pre id='vimCodeElement'>
<span class="PreProc">module</span> paths
   <span class="Type">implicit</span> <span class="Type">none</span>
   <span class="Type">private</span>

   <span class="Type">public</span> :: extension, stem

<span class="PreProc">contains</span>

   <span class="PreProc">function</span> extension(path)
      <span class="Type">character</span>(:), <span class="Type">allocatable</span> :: extension

      <span class="Type">character</span>(<span class="Statement">*</span>), <span class="Type">intent</span>(<span class="Type">in</span>) :: path

      <span class="Type">integer</span> :: dot, slash

      dot <span class="Statement">=</span> <span class="Identifier">index</span>(path, <span class="Constant">'.'</span>, back<span class="Statement">=</span><span class="Constant">.true.</span>)
      slash <span class="Statement">=</span> <span class="Identifier">scan</span>(path, <span class="Constant">'/\:'</span>, back<span class="Statement">=</span><span class="Constant">.true.</span>)

      <span class="Statement">if</span> (dot <span class="Statement">.gt.</span> slash) <span class="Statement">then</span>
         extension <span class="Statement">=</span> path(dot <span class="Statement">+</span> <span class="Constant">1</span>:)
      <span class="Statement">else</span>
         extension <span class="Statement">=</span> <span class="Constant">''</span>
      <span class="Statement">end if</span>
   <span class="PreProc">end function</span> extension

   <span class="PreProc">function</span> stem(path)
      <span class="Type">character</span>(:), <span class="Type">allocatable</span> :: stem

      <span class="Type">character</span>(<span class="Statement">*</span>), <span class="Type">intent</span>(<span class="Type">in</span>) :: path

      <span class="Type">integer</span> :: dot, slash

      dot <span class="Statement">=</span> <span class="Identifier">index</span>(path, <span class="Constant">'.'</span>, back<span class="Statement">=</span><span class="Constant">.true.</span>)
      slash <span class="Statement">=</span> <span class="Identifier">scan</span>(path, <span class="Constant">'/\:'</span>, back<span class="Statement">=</span><span class="Constant">.true.</span>)

      <span class="Statement">if</span> (dot <span class="Statement">.gt.</span> slash) <span class="Statement">then</span>
         stem <span class="Statement">=</span> path(:dot <span class="Statement">-</span> <span class="Constant">1</span>)
      <span class="Statement">else</span>
         stem <span class="Statement">=</span> path
      <span class="Statement">end if</span>
   <span class="PreProc">end function</span> stem
<span class="PreProc">end module</span> paths
</pre>
<h2>rationals.f90</h2>
<pre id='vimCodeElement'>
<span class="PreProc">module</span> rationals
   <span class="PreProc">use</span> constants, <span class="PreProc">only</span>: dp
   <span class="Type">implicit</span> <span class="Type">none</span>
   <span class="Type">private</span>

   <span class="Type">public</span> :: rational

<span class="PreProc">contains</span>

   <span class="PreProc">function</span> rational(ratio)
      <span class="Identifier">real</span>(dp) :: rational

      <span class="Type">character</span>(<span class="Statement">*</span>), <span class="Type">intent</span>(<span class="Type">in</span>) :: ratio

      <span class="Type">integer</span> :: i, error
      <span class="Identifier">real</span>(dp) :: numerator, denominator

      i <span class="Statement">=</span> <span class="Identifier">scan</span>(ratio, <span class="Constant">':/'</span>)

      <span class="Statement">if</span> (i <span class="Statement">.eq.</span> <span class="Constant">0</span>) <span class="Statement">then</span>
         <span class="Statement">read</span> (ratio, <span class="Statement">*</span>, <span class="Statement">iostat</span><span class="Statement">=</span>error) rational
         <span class="Statement">if</span> (error <span class="Statement">.ne.</span> <span class="Constant">0</span>) rational <span class="Statement">=</span> <span class="Constant">0.0_dp</span>
      <span class="Statement">else</span>
         <span class="Statement">read</span> (ratio(:i <span class="Statement">-</span> <span class="Constant">1</span>), <span class="Statement">*</span>, <span class="Statement">iostat</span><span class="Statement">=</span>error) numerator
         <span class="Statement">if</span> (error <span class="Statement">.ne.</span> <span class="Constant">0</span>) numerator <span class="Statement">=</span> <span class="Constant">0.0_dp</span>

         <span class="Statement">read</span> (ratio(i <span class="Statement">+</span> <span class="Constant">1</span>:), <span class="Statement">*</span>, <span class="Statement">iostat</span><span class="Statement">=</span>error) denominator
         <span class="Statement">if</span> (error <span class="Statement">.ne.</span> <span class="Constant">0</span>) denominator <span class="Statement">=</span> <span class="Constant">1.0_dp</span>

         rational <span class="Statement">=</span> numerator <span class="Statement">/</span> denominator
      <span class="Statement">end if</span>
   <span class="PreProc">end function</span> rational
<span class="PreProc">end module</span> rationals
</pre>
<h2>repeat.f90</h2>
<pre id='vimCodeElement'>
<span class="PreProc">subroutine</span> repeatz
   <span class="PreProc">use</span> constants, <span class="PreProc">only</span>: audio, dp
   <span class="PreProc">use</span> io, <span class="PreProc">only</span>: command_argument
   <span class="PreProc">use</span> rationals, <span class="PreProc">only</span>: rational
   <span class="PreProc">use</span> riff, <span class="PreProc">only</span>: read_riff, write_riff
   <span class="Type">implicit</span> <span class="Type">none</span>

   <span class="Type">integer</span> :: i
   <span class="Identifier">real</span>(dp) :: factor
   <span class="Type">type</span>(audio) :: s1, s

   factor <span class="Statement">=</span> rational(command_argument(<span class="Constant">1</span>, <span class="Constant">'2'</span>))

   <span class="Identifier">call</span> read_riff(command_argument(<span class="Constant">2</span>, <span class="Constant">'/dev/stdin'</span>), s1)

   s%channels <span class="Statement">=</span> s1%channels
   s%points <span class="Statement">=</span> <span class="Identifier">nint</span>(<span class="Identifier">abs</span>(factor) <span class="Statement">*</span> s1%points)
   s%rate <span class="Statement">=</span> s1%rate
   s%amplitude <span class="Statement">=</span> s1%amplitude

   <span class="Statement">allocate</span>(s%sound(s%channels, s%points))

   <span class="Statement">if</span> (factor <span class="Statement">.gt.</span> <span class="Constant">0.0_dp</span>) <span class="Statement">then</span>
      <span class="Statement">do</span> i <span class="Statement">=</span> <span class="Constant">1</span>, s%points
         s%sound(:, i) <span class="Statement">=</span> s1%sound(:, <span class="Constant">1</span> <span class="Statement">+</span> <span class="Identifier">modulo</span>(i <span class="Statement">-</span> <span class="Constant">1</span>, s1%points))
      <span class="Statement">end do</span>
   <span class="Statement">else</span>
      <span class="Statement">do</span> i <span class="Statement">=</span> <span class="Constant">1</span>, s%points
         s%sound(:, s%points <span class="Statement">+</span> <span class="Constant">1</span> <span class="Statement">-</span> i) <span class="Special">&amp;</span>
            <span class="Statement">=</span> s1%sound(:, <span class="Constant">1</span> <span class="Statement">+</span> <span class="Identifier">modulo</span>(s1%points <span class="Statement">-</span> i, s1%points))
      <span class="Statement">end do</span>
   <span class="Statement">end if</span>

   <span class="Identifier">call</span> write_riff(command_argument(<span class="Constant">3</span>, <span class="Constant">'/dev/stdout'</span>), s)
<span class="PreProc">end subroutine</span> repeatz
</pre>
<h2>riff.f90</h2>
<pre id='vimCodeElement'>
<span class="PreProc">module</span> riff
   <span class="PreProc">use</span> bytes, <span class="PreProc">only</span>: c
   <span class="PreProc">use</span> constants, <span class="PreProc">only</span>: audio, dp, eof, i2, i4, stderr
   <span class="PreProc">use</span> extended, <span class="PreProc">only</span>: decode, encode
   <span class="Type">implicit</span> <span class="Type">none</span>
   <span class="Type">private</span>

   <span class="Type">public</span> :: read_riff, write_riff

<span class="PreProc">contains</span>

   <span class="PreProc">subroutine</span> read_riff(path, s)
      <span class="Type">character</span>(<span class="Statement">*</span>), <span class="Type">intent</span>(<span class="Type">in</span>) :: path
      <span class="Type">type</span>(audio), <span class="Type">intent</span>(<span class="Type">out</span>) :: s

      <span class="Type">integer</span> :: i, fun, error
      <span class="Type">character</span>(<span class="Constant">1</span>) :: byte
      <span class="Type">character</span>(<span class="Constant">4</span>) :: ckID, formType, applicationSignature
      <span class="Type">character</span>(<span class="Constant">10</span>) :: extended
      <span class="Type">integer</span>(i4) :: ckSize, sampleRate, byteRate
      <span class="Type">integer</span>(i2) :: sampleSize, formatTag, blockAlign

      <span class="Statement">open</span> (<span class="Statement">newunit</span><span class="Statement">=</span>fun, <span class="Statement">file</span><span class="Statement">=</span>path, <span class="Statement">iostat</span><span class="Statement">=</span>error, <span class="Special">&amp;</span>
         <span class="Statement">action</span><span class="Statement">=</span><span class="Constant">'read'</span>, <span class="Statement">status</span><span class="Statement">=</span><span class="Constant">'old'</span>, <span class="Statement">access</span><span class="Statement">=</span><span class="Constant">'stream'</span>)

      <span class="Statement">if</span> (error <span class="Statement">.ne.</span> <span class="Constant">0</span>) <span class="Statement">then</span>
         <span class="Statement">write</span> (stderr, <span class="Constant">&quot;('Error: Cannot read RIFF file ''', A, '''.')&quot;</span>) path
         <span class="Statement">stop</span>
      <span class="Statement">end if</span>

      <span class="Statement">do</span>
         <span class="Statement">read</span> (fun, <span class="Statement">iostat</span><span class="Statement">=</span>error) ckID, ckSize
         <span class="Statement">if</span> (error <span class="Statement">.eq.</span> eof) <span class="Statement">exit</span>

         <span class="Statement">select case</span> (ckID)
         <span class="Statement">case</span> (<span class="Constant">'RIFF'</span>)
            <span class="Statement">read</span> (fun) formType

         <span class="Statement">case</span> (<span class="Constant">'fmt '</span>)
            <span class="Statement">read</span> (fun) formatTag, s%channels, sampleRate, byteRate
            <span class="Statement">read</span> (fun) blockAlign, sampleSize

            s%rate <span class="Statement">=</span> <span class="Identifier">real</span>(sampleRate, dp)

            <span class="Statement">if</span> (sampleSize <span class="Statement">.ne.</span> <span class="Constant">16_i2</span>) <span class="Statement">then</span>
               <span class="Statement">write</span> (stderr, <span class="Constant">&quot;('Error: Only 16 bits supported.')&quot;</span>)
               <span class="Statement">stop</span>
            <span class="Statement">end if</span>

         <span class="Statement">case</span> (<span class="Constant">'data'</span>)
            s%points <span class="Statement">=</span> ckSize <span class="Statement">/</span> (<span class="Constant">2</span> <span class="Statement">*</span> s%channels)
            <span class="Statement">allocate</span>(s%sound(s%channels, s%points))
            <span class="Statement">read</span> (fun) s%sound

         <span class="Statement">case</span> (<span class="Constant">'APPL'</span>)
            <span class="Statement">read</span> (fun) applicationSignature

            <span class="Statement">if</span> (applicationSignature <span class="Statement">.eq.</span> <span class="Constant">'FETZ'</span>) <span class="Statement">then</span>
               <span class="Statement">read</span> (fun) extended
               s%amplitude <span class="Statement">=</span> decode(extended)
            <span class="Statement">else</span>
               <span class="Statement">read</span> (fun) (byte, i <span class="Statement">=</span> <span class="Constant">1</span>, ckSize <span class="Statement">-</span> <span class="Constant">4</span>)
            <span class="Statement">end if</span>

         <span class="Statement">case</span> (<span class="Constant">'ID3 '</span>, <span class="Constant">'id3 '</span>)
            <span class="Statement">allocate</span>(<span class="Type">character</span>(ckSize) :: s%meta)
            <span class="Statement">read</span> (fun) s%meta

         <span class="Statement">case</span> <span class="Statement">default</span>
            <span class="Statement">do</span> i <span class="Statement">=</span> <span class="Constant">1</span>, ckSize
               <span class="Statement">read</span> (fun, <span class="Statement">iostat</span><span class="Statement">=</span>error) byte

               <span class="Statement">if</span> (error <span class="Statement">.ne.</span> <span class="Constant">0</span>) <span class="Statement">then</span>
                  <span class="Statement">write</span> (stderr, <span class="Constant">&quot;('Error: Corrupt RIFF file ''', A, '''.')&quot;</span>) <span class="Special">&amp;</span>
                     path
                  <span class="Statement">stop</span>
               <span class="Statement">end if</span>
            <span class="Statement">end do</span>
         <span class="Statement">end select</span>
      <span class="Statement">end do</span>

      <span class="Statement">close</span> (fun)
   <span class="PreProc">end subroutine</span> read_riff

   <span class="PreProc">subroutine</span> write_riff(path, s)
      <span class="Type">character</span>(<span class="Statement">*</span>), <span class="Type">intent</span>(<span class="Type">in</span>) :: path
      <span class="Type">type</span>(audio), <span class="Type">intent</span>(<span class="Type">in</span>) :: s

      <span class="Type">integer</span> :: fun, error
      <span class="Type">integer</span>(i4), <span class="Type">parameter</span> :: fmtSize <span class="Statement">=</span> <span class="Constant">16_i4</span>, applSize <span class="Statement">=</span> <span class="Constant">14_i4</span>
      <span class="Type">integer</span>(i4) :: riffSize, dataSize, sampleRate, byteRate
      <span class="Type">integer</span>(i2), <span class="Type">parameter</span> :: sampleSize <span class="Statement">=</span> <span class="Constant">16_i2</span>, formatTag <span class="Statement">=</span> <span class="Constant">1_i2</span>
      <span class="Type">integer</span>(i2) :: blockAlign

      blockAlign <span class="Statement">=</span> <span class="Constant">2_i2</span> <span class="Statement">*</span> s%channels
      sampleRate <span class="Statement">=</span> <span class="Identifier">nint</span>(s%rate, i4)
      byteRate <span class="Statement">=</span> blockAlign <span class="Statement">*</span> sampleRate

      dataSize <span class="Statement">=</span> blockAlign <span class="Statement">*</span> s%points
      riffSize <span class="Statement">=</span> <span class="Constant">4_i4</span> <span class="Statement">+</span> <span class="Constant">8_i4</span> <span class="Statement">+</span> fmtSize <span class="Statement">+</span> <span class="Constant">8_i4</span> <span class="Statement">+</span> dataSize

      <span class="Statement">if</span> (s%amplitude <span class="Statement">.ne.</span> <span class="Constant">1.0_dp</span>) riffSize <span class="Statement">=</span> riffSize <span class="Statement">+</span> <span class="Constant">8_i4</span> <span class="Statement">+</span> applSize

      <span class="Statement">if</span> (<span class="Identifier">allocated</span>(s%meta)) riffSize <span class="Statement">=</span> riffSize <span class="Statement">+</span> <span class="Constant">8_i4</span> <span class="Statement">+</span> <span class="Identifier">len</span>(s%meta)

      <span class="Statement">if</span> (path <span class="Statement">.eq.</span> <span class="Constant">'stdout'</span> <span class="Statement">.or.</span> path <span class="Statement">.eq.</span> <span class="Constant">'http'</span>) <span class="Statement">then</span>
         <span class="Statement">if</span> (path <span class="Statement">.eq.</span> <span class="Constant">'http'</span>) <span class="Statement">then</span>
            <span class="Statement">write</span> (<span class="Statement">*</span>, <span class="Constant">&quot;('Content-Type: audio/x-wav')&quot;</span>)
            <span class="Statement">write</span> (<span class="Statement">*</span>, <span class="Constant">&quot;('Content-Length: ', I0, /)&quot;</span>) riffSize <span class="Statement">+</span> <span class="Constant">8</span>
         <span class="Statement">end if</span>

         <span class="Statement">write</span> (<span class="Statement">*</span>, <span class="Constant">'(*(A))'</span>, <span class="Statement">advance</span><span class="Statement">=</span><span class="Constant">'no'</span>) <span class="Special">&amp;</span>
            <span class="Constant">'RIFF'</span>, c(riffSize), <span class="Constant">'WAVE'</span>, <span class="Special">&amp;</span>
            <span class="Constant">'fmt '</span>, c(fmtSize), c(formatTag), c(s%channels), <span class="Special">&amp;</span>
            c(sampleRate), c(byteRate), c(blockAlign), c(sampleSize), <span class="Special">&amp;</span>
            <span class="Constant">'data'</span>, c(dataSize), c(s%sound)

         <span class="Statement">if</span> (s%amplitude <span class="Statement">.ne.</span> <span class="Constant">1.0_dp</span>) <span class="Statement">write</span> (<span class="Statement">*</span>, <span class="Constant">'(*(A))'</span>, <span class="Statement">advance</span><span class="Statement">=</span><span class="Constant">'no'</span>) <span class="Special">&amp;</span>
            <span class="Constant">'APPL'</span>, c(applSize), <span class="Constant">'FETZ'</span>, encode(s%amplitude)

         <span class="Statement">if</span> (<span class="Identifier">allocated</span>(s%meta)) <span class="Statement">write</span> (<span class="Statement">*</span>, <span class="Constant">'(*(A))'</span>, <span class="Statement">advance</span><span class="Statement">=</span><span class="Constant">'no'</span>) <span class="Special">&amp;</span>
            <span class="Constant">'ID3 '</span>, c(<span class="Identifier">len</span>(s%meta, i4)), s%meta
      <span class="Statement">else</span>
         <span class="Statement">open</span> (<span class="Statement">newunit</span><span class="Statement">=</span>fun, <span class="Statement">file</span><span class="Statement">=</span>path, <span class="Statement">iostat</span><span class="Statement">=</span>error, <span class="Special">&amp;</span>
            <span class="Statement">action</span><span class="Statement">=</span><span class="Constant">'write'</span>, <span class="Statement">status</span><span class="Statement">=</span><span class="Constant">'replace'</span>, <span class="Statement">access</span><span class="Statement">=</span><span class="Constant">'stream'</span>)

         <span class="Statement">if</span> (error <span class="Statement">.ne.</span> <span class="Constant">0</span>) <span class="Statement">then</span>
            <span class="Statement">write</span> (stderr, <span class="Constant">&quot;('Error: Cannot write RIFF file ''', A, '''.')&quot;</span>) <span class="Special">&amp;</span>
               path
            <span class="Statement">stop</span>
         <span class="Statement">end if</span>

         <span class="Statement">write</span> (fun) <span class="Constant">'RIFF'</span>, riffSize, <span class="Constant">'WAVE'</span>, <span class="Special">&amp;</span>
            <span class="Constant">'fmt '</span>, fmtSize, formatTag, s%channels, <span class="Special">&amp;</span>
            sampleRate, byteRate, blockAlign, sampleSize, <span class="Special">&amp;</span>
            <span class="Constant">'data'</span>, dataSize, s%sound

         <span class="Statement">if</span> (s%amplitude <span class="Statement">.ne.</span> <span class="Constant">1.0_dp</span>) <span class="Statement">write</span> (fun) <span class="Special">&amp;</span>
            <span class="Constant">'APPL'</span>, applSize, <span class="Constant">'FETZ'</span>, encode(s%amplitude)

         <span class="Statement">if</span> (<span class="Identifier">allocated</span>(s%meta)) <span class="Statement">write</span> (fun) <span class="Special">&amp;</span>
            <span class="Constant">'ID3 '</span>, <span class="Identifier">len</span>(s%meta, i4), s%meta

         <span class="Statement">close</span> (fun)
      <span class="Statement">end if</span>
   <span class="PreProc">end subroutine</span> write_riff
<span class="PreProc">end module</span> riff
</pre>
<h2>riff2aiff.f90</h2>
<pre id='vimCodeElement'>
<span class="PreProc">subroutine</span> riff2aiff
   <span class="PreProc">use</span> aiff, <span class="PreProc">only</span>: write_aiff
   <span class="PreProc">use</span> constants, <span class="PreProc">only</span>: audio
   <span class="PreProc">use</span> io, <span class="PreProc">only</span>: command_argument
   <span class="PreProc">use</span> riff, <span class="PreProc">only</span>: read_riff
   <span class="Type">implicit</span> <span class="Type">none</span>

   <span class="Type">type</span>(audio) :: s

   <span class="Identifier">call</span> read_riff(command_argument(<span class="Statement">-</span><span class="Constant">2</span>, <span class="Constant">'/dev/stdin'</span>), s)
   <span class="Identifier">call</span> write_aiff(command_argument(<span class="Statement">-</span><span class="Constant">1</span>, <span class="Constant">'/dev/stdout'</span>), s)
<span class="PreProc">end subroutine</span> riff2aiff
</pre>
<h2>samples.f90</h2>
<pre id='vimCodeElement'>
<span class="PreProc">module</span> samples
   <span class="PreProc">use</span> constants, <span class="PreProc">only</span>: dp, pi, stderr
   <span class="PreProc">use</span> intervals, <span class="PreProc">only</span>: interval
   <span class="PreProc">use</span> lcg, <span class="PreProc">only</span>: minstd
   <span class="Type">implicit</span> <span class="Type">none</span>
   <span class="Type">private</span>

   <span class="Type">public</span> :: sample

<span class="PreProc">contains</span>

   <span class="PreProc">subroutine</span> sample(x, what, how)
      <span class="Identifier">real</span>(dp), <span class="Type">intent</span>(<span class="Type">out</span>) :: x(:)
      <span class="Type">character</span>(<span class="Statement">*</span>), <span class="Type">intent</span>(<span class="Type">in</span>) :: what, how

      <span class="Type">integer</span> :: i

      <span class="Statement">select case</span> (what)
      <span class="Statement">case</span> (<span class="Constant">'wave'</span>)
         <span class="Statement">select case</span> (how)
         <span class="Statement">case</span> <span class="Statement">default</span> <span class="Comment">! harmonic</span>
            <span class="Identifier">call</span> warn
            <span class="Identifier">call</span> interval(x, <span class="Constant">0.0_dp</span>, <span class="Constant">2.0_dp</span> <span class="Statement">*</span> pi, <span class="Constant">1</span>)
            x <span class="Statement">=</span> <span class="Identifier">sin</span>(x)

         <span class="Statement">case</span> (<span class="Constant">'power'</span>)
            <span class="Identifier">call</span> interval(x, <span class="Constant">0.0_dp</span>, <span class="Constant">2.0_dp</span> <span class="Statement">*</span> pi, <span class="Constant">1</span>)
            x <span class="Statement">=</span> <span class="Identifier">sin</span>(x) <span class="Statement">**</span> <span class="Constant">3</span>

         <span class="Statement">case</span> (<span class="Constant">'major'</span>)
            <span class="Identifier">call</span> interval(x, <span class="Constant">0.0_dp</span>, <span class="Constant">2.0_dp</span> <span class="Statement">*</span> pi, <span class="Constant">1</span>)
            x <span class="Statement">=</span> <span class="Identifier">sin</span>(x) <span class="Statement">**</span> <span class="Constant">5</span>

         <span class="Statement">case</span> (<span class="Constant">'constant'</span>)
            <span class="Identifier">call</span> interval(x, <span class="Constant">0.0_dp</span>, <span class="Constant">2.0_dp</span> <span class="Statement">*</span> pi, <span class="Constant">1</span>)
            x <span class="Statement">=</span> <span class="Identifier">sign</span>(<span class="Constant">1.0_dp</span>, <span class="Identifier">sin</span>(x))

         <span class="Statement">case</span> (<span class="Constant">'linear'</span>)
            <span class="Identifier">call</span> interval(x, <span class="Constant">0.0_dp</span>, <span class="Constant">2.0_dp</span> <span class="Statement">*</span> pi, <span class="Constant">1</span>)
            x <span class="Statement">=</span> <span class="Constant">2.0_dp</span> <span class="Statement">/</span> pi <span class="Statement">*</span> <span class="Identifier">asin</span>(<span class="Identifier">sin</span>(x))

         <span class="Statement">case</span> (<span class="Constant">'quadratic'</span>)
            <span class="Identifier">call</span> interval(x, <span class="Statement">-</span><span class="Constant">2.0_dp</span>, <span class="Constant">2.0_dp</span>, <span class="Constant">1</span>)
            x <span class="Statement">=</span> <span class="Identifier">sign</span>(<span class="Constant">2.0_dp</span> <span class="Statement">*</span> <span class="Identifier">abs</span>(x) <span class="Statement">-</span> x <span class="Statement">**</span> <span class="Constant">2</span>, x)

         <span class="Statement">case</span> (<span class="Constant">'circular'</span>)
            <span class="Identifier">call</span> interval(x, <span class="Statement">-</span><span class="Constant">2.0_dp</span>, <span class="Constant">2.0_dp</span>, <span class="Constant">1</span>)
            x <span class="Statement">=</span> <span class="Identifier">sign</span>(<span class="Identifier">sqrt</span>(<span class="Constant">2.0_dp</span> <span class="Statement">*</span> <span class="Identifier">abs</span>(x) <span class="Statement">-</span> x <span class="Statement">**</span> <span class="Constant">2</span>), x)

         <span class="Statement">case</span> (<span class="Constant">'cubic'</span>)
            <span class="Identifier">call</span> interval(x, <span class="Statement">-</span><span class="Constant">1.0_dp</span>, <span class="Constant">1.0_dp</span>, <span class="Constant">1</span>)
            x <span class="Statement">=</span> <span class="Constant">1.5_dp</span> <span class="Statement">*</span> <span class="Identifier">sqrt</span>(<span class="Constant">3.0_dp</span>) <span class="Statement">*</span> (x <span class="Statement">**</span> <span class="Constant">3</span> <span class="Statement">-</span> x)

         <span class="Statement">case</span> (<span class="Constant">'water'</span>)
            <span class="Identifier">call</span> interval(x, <span class="Constant">0.0_dp</span>, <span class="Constant">1.0_dp</span>, <span class="Constant">1</span>)
            x <span class="Statement">=</span> <span class="Constant">1.5_dp</span> <span class="Statement">*</span> <span class="Identifier">sqrt</span>(<span class="Constant">3.0_dp</span>) <span class="Statement">*</span> (x <span class="Statement">**</span> <span class="Constant">3</span> <span class="Statement">-</span> x) <span class="Statement">+</span> <span class="Constant">0.5_dp</span>

         <span class="Statement">case</span> (<span class="Constant">'random'</span>)
            <span class="Statement">do</span> i <span class="Statement">=</span> <span class="Constant">1</span>, <span class="Identifier">size</span>(x)
               <span class="Identifier">call</span> minstd(x(i))
            <span class="Statement">end do</span>
            x <span class="Statement">=</span> <span class="Constant">2.0_dp</span> <span class="Statement">*</span> x <span class="Statement">-</span> <span class="Constant">1.0_dp</span>
         <span class="Statement">end select</span>

      <span class="Statement">case</span> (<span class="Constant">'fade'</span>)
         <span class="Statement">select case</span> (how)
         <span class="Statement">case</span> <span class="Statement">default</span> <span class="Comment">! harmonic</span>
            <span class="Identifier">call</span> warn
            <span class="Identifier">call</span> interval(x, <span class="Constant">0.0_dp</span>, <span class="Constant">0.5_dp</span> <span class="Statement">*</span> pi, <span class="Constant">0</span>)
            x <span class="Statement">=</span> <span class="Identifier">sin</span>(x)

         <span class="Statement">case</span> (<span class="Constant">'smooth'</span>)
            <span class="Identifier">call</span> interval(x, <span class="Constant">0.0_dp</span>, <span class="Constant">0.5_dp</span> <span class="Statement">*</span> pi, <span class="Constant">0</span>)
            x <span class="Statement">=</span> <span class="Identifier">sin</span>(x) <span class="Statement">**</span> <span class="Constant">2</span>

         <span class="Statement">case</span> (<span class="Constant">'power'</span>)
            <span class="Identifier">call</span> interval(x, <span class="Constant">0.0_dp</span>, <span class="Constant">0.5_dp</span> <span class="Statement">*</span> pi, <span class="Constant">0</span>)
            x <span class="Statement">=</span> <span class="Identifier">sin</span>(x) <span class="Statement">**</span> <span class="Constant">3</span>

         <span class="Statement">case</span> (<span class="Constant">'major'</span>)
            <span class="Identifier">call</span> interval(x, <span class="Constant">0.0_dp</span>, <span class="Constant">0.5_dp</span> <span class="Statement">*</span> pi, <span class="Constant">0</span>)
            x <span class="Statement">=</span> <span class="Identifier">sin</span>(x) <span class="Statement">**</span> <span class="Constant">5</span>

         <span class="Statement">case</span> (<span class="Constant">'linear'</span>)
            <span class="Identifier">call</span> interval(x, <span class="Constant">0.0_dp</span>, <span class="Constant">1.0_dp</span>, <span class="Constant">0</span>)

         <span class="Statement">case</span> (<span class="Constant">'quadratic'</span>)
            <span class="Identifier">call</span> interval(x, <span class="Statement">-</span><span class="Constant">1.0_dp</span>, <span class="Constant">0.0_dp</span>, <span class="Constant">0</span>)
            x <span class="Statement">=</span> <span class="Constant">1.0_dp</span> <span class="Statement">-</span> x <span class="Statement">**</span> <span class="Constant">2</span>

         <span class="Statement">case</span> (<span class="Constant">'circular'</span>)
            <span class="Identifier">call</span> interval(x, <span class="Statement">-</span><span class="Constant">1.0_dp</span>, <span class="Constant">0.0_dp</span>, <span class="Constant">0</span>)
            x <span class="Statement">=</span> <span class="Identifier">sqrt</span>(<span class="Constant">1.0_dp</span> <span class="Statement">-</span> x <span class="Statement">**</span> <span class="Constant">2</span>)

         <span class="Statement">case</span> (<span class="Constant">'cubic'</span>)
            <span class="Identifier">call</span> interval(x, <span class="Constant">0.0_dp</span>, <span class="Constant">1.0_dp</span>, <span class="Constant">0</span>)
            x <span class="Statement">=</span> <span class="Constant">3.0_dp</span> <span class="Statement">*</span> x <span class="Statement">**</span> <span class="Constant">2</span> <span class="Statement">-</span> <span class="Constant">2.0_dp</span> <span class="Statement">*</span> x <span class="Statement">**</span> <span class="Constant">2</span>
         <span class="Statement">end select</span>
      <span class="Statement">end select</span>

   <span class="PreProc">contains</span>

      <span class="PreProc">subroutine</span> warn
         <span class="Statement">if</span> (how <span class="Statement">.ne.</span> <span class="Constant">'harmonic'</span>) <span class="Statement">then</span>
            <span class="Statement">write</span> (stderr, <span class="Constant">&quot;('Warning: Unknown sample ''', A, '''.')&quot;</span>) how
            <span class="Statement">write</span> (stderr, <span class="Constant">&quot;('The sample ''harmonic'' is used instead.')&quot;</span>)
            <span class="Statement">write</span> (stderr, <span class="Constant">&quot;('See ''man tz mel'' for list of samples.')&quot;</span>)
         <span class="Statement">end if</span>
      <span class="PreProc">end subroutine</span> warn
   <span class="PreProc">end subroutine</span> sample
<span class="PreProc">end module</span> samples
</pre>
<h2>search.f90</h2>
<pre id='vimCodeElement'>
<span class="PreProc">module</span> search
   <span class="PreProc">use</span> constants, <span class="PreProc">only</span>: i2
   <span class="Type">implicit</span> <span class="Type">none</span>
   <span class="Type">private</span>

   <span class="Type">public</span> :: focus, reset, next, remember, revert, known, set, get, <span class="Special">&amp;</span>
      numeral, lexical, special

   <span class="Type">character</span>(:), <span class="Type">allocatable</span> :: text
   <span class="Type">integer</span>(i2), <span class="Type">allocatable</span> :: info(:)

   <span class="Type">integer</span>, <span class="Type">save</span> :: last, marks(<span class="Constant">0</span>:<span class="Constant">99</span>)

   <span class="Type">character</span>(<span class="Statement">*</span>), <span class="Type">parameter</span> :: <span class="Special">&amp;</span>
      numeral <span class="Statement">=</span> <span class="Constant">'.0123456789:'</span>, <span class="Special">&amp;</span>
      lexical <span class="Statement">=</span> <span class="Constant">'abcdefghijklmnopqrstuvwxyz#'</span>, <span class="Special">&amp;</span>
      special <span class="Statement">=</span> <span class="Constant">'!&quot;$%</span><span class="Special">&amp;</span><span class="Constant">''()*+,-/;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`{|}~'</span>

   <span class="Type">character</span>(<span class="Statement">*</span>), <span class="Type">parameter</span> :: canonical <span class="Statement">=</span> numeral <span class="Statement">//</span> lexical <span class="Statement">//</span> special

<span class="PreProc">contains</span>

   <span class="PreProc">subroutine</span> focus(it)
      <span class="Type">character</span>(<span class="Statement">*</span>), <span class="Type">intent</span>(<span class="Type">in</span>) :: it

      text <span class="Statement">=</span> it

      <span class="Statement">if</span> (<span class="Identifier">allocated</span>(info)) <span class="Statement">deallocate</span>(info)
      <span class="Statement">allocate</span>(info(<span class="Identifier">len</span>(text)))

      <span class="Identifier">call</span> reset
   <span class="PreProc">end subroutine</span> focus

   <span class="PreProc">subroutine</span> reset
      last <span class="Statement">=</span> <span class="Constant">0</span>
      marks <span class="Statement">=</span> <span class="Statement">-</span><span class="Constant">1</span>
      info <span class="Statement">=</span> <span class="Constant">0</span>
   <span class="PreProc">end subroutine</span> reset

   <span class="PreProc">function</span> next(set, def, length, barrier)
      <span class="Type">character</span>(:), <span class="Type">allocatable</span> :: next

      <span class="Type">character</span>(<span class="Statement">*</span>), <span class="Type">intent</span>(<span class="Type">in</span>) :: set
      <span class="Type">character</span>(<span class="Statement">*</span>), <span class="Type">intent</span>(<span class="Type">in</span>), <span class="Type">optional</span> :: def
      <span class="Type">integer</span>, <span class="Type">intent</span>(<span class="Type">in</span>), <span class="Type">optional</span> :: length
      <span class="Type">character</span>(<span class="Statement">*</span>), <span class="Type">intent</span>(<span class="Type">in</span>), <span class="Type">optional</span> :: barrier

      <span class="Type">integer</span> :: first, break

      <span class="Type">character</span>(:), <span class="Type">allocatable</span> :: blocking

      <span class="Statement">if</span> (<span class="Identifier">present</span>(barrier)) <span class="Statement">then</span>
         blocking <span class="Statement">=</span> barrier
      <span class="Statement">else</span> <span class="Statement">if</span> (<span class="Identifier">present</span>(def)) <span class="Statement">then</span>
         blocking <span class="Statement">=</span> canonical
      <span class="Statement">else</span>
         blocking <span class="Statement">=</span> special
      <span class="Statement">end if</span>

      first <span class="Statement">=</span> <span class="Identifier">scan</span>(text(last <span class="Statement">+</span> <span class="Constant">1</span>:), set)
      break <span class="Statement">=</span> <span class="Identifier">scan</span>(text(last <span class="Statement">+</span> <span class="Constant">1</span>:), blocking)

      <span class="Statement">if</span> (first <span class="Statement">.eq.</span> <span class="Constant">0</span> <span class="Statement">.or.</span> break <span class="Statement">.ne.</span> <span class="Constant">0</span> <span class="Statement">.and.</span> break <span class="Statement">.lt.</span> first) <span class="Statement">then</span>
         <span class="Statement">if</span> (<span class="Identifier">present</span>(def)) <span class="Statement">then</span>
            next <span class="Statement">=</span> def
         <span class="Statement">else</span>
            next <span class="Statement">=</span> <span class="Constant">'none'</span>
         <span class="Statement">end if</span>
         <span class="Statement">return</span>
      <span class="Statement">end if</span>

      first <span class="Statement">=</span> first <span class="Statement">+</span> last

      <span class="Statement">if</span> (<span class="Identifier">present</span>(length)) <span class="Statement">then</span>
         last <span class="Statement">=</span> first <span class="Statement">+</span> length <span class="Statement">-</span> <span class="Constant">1</span>
      <span class="Statement">else</span>
         last <span class="Statement">=</span> <span class="Identifier">verify</span>(text(first <span class="Statement">+</span> <span class="Constant">1</span>:), set)

         <span class="Statement">if</span> (last <span class="Statement">.eq.</span> <span class="Constant">0</span>) <span class="Statement">then</span>
            last <span class="Statement">=</span> <span class="Identifier">len</span>(text)
         <span class="Statement">else</span>
            last <span class="Statement">=</span> last <span class="Statement">+</span> first <span class="Statement">-</span> <span class="Constant">1</span>
         <span class="Statement">end if</span>
      <span class="Statement">end if</span>

      next <span class="Statement">=</span> text(first:last)
   <span class="PreProc">end function</span> next

   <span class="PreProc">subroutine</span> remember(mark)
      <span class="Type">integer</span>, <span class="Type">intent</span>(<span class="Type">in</span>) :: mark

      marks(mark) <span class="Statement">=</span> last
   <span class="PreProc">end subroutine</span> remember

   <span class="PreProc">subroutine</span> revert(mark)
      <span class="Type">integer</span>, <span class="Type">intent</span>(<span class="Type">in</span>) :: mark

      <span class="Statement">if</span> (known(mark)) last <span class="Statement">=</span> marks(mark)
   <span class="PreProc">end subroutine</span> revert

   <span class="PreProc">function</span> known(mark)
      <span class="Type">logical</span> :: known
      <span class="Type">integer</span>, <span class="Type">intent</span>(<span class="Type">in</span>) :: mark

      known <span class="Statement">=</span> marks(mark) <span class="Statement">.ne.</span> <span class="Statement">-</span><span class="Constant">1</span>
   <span class="PreProc">end function</span> known

   <span class="PreProc">subroutine</span> set(i)
      <span class="Type">integer</span>, <span class="Type">intent</span>(<span class="Type">in</span>) :: i

      info(last) <span class="Statement">=</span> <span class="Identifier">int</span>(i, i2)
   <span class="PreProc">end subroutine</span> set

   <span class="PreProc">subroutine</span> get(i)
      <span class="Type">integer</span>, <span class="Type">intent</span>(<span class="Type">out</span>) :: i

      i <span class="Statement">=</span> info(last)
   <span class="PreProc">end subroutine</span> get
<span class="PreProc">end module</span> search
</pre>
<h2>spectra.f90</h2>
<pre id='vimCodeElement'>
<span class="PreProc">module</span> spectra
   <span class="PreProc">use</span> constants, <span class="PreProc">only</span>: dp, pi
   <span class="Type">implicit</span> <span class="Type">none</span>
   <span class="Type">private</span>

   <span class="Type">public</span> :: fourier

<span class="PreProc">contains</span>

   <span class="PreProc">subroutine</span> fourier(wave, spectrum)
      <span class="Identifier">real</span>(dp), <span class="Type">intent</span>(<span class="Type">in</span>) :: wave(:)
      <span class="Type">complex</span>(dp), <span class="Type">intent</span>(<span class="Type">out</span>) :: spectrum(:)

      <span class="Type">integer</span> :: n, m
      <span class="Identifier">real</span>(dp) :: omega, phi
      <span class="Type">complex</span>(dp) :: transform(<span class="Identifier">size</span>(spectrum), <span class="Identifier">size</span>(wave))

      omega <span class="Statement">=</span> <span class="Constant">2.0_dp</span> <span class="Statement">*</span> pi <span class="Statement">/</span> <span class="Identifier">size</span>(wave)

      <span class="Statement">do</span> m <span class="Statement">=</span> <span class="Constant">1</span>, <span class="Identifier">size</span>(wave)
         <span class="Statement">do</span> n <span class="Statement">=</span> <span class="Constant">1</span>, <span class="Identifier">size</span>(spectrum)
            phi <span class="Statement">=</span> n <span class="Statement">*</span> m <span class="Statement">*</span> omega
            transform(n, m) <span class="Statement">=</span> <span class="Identifier">cmplx</span>(<span class="Identifier">cos</span>(phi), <span class="Identifier">sin</span>(phi), dp)
         <span class="Statement">end do</span>
      <span class="Statement">end do</span>

      spectrum <span class="Statement">=</span> <span class="Identifier">matmul</span>(transform, wave) <span class="Statement">/</span> <span class="Identifier">size</span>(wave)
   <span class="PreProc">end subroutine</span> fourier
<span class="PreProc">end module</span> spectra
</pre>
<h2>stack.f90</h2>
<pre id='vimCodeElement'>
<span class="PreProc">subroutine</span> stack
   <span class="PreProc">use</span> constants, <span class="PreProc">only</span>: audio, dp, i2, i2max
   <span class="PreProc">use</span> io, <span class="PreProc">only</span>: command_argument
   <span class="PreProc">use</span> riff, <span class="PreProc">only</span>: read_riff, write_riff
   <span class="Type">implicit</span> <span class="Type">none</span>

   <span class="Type">integer</span> :: i, n, t
   <span class="Type">integer</span>(i2) :: c
   <span class="Identifier">real</span>(dp), <span class="Type">allocatable</span> :: sound(:, :)
   <span class="Type">type</span>(audio), <span class="Type">allocatable</span> :: p(:)
   <span class="Type">type</span>(audio) :: s

   s%channels <span class="Statement">=</span> <span class="Constant">1_i2</span>
   s%points <span class="Statement">=</span> <span class="Constant">0</span>
   s%rate <span class="Statement">=</span> <span class="Constant">1.0_dp</span>
   s%amplitude <span class="Statement">=</span> <span class="Constant">0.0_dp</span>

   n <span class="Statement">=</span> <span class="Identifier">command_argument_count</span>() <span class="Statement">-</span> <span class="Constant">2</span>

   <span class="Statement">allocate</span>(p(n))

   <span class="Statement">do</span> i <span class="Statement">=</span> <span class="Constant">1</span>, n
      <span class="Identifier">call</span> read_riff(command_argument(i, <span class="Constant">'/dev/stdin'</span>), p(i))

      s%channels <span class="Statement">=</span> <span class="Identifier">max</span>(s%channels, p(i)%channels)
      s%points <span class="Statement">=</span> <span class="Identifier">max</span>(s%points, p(i)%points)
      s%rate <span class="Statement">=</span> <span class="Identifier">max</span>(s%rate, p(i)%rate)
   <span class="Statement">end do</span>

   <span class="Statement">allocate</span>(s%sound(s%channels, s%points))
   <span class="Statement">allocate</span>(sound(s%channels, s%points))

   sound <span class="Statement">=</span> <span class="Constant">0.0_dp</span>

   <span class="Statement">do</span> i <span class="Statement">=</span> <span class="Constant">1</span>, n
      <span class="Statement">do</span> t <span class="Statement">=</span> <span class="Constant">1</span>, s%points
         <span class="Statement">do</span> c <span class="Statement">=</span> <span class="Constant">1</span>, s%channels
            sound(c, t) <span class="Statement">=</span> sound(c, t) <span class="Statement">+</span> p(i)%amplitude <span class="Statement">*</span> p(i)%sound( <span class="Special">&amp;</span>
               <span class="Constant">1_i2</span> <span class="Statement">+</span> <span class="Identifier">modulo</span>(c <span class="Statement">-</span> <span class="Constant">1_i2</span>, p(i)%channels), <span class="Special">&amp;</span>
               <span class="Constant">1_i2</span> <span class="Statement">+</span> <span class="Identifier">modulo</span>(t <span class="Statement">-</span> <span class="Constant">1_i2</span>, p(i)%points))
         <span class="Statement">end do</span>
      <span class="Statement">end do</span>
   <span class="Statement">end do</span>

   sound <span class="Statement">=</span> sound <span class="Statement">/</span> i2max

   <span class="Statement">if</span> (s%points <span class="Statement">.gt.</span> <span class="Constant">0</span>) <span class="Statement">then</span>
      s%amplitude <span class="Statement">=</span> <span class="Identifier">maxval</span>(<span class="Identifier">abs</span>(sound))
      s%sound <span class="Statement">=</span> <span class="Identifier">nint</span>(i2max <span class="Statement">/</span> s%amplitude <span class="Statement">*</span> sound, i2)
   <span class="Statement">end if</span>

   <span class="Identifier">call</span> write_riff(command_argument(<span class="Statement">-</span><span class="Constant">1</span>, <span class="Constant">'/dev/stdout'</span>), s)
<span class="PreProc">end subroutine</span> stack
</pre>
<h2>stick.f90</h2>
<pre id='vimCodeElement'>
<span class="PreProc">subroutine</span> stick
   <span class="PreProc">use</span> constants, <span class="PreProc">only</span>: audio, dp, i2
   <span class="PreProc">use</span> io, <span class="PreProc">only</span>: command_argument
   <span class="PreProc">use</span> riff, <span class="PreProc">only</span>: read_riff, write_riff
   <span class="Type">implicit</span> <span class="Type">none</span>

   <span class="Type">integer</span> :: i, n, offset
   <span class="Type">integer</span>(i2) :: c
   <span class="Type">type</span>(audio), <span class="Type">allocatable</span> :: p(:)
   <span class="Type">type</span>(audio) :: s

   s%channels <span class="Statement">=</span> <span class="Constant">1_i2</span>
   s%points <span class="Statement">=</span> <span class="Constant">0</span>
   s%rate <span class="Statement">=</span> <span class="Constant">1.0_dp</span>
   s%amplitude <span class="Statement">=</span> <span class="Constant">0.0_dp</span>

   n <span class="Statement">=</span> <span class="Identifier">command_argument_count</span>() <span class="Statement">-</span> <span class="Constant">2</span>

   <span class="Statement">allocate</span>(p(n))

   <span class="Statement">do</span> i <span class="Statement">=</span> <span class="Constant">1</span>, n
      <span class="Identifier">call</span> read_riff(command_argument(i, <span class="Constant">'/dev/stdin'</span>), p(i))

      s%points <span class="Statement">=</span> s%points <span class="Statement">+</span> p(i)%points

      s%channels <span class="Statement">=</span> <span class="Identifier">max</span>(s%channels, p(i)%channels)
      s%amplitude <span class="Statement">=</span> <span class="Identifier">max</span>(s%amplitude, p(i)%amplitude)
      s%rate <span class="Statement">=</span> <span class="Identifier">max</span>(s%rate, p(i)%rate)
   <span class="Statement">end do</span>

   <span class="Statement">allocate</span>(s%sound(s%channels, s%points))

   offset <span class="Statement">=</span> <span class="Constant">0</span>

   <span class="Statement">do</span> i <span class="Statement">=</span> <span class="Constant">1</span>, n
      <span class="Statement">if</span> (p(i)%amplitude <span class="Statement">.ne.</span> s%amplitude) <span class="Statement">then</span>
         p(i)%sound <span class="Statement">=</span> <span class="Identifier">int</span>(p(i)%sound <span class="Statement">*</span> p(i)%amplitude <span class="Statement">/</span> s%amplitude, i2)
      <span class="Statement">end if</span>

      <span class="Statement">do</span> c <span class="Statement">=</span> <span class="Constant">1</span>, s%channels
         s%sound(c, offset <span class="Statement">+</span> <span class="Constant">1</span>:offset <span class="Statement">+</span> p(i)%points) <span class="Special">&amp;</span>
            <span class="Statement">=</span> p(i)%sound(<span class="Constant">1_i2</span> <span class="Statement">+</span> <span class="Identifier">modulo</span>(c <span class="Statement">-</span> <span class="Constant">1_i2</span>, p(i)%channels), :)
      <span class="Statement">end do</span>

      offset <span class="Statement">=</span> offset <span class="Statement">+</span> p(i)%points
   <span class="Statement">end do</span>

   <span class="Identifier">call</span> write_riff(command_argument(<span class="Statement">-</span><span class="Constant">1</span>, <span class="Constant">'/dev/stdout'</span>), s)
<span class="PreProc">end subroutine</span> stick
</pre>
<h2>stretch.f90</h2>
<pre id='vimCodeElement'>
<span class="PreProc">subroutine</span> stretch
   <span class="PreProc">use</span> constants, <span class="PreProc">only</span>: audio, dp, i2
   <span class="PreProc">use</span> io, <span class="PreProc">only</span>: command_argument
   <span class="PreProc">use</span> rationals, <span class="PreProc">only</span>: rational
   <span class="PreProc">use</span> riff, <span class="PreProc">only</span>: read_riff, write_riff
   <span class="Type">implicit</span> <span class="Type">none</span>

   <span class="Type">integer</span> :: t, t0
   <span class="Identifier">real</span>(dp) :: t1, dt, scaling, factor
   <span class="Type">type</span>(audio) :: s0, s

   factor <span class="Statement">=</span> rational(command_argument(<span class="Constant">1</span>, <span class="Constant">'-1'</span>))

   <span class="Identifier">call</span> read_riff(command_argument(<span class="Constant">2</span>, <span class="Constant">'/dev/stdin'</span>), s0)

   s%channels <span class="Statement">=</span> s0%channels
   s%points <span class="Statement">=</span> <span class="Identifier">nint</span>(<span class="Identifier">abs</span>(factor) <span class="Statement">*</span> s0%points)
   s%rate <span class="Statement">=</span> s0%rate
   s%amplitude <span class="Statement">=</span> s0%amplitude

   <span class="Statement">if</span> (s%points <span class="Statement">.eq.</span> s0%points) <span class="Statement">then</span>
      s%sound <span class="Statement">=</span> s0%sound
   <span class="Statement">else</span>
      <span class="Statement">allocate</span>(s%sound(s0%channels, s%points))

      scaling <span class="Statement">=</span> <span class="Identifier">real</span>(s0%points <span class="Statement">-</span> <span class="Constant">1</span>, dp) <span class="Statement">/</span> <span class="Identifier">real</span>(<span class="Identifier">max</span>(s%points, <span class="Constant">2</span>) <span class="Statement">-</span> <span class="Constant">1</span>, dp)

      <span class="Statement">do</span> t <span class="Statement">=</span> <span class="Constant">0</span>, s%points <span class="Statement">-</span> <span class="Constant">1</span>
         t1 <span class="Statement">=</span> <span class="Constant">1.0_dp</span> <span class="Statement">+</span> scaling <span class="Statement">*</span> t
         t0 <span class="Statement">=</span> <span class="Identifier">floor</span>(t1)
         dt <span class="Statement">=</span> t1 <span class="Statement">-</span> t0
         s%sound(:, <span class="Constant">1</span> <span class="Statement">+</span> t) <span class="Statement">=</span> <span class="Identifier">nint</span>(s0%sound(:, t0) <span class="Statement">*</span> (<span class="Constant">1.0_dp</span> <span class="Statement">-</span> dt) <span class="Special">&amp;</span>
            <span class="Statement">+</span> s0%sound(:, t0 <span class="Statement">+</span> <span class="Constant">1</span>) <span class="Statement">*</span> dt, i2)
      <span class="Statement">end do</span>
   <span class="Statement">end if</span>

   <span class="Statement">if</span> (factor <span class="Statement">.lt.</span> <span class="Constant">0.0_dp</span>) s%sound <span class="Statement">=</span> s%sound(:, s%points:<span class="Constant">1</span>:<span class="Statement">-</span><span class="Constant">1</span>)

   <span class="Identifier">call</span> write_riff(command_argument(<span class="Constant">3</span>, <span class="Constant">'/dev/stdout'</span>), s)
<span class="PreProc">end subroutine</span> stretch
</pre>
<h2>synthesis.f90</h2>
<pre id='vimCodeElement'>
<span class="Comment">! From Kevin Karplus and Alex Strong, Digital Synthesis of Plucked-String and</span>
<span class="Comment">! Drum Timbre, Comput. Music J. 7, 43 (1983), <a href="https://doi.org/10.2307/3680062.">https://doi.org/10.2307/3680062.</a></span>
<span class="Comment">! Implementation inspired by Vincent Magnin's Fortran synthesizer &quot;ForSynth&quot;,</span>
<span class="Comment">! see <a href="https://vmagnin.github.io/forsynth.">https://vmagnin.github.io/forsynth.</a></span>

<span class="PreProc">module</span> synthesis
   <span class="PreProc">use</span> constants, <span class="PreProc">only</span>: dp
   <span class="PreProc">use</span> lcg, <span class="PreProc">only</span>: minstd
   <span class="Type">implicit</span> <span class="Type">none</span>
   <span class="Type">private</span>

   <span class="Type">public</span> :: karplus_strong

<span class="PreProc">contains</span>

   <span class="PreProc">subroutine</span> karplus_strong(y, t, period, blend, decay, tuned)
      <span class="Identifier">real</span>(dp), <span class="Type">intent</span>(<span class="Type">inout</span>) :: y(:)
      <span class="Type">integer</span>, <span class="Type">intent</span>(<span class="Type">in</span>) :: t
      <span class="Identifier">real</span>(dp), <span class="Type">intent</span>(<span class="Type">in</span>) :: period, blend, decay
      <span class="Type">logical</span>, <span class="Type">intent</span>(<span class="Type">in</span>) :: tuned

      <span class="Type">integer</span> :: p
      <span class="Identifier">real</span>(dp) :: r, v, w

      r <span class="Statement">=</span> <span class="Identifier">max</span>(period, <span class="Constant">1.0_dp</span>)

      <span class="Statement">if</span> (tuned) <span class="Statement">then</span>
         p <span class="Statement">=</span> <span class="Identifier">nint</span>(r)
         v <span class="Statement">=</span> <span class="Constant">0.5_dp</span> <span class="Statement">+</span> r <span class="Statement">-</span> p
      <span class="Statement">else</span>
         p <span class="Statement">=</span> <span class="Identifier">floor</span>(r) <span class="Comment">! signal frequency is 1 / (p + 1/2)</span>
         v <span class="Statement">=</span> <span class="Constant">1.0_dp</span>
      <span class="Statement">end if</span>

      w <span class="Statement">=</span> <span class="Constant">1.0_dp</span> <span class="Statement">-</span> v

      <span class="Identifier">call</span> minstd(r)

      <span class="Statement">if</span> (t <span class="Statement">.lt.</span> p <span class="Statement">+</span> <span class="Constant">2</span>) <span class="Statement">then</span>
         y(t) <span class="Statement">=</span> <span class="Constant">2.0_dp</span> <span class="Statement">*</span> r <span class="Statement">-</span> <span class="Constant">1.0_dp</span>
      <span class="Statement">else</span> <span class="Statement">if</span> (r <span class="Statement">.ge.</span> decay) <span class="Statement">then</span>
         y(t) <span class="Statement">=</span> y(t <span class="Statement">-</span> p)
      <span class="Statement">else</span>
         y(t) <span class="Statement">=</span> <span class="Constant">0.5_dp</span> <span class="Statement">*</span> (v <span class="Statement">*</span> y(t <span class="Statement">-</span> p <span class="Statement">-</span> <span class="Constant">1</span>) <span class="Statement">+</span> y(t <span class="Statement">-</span> p) <span class="Statement">+</span> w <span class="Statement">*</span> y(t <span class="Statement">-</span> p <span class="Statement">+</span> <span class="Constant">1</span>))
      <span class="Statement">end if</span>

      <span class="Identifier">call</span> minstd(r)
      <span class="Statement">if</span> (r <span class="Statement">.ge.</span> blend) y(t) <span class="Statement">=</span> <span class="Statement">-</span>y(t)
   <span class="PreProc">end subroutine</span> karplus_strong
<span class="PreProc">end module</span> synthesis
</pre>
<h2>tab.f90</h2>
<pre id='vimCodeElement'>
<span class="PreProc">module</span> tab
   <span class="Type">implicit</span> <span class="Type">none</span>
   <span class="Type">private</span>

   <span class="Type">public</span> :: preprocess, strip, matches, sub

   <span class="Type">integer</span> :: beats

<span class="PreProc">contains</span>

   <span class="PreProc">function</span> preprocess(tablature) <span class="PreProc">result</span>(notes)
      <span class="Type">character</span>(:), <span class="Type">allocatable</span> :: notes

      <span class="Type">character</span>(<span class="Statement">*</span>), <span class="Type">intent</span>(<span class="Type">in</span>) :: tablature

      <span class="Type">integer</span> :: lower, upper, from, till
      <span class="Type">logical</span> :: first

      <span class="Type">character</span> :: c
      <span class="Type">character</span>, <span class="Type">parameter</span> :: lf <span class="Statement">=</span> <span class="Identifier">achar</span>(<span class="Constant">10</span>), cr <span class="Statement">=</span> <span class="Identifier">achar</span>(<span class="Constant">13</span>)
      <span class="Type">character</span>(<span class="Constant">2</span>), <span class="Type">parameter</span> :: rn <span class="Statement">=</span> cr <span class="Statement">//</span> lf
      <span class="Type">character</span>(:), <span class="Type">allocatable</span> :: nl, line, bar, bars

      notes <span class="Statement">=</span> <span class="Constant">''</span>

      first <span class="Statement">=</span> <span class="Constant">.true.</span>

      lower <span class="Statement">=</span> <span class="Constant">1</span>
      <span class="Statement">do</span> <span class="Statement">while</span> (lower <span class="Statement">.le.</span> <span class="Identifier">len</span>(tablature))
         upper <span class="Statement">=</span> <span class="Identifier">scan</span>(tablature(lower:), rn)

         <span class="Statement">if</span> (upper <span class="Statement">.eq.</span> <span class="Constant">0</span>) <span class="Statement">then</span>
            upper <span class="Statement">=</span> <span class="Identifier">len</span>(tablature)

            nl <span class="Statement">=</span> <span class="Constant">''</span>
         <span class="Statement">else</span>
            upper <span class="Statement">=</span> lower <span class="Statement">+</span> upper <span class="Statement">-</span> <span class="Constant">2</span>

            nl <span class="Statement">=</span> tablature(upper <span class="Statement">+</span> <span class="Constant">1</span>:upper <span class="Statement">+</span> <span class="Constant">1</span>)

            <span class="Statement">if</span> (upper <span class="Statement">+</span> <span class="Constant">2</span> <span class="Statement">.le.</span> <span class="Identifier">len</span>(tablature)) <span class="Statement">then</span>
               c <span class="Statement">=</span> tablature(upper <span class="Statement">+</span> <span class="Constant">2</span>:upper <span class="Statement">+</span> <span class="Constant">2</span>)

               <span class="Statement">if</span> (<span class="Identifier">scan</span>(c, rn) <span class="Statement">.eq.</span> <span class="Constant">1</span> <span class="Statement">.and.</span> c <span class="Statement">.ne.</span> nl) nl <span class="Statement">=</span> nl <span class="Statement">//</span> c
            <span class="Statement">end if</span>
         <span class="Statement">end if</span>

         line <span class="Statement">=</span> <span class="Identifier">trim</span>(tablature(lower:upper))

         lower <span class="Statement">=</span> upper <span class="Statement">+</span> <span class="Identifier">len</span>(nl) <span class="Statement">+</span> <span class="Constant">1</span>

         <span class="Statement">if</span> (matches(line, <span class="Constant">'|'</span>) <span class="Statement">.gt.</span> <span class="Constant">1</span>) <span class="Statement">then</span>
            <span class="Statement">if</span> (first) <span class="Statement">then</span>
               bars <span class="Statement">=</span> <span class="Constant">'M0'</span>
               first <span class="Statement">=</span> <span class="Constant">.false.</span>
            <span class="Statement">else</span>
               bars <span class="Statement">=</span> <span class="Constant">'W0'</span>
            <span class="Statement">end if</span>

            from <span class="Statement">=</span> <span class="Constant">1</span>
            <span class="Statement">do</span> <span class="Statement">while</span> (from <span class="Statement">.le.</span> <span class="Identifier">len</span>(line))
               till <span class="Statement">=</span> <span class="Identifier">scan</span>(line(from:), <span class="Constant">'|'</span>)

               <span class="Statement">if</span> (till <span class="Statement">.eq.</span> <span class="Constant">0</span>) <span class="Statement">then</span>
                  till <span class="Statement">=</span> <span class="Identifier">len</span>(line)
               <span class="Statement">else</span>
                  till <span class="Statement">=</span> from <span class="Statement">+</span> till <span class="Statement">-</span> <span class="Constant">2</span>
               <span class="Statement">end if</span>

               bar <span class="Statement">=</span> line(from:till)

               from <span class="Statement">=</span> till <span class="Statement">+</span> <span class="Constant">2</span>

               <span class="Statement">if</span> (<span class="Identifier">scan</span>(bar, <span class="Constant">'-~'</span>) <span class="Statement">.ne.</span> <span class="Constant">0</span>) <span class="Statement">then</span>
                  bar <span class="Statement">=</span> sub(bar, <span class="Constant">'X'</span>, replace<span class="Statement">=</span><span class="Constant">'-'</span>)
                  bar <span class="Statement">=</span> sub(bar, <span class="Constant">'SZNT'</span>, replace<span class="Statement">=</span><span class="Constant">'~'</span>)

                  bar <span class="Statement">=</span> sub(bar, <span class="Constant">'-~'</span>, invert<span class="Statement">=</span><span class="Constant">.true.</span>, <span class="Special">&amp;</span>
                     keep<span class="Statement">=</span><span class="Constant">.true.</span>, replace<span class="Statement">=</span><span class="Constant">'~'</span>)

                  bar <span class="Statement">=</span> sub(bar, <span class="Constant">'0.123456789:'</span>, before<span class="Statement">=</span><span class="Constant">'-~'</span>, <span class="Special">&amp;</span>
                     insert<span class="Statement">=</span><span class="Constant">'U'</span>, keep<span class="Statement">=</span><span class="Constant">.true.</span>)

                  beats <span class="Statement">=</span> matches(bar, <span class="Constant">'-~'</span>)

                  bar <span class="Statement">=</span> sub(bar, <span class="Constant">'-'</span>, insert<span class="Statement">=</span><span class="Constant">'&quot;'</span>, ratio<span class="Statement">=</span><span class="Constant">.true.</span>)
                  bar <span class="Statement">=</span> sub(bar, <span class="Constant">'~'</span>, insert<span class="Statement">=</span><span class="Constant">&quot;'&quot;</span>, ratio<span class="Statement">=</span><span class="Constant">.true.</span>)
               <span class="Statement">end if</span>

               bars <span class="Statement">=</span> bars <span class="Statement">//</span> strip(bar)
            <span class="Statement">end do</span>

            notes <span class="Statement">=</span> notes <span class="Statement">//</span> bars <span class="Statement">//</span> nl
         <span class="Statement">else</span>
            <span class="Statement">if</span> (<span class="Identifier">len</span>(strip(line)) <span class="Statement">.eq.</span> <span class="Constant">0</span>) first <span class="Statement">=</span> <span class="Constant">.true.</span>

            notes <span class="Statement">=</span> notes <span class="Statement">//</span> line <span class="Statement">//</span> nl
         <span class="Statement">end if</span>
      <span class="Statement">end do</span>
   <span class="PreProc">end function</span> preprocess

   <span class="PreProc">function</span> strip(string)
      <span class="Type">character</span>(:), <span class="Type">allocatable</span> :: strip
      <span class="Type">character</span>(<span class="Statement">*</span>), <span class="Type">intent</span>(<span class="Type">in</span>) :: string

      <span class="Type">character</span>(<span class="Statement">*</span>), <span class="Type">parameter</span> :: whitespace <span class="Statement">=</span> <span class="Identifier">char</span>(<span class="Constant">9</span>) <span class="Statement">//</span> <span class="Constant">' '</span>
      <span class="Type">integer</span> :: lower, upper

      lower <span class="Statement">=</span> <span class="Identifier">verify</span>(string, whitespace)

      <span class="Statement">if</span> (lower <span class="Statement">.eq.</span> <span class="Constant">0</span>) <span class="Statement">then</span>
         strip <span class="Statement">=</span> <span class="Constant">''</span>
         <span class="Statement">return</span>
      <span class="Statement">end if</span>

      upper <span class="Statement">=</span> <span class="Identifier">verify</span>(string, whitespace, back<span class="Statement">=</span><span class="Constant">.true.</span>)

      strip <span class="Statement">=</span> string(lower:upper)
   <span class="PreProc">end function</span> strip

   <span class="PreProc">function</span> matches(string, set)
      <span class="Type">integer</span> :: matches
      <span class="Type">character</span>(<span class="Statement">*</span>), <span class="Type">intent</span>(<span class="Type">in</span>) :: string, set

      <span class="Type">integer</span> :: i

      matches <span class="Statement">=</span> <span class="Constant">0</span>

      <span class="Statement">do</span> i <span class="Statement">=</span> <span class="Constant">1</span>, <span class="Identifier">len_trim</span>(string)
         <span class="Statement">if</span> (<span class="Identifier">index</span>(set, string(i:i)) <span class="Statement">.ne.</span> <span class="Constant">0</span>) matches <span class="Statement">=</span> matches <span class="Statement">+</span> <span class="Constant">1</span>
      <span class="Statement">end do</span>
   <span class="PreProc">end function</span> matches

   <span class="PreProc">function</span> sub(string, set, invert, before, insert, ratio, keep, replace)
      <span class="Type">character</span>(:), <span class="Type">allocatable</span> :: sub
      <span class="Type">character</span>(<span class="Statement">*</span>), <span class="Type">intent</span>(<span class="Type">in</span>) :: string, set
      <span class="Type">character</span>(<span class="Statement">*</span>), <span class="Type">intent</span>(<span class="Type">in</span>), <span class="Type">optional</span> :: before, insert, replace
      <span class="Type">logical</span>, <span class="Type">intent</span>(<span class="Type">in</span>), <span class="Type">optional</span> :: invert, ratio, keep

      <span class="Type">integer</span> :: i, j
      <span class="Type">logical</span> :: inverted
      <span class="Type">character</span>(<span class="Constant">1024</span>) :: tmp

      <span class="Statement">if</span> (<span class="Identifier">present</span>(invert)) <span class="Statement">then</span>
         inverted <span class="Statement">=</span> invert
      <span class="Statement">else</span>
         inverted <span class="Statement">=</span> <span class="Constant">.false.</span>
      <span class="Statement">end if</span>

      sub <span class="Statement">=</span> <span class="Constant">''</span>

      i <span class="Statement">=</span> <span class="Constant">1</span>
      <span class="Statement">do</span>
         <span class="Statement">if</span> (i <span class="Statement">.gt.</span> <span class="Identifier">len</span>(string)) <span class="Statement">exit</span>

         <span class="Statement">if</span> (inverted) <span class="Statement">then</span>
            j <span class="Statement">=</span> <span class="Identifier">verify</span>(string(i:), set)
         <span class="Statement">else</span>
            j <span class="Statement">=</span> <span class="Identifier">scan</span>(string(i:), set)
         <span class="Statement">end if</span>

         <span class="Statement">if</span> (j <span class="Statement">.eq.</span> <span class="Constant">0</span>) <span class="Statement">then</span>
            j <span class="Statement">=</span> <span class="Identifier">len</span>(string) <span class="Statement">+</span> <span class="Constant">1</span>
         <span class="Statement">else</span>
            j <span class="Statement">=</span> i <span class="Statement">+</span> j <span class="Statement">-</span> <span class="Constant">1</span>
         <span class="Statement">end if</span>

         sub <span class="Statement">=</span> sub <span class="Statement">//</span> string(i:j <span class="Statement">-</span> <span class="Constant">1</span>)

         <span class="Statement">if</span> (j <span class="Statement">.gt.</span> <span class="Identifier">len</span>(string)) <span class="Statement">exit</span>

         <span class="Statement">if</span> (inverted) <span class="Statement">then</span>
            i <span class="Statement">=</span> <span class="Identifier">scan</span>(string(j:), set)
         <span class="Statement">else</span>
            i <span class="Statement">=</span> <span class="Identifier">verify</span>(string(j:), set)
         <span class="Statement">end if</span>

         <span class="Statement">if</span> (i <span class="Statement">.eq.</span> <span class="Constant">0</span>) <span class="Statement">then</span>
            i <span class="Statement">=</span> <span class="Identifier">len</span>(string) <span class="Statement">+</span> <span class="Constant">1</span>
         <span class="Statement">else</span>
            i <span class="Statement">=</span> j <span class="Statement">+</span> i <span class="Statement">-</span> <span class="Constant">1</span>
         <span class="Statement">end if</span>

         <span class="Statement">if</span> (<span class="Identifier">present</span>(before)) <span class="Statement">then</span>
            <span class="Statement">if</span> (j <span class="Statement">.gt.</span> <span class="Constant">1</span>) <span class="Statement">then</span>
               <span class="Statement">if</span> (<span class="Identifier">index</span>(before, string(j <span class="Statement">-</span> <span class="Constant">1</span>:j <span class="Statement">-</span> <span class="Constant">1</span>)) <span class="Statement">.eq.</span> <span class="Constant">0</span>) <span class="Statement">then</span>
                  sub <span class="Statement">=</span> sub <span class="Statement">//</span> string(j:i <span class="Statement">-</span> <span class="Constant">1</span>)
                  <span class="Statement">cycle</span>
               <span class="Statement">end if</span>
            <span class="Statement">end if</span>
         <span class="Statement">end if</span>

         <span class="Statement">if</span> (<span class="Identifier">present</span>(insert)) sub <span class="Statement">=</span> sub <span class="Statement">//</span> insert

         <span class="Statement">if</span> (<span class="Identifier">present</span>(ratio)) <span class="Statement">then</span>
            <span class="Statement">if</span> (ratio) <span class="Statement">then</span>
               <span class="Statement">write</span> (tmp, <span class="Constant">&quot;(I0, ':', I0)&quot;</span>) i <span class="Statement">-</span> j, beats
               sub <span class="Statement">=</span> sub <span class="Statement">//</span> <span class="Identifier">trim</span>(tmp)
            <span class="Statement">end if</span>
         <span class="Statement">end if</span>

         <span class="Statement">if</span> (<span class="Identifier">present</span>(keep)) <span class="Statement">then</span>
            <span class="Statement">if</span> (keep) sub <span class="Statement">=</span> sub <span class="Statement">//</span> string(j:i <span class="Statement">-</span> <span class="Constant">1</span>)
         <span class="Statement">end if</span>

         <span class="Statement">if</span> (<span class="Identifier">present</span>(replace)) <span class="Statement">then</span>
            sub <span class="Statement">=</span> sub <span class="Statement">//</span> <span class="Identifier">repeat</span>(replace, i <span class="Statement">-</span> j)
         <span class="Statement">end if</span>
      <span class="Statement">end do</span>
   <span class="PreProc">end function</span> sub
<span class="PreProc">end module</span> tab
</pre>
<h2>tag.f90</h2>
<pre id='vimCodeElement'>
<span class="PreProc">subroutine</span> tag
   <span class="PreProc">use</span> constants, <span class="PreProc">only</span>: audio, dp
   <span class="PreProc">use</span> id3, <span class="PreProc">only</span>: write_id3
   <span class="PreProc">use</span> io, <span class="PreProc">only</span>: command_argument
   <span class="PreProc">use</span> paths, <span class="PreProc">only</span>: stem
   <span class="PreProc">use</span> riff, <span class="PreProc">only</span>: read_riff, write_riff
   <span class="Type">implicit</span> <span class="Type">none</span>

   <span class="Type">integer</span> :: i
   <span class="Type">character</span>(:), <span class="Type">allocatable</span> :: infile, datafile, outfile
   <span class="Type">type</span>(audio) :: s

   infile <span class="Statement">=</span> command_argument(<span class="Constant">1</span>, <span class="Constant">'/dev/stdin'</span>)

   datafile <span class="Statement">=</span> command_argument(<span class="Constant">2</span>, <span class="Constant">'-'</span>)

   <span class="Statement">if</span> (datafile <span class="Statement">.eq.</span> <span class="Constant">'-'</span>) datafile <span class="Statement">=</span> stem(infile) <span class="Statement">//</span> <span class="Constant">'.id3'</span>

   outfile <span class="Statement">=</span> command_argument(<span class="Constant">3</span>, <span class="Constant">'-'</span>)

   <span class="Statement">if</span> (outfile <span class="Statement">.eq.</span> <span class="Constant">'-'</span>) <span class="Statement">then</span>
      i <span class="Statement">=</span> <span class="Identifier">index</span>(infile, <span class="Constant">'stdin'</span>, back<span class="Statement">=</span><span class="Constant">.true.</span>)

      <span class="Statement">if</span> (i <span class="Statement">.ne.</span> <span class="Constant">0</span>) <span class="Statement">then</span>
         outfile <span class="Statement">=</span> infile(:i <span class="Statement">-</span> <span class="Constant">1</span>) <span class="Statement">//</span> <span class="Constant">'stdout'</span> <span class="Statement">//</span> infile(i <span class="Statement">+</span> <span class="Constant">6</span>:)
      <span class="Statement">else</span>
         outfile <span class="Statement">=</span> infile
      <span class="Statement">end if</span>
   <span class="Statement">end if</span>

   <span class="Identifier">call</span> read_riff(infile, s)

   s%meta <span class="Statement">=</span> write_id3(datafile)

   <span class="Statement">if</span> (<span class="Identifier">len</span>(s%meta) <span class="Statement">.eq.</span> <span class="Constant">0</span>) <span class="Statement">deallocate</span>(s%meta)

   s%amplitude <span class="Statement">=</span> <span class="Constant">1.0_dp</span>

   <span class="Identifier">call</span> write_riff(outfile, s)
<span class="PreProc">end subroutine</span> tag
</pre>
<h2>trim.f90</h2>
<pre id='vimCodeElement'>
<span class="PreProc">subroutine</span> trimz
   <span class="PreProc">use</span> constants, <span class="PreProc">only</span>: audio, dp, i2max
   <span class="PreProc">use</span> io, <span class="PreProc">only</span>: command_argument
   <span class="PreProc">use</span> rationals, <span class="PreProc">only</span>: rational
   <span class="PreProc">use</span> riff, <span class="PreProc">only</span>: read_riff, write_riff
   <span class="Type">implicit</span> <span class="Type">none</span>

   <span class="Type">integer</span> :: a, i, z
   <span class="Identifier">real</span>(dp) :: threshold
   <span class="Type">type</span>(audio) :: s0, s

   threshold <span class="Statement">=</span> rational(command_argument(<span class="Constant">1</span>, <span class="Constant">'0'</span>)) <span class="Statement">*</span> i2max

   <span class="Identifier">call</span> read_riff(command_argument(<span class="Constant">2</span>, <span class="Constant">'/dev/stdin'</span>), s0)

   <span class="Statement">do</span> i <span class="Statement">=</span> <span class="Constant">1</span>, s0%points
      a <span class="Statement">=</span> i
      <span class="Statement">if</span> (<span class="Identifier">any</span>(s0%sound(:, a) <span class="Statement">.gt.</span> threshold)) <span class="Statement">exit</span>
   <span class="Statement">end do</span>

   <span class="Statement">do</span> i <span class="Statement">=</span> s0%points, a <span class="Statement">-</span> <span class="Constant">1</span>, <span class="Statement">-</span><span class="Constant">1</span>
      z <span class="Statement">=</span> i
      <span class="Statement">if</span> (<span class="Identifier">any</span>(s0%sound(:, z) <span class="Statement">.gt.</span> threshold)) <span class="Statement">exit</span>
   <span class="Statement">end do</span>

   s%channels <span class="Statement">=</span> s0%channels
   s%points <span class="Statement">=</span> z <span class="Statement">-</span> a <span class="Statement">+</span> <span class="Constant">1</span>
   s%rate <span class="Statement">=</span> s0%rate
   s%amplitude <span class="Statement">=</span> s0%amplitude
   s%sound <span class="Statement">=</span> s0%sound(:, a:z)

   <span class="Identifier">call</span> write_riff(command_argument(<span class="Constant">3</span>, <span class="Constant">'/dev/stdout'</span>), s)
<span class="PreProc">end subroutine</span> trimz
</pre>
<h2>tz.f90</h2>
<pre id='vimCodeElement'>
<span class="PreProc">program</span> tz
   <span class="PreProc">use</span> io, <span class="PreProc">only</span>: command_argument
   <span class="Type">implicit</span> <span class="Type">none</span>

   <span class="Type">external</span> :: aiff2riff, guitar, harmonics, inspect, mel, mono, repeatz, <span class="Special">&amp;</span>
      riff2aiff, stack, stick, stretch, tag, trimz

   <span class="Type">character</span>(:), <span class="Type">allocatable</span> :: command

   command <span class="Statement">=</span> command_argument(<span class="Constant">0</span>, <span class="Constant">'help'</span>)

   <span class="Statement">select case</span> (command)
   <span class="Statement">case</span> (<span class="Constant">'mel'</span>); <span class="Identifier">call</span> mel
   <span class="Statement">case</span> (<span class="Constant">'guitar'</span>); <span class="Identifier">call</span> guitar
   <span class="Statement">case</span> (<span class="Constant">'stick'</span>); <span class="Identifier">call</span> stick
   <span class="Statement">case</span> (<span class="Constant">'stack'</span>); <span class="Identifier">call</span> stack
   <span class="Statement">case</span> (<span class="Constant">'stretch'</span>); <span class="Identifier">call</span> stretch
   <span class="Statement">case</span> (<span class="Constant">'repeat'</span>); <span class="Identifier">call</span> repeatz
   <span class="Statement">case</span> (<span class="Constant">'trim'</span>); <span class="Identifier">call</span> trimz
   <span class="Statement">case</span> (<span class="Constant">'mono'</span>); <span class="Identifier">call</span> mono
   <span class="Statement">case</span> (<span class="Constant">'harmonics'</span>); <span class="Identifier">call</span> harmonics
   <span class="Statement">case</span> (<span class="Constant">'inspect'</span>); <span class="Identifier">call</span> inspect
   <span class="Statement">case</span> (<span class="Constant">'riff2aiff'</span>); <span class="Identifier">call</span> riff2aiff
   <span class="Statement">case</span> (<span class="Constant">'aiff2riff'</span>); <span class="Identifier">call</span> aiff2riff
   <span class="Statement">case</span> (<span class="Constant">'tag'</span>); <span class="Identifier">call</span> tag
   <span class="Statement">case</span> (<span class="Constant">'help'</span>); <span class="Identifier">call</span> help
   <span class="Statement">case</span> <span class="Statement">default</span>
      <span class="Statement">write</span> (<span class="Statement">*</span>, <span class="Constant">&quot;('Unknown command &quot;&quot;', A, '&quot;&quot;', /)&quot;</span>) command
      <span class="Identifier">call</span> help
   <span class="Statement">end select</span>

<span class="PreProc">contains</span>

   <span class="PreProc">subroutine</span> help
      <span class="Statement">write</span> (<span class="Statement">*</span>, <span class="Constant">&quot;(A, /, *(:, /, '    tz ', A))&quot;</span>) <span class="Special">&amp;</span>
         <span class="Constant">'Tonbandfetzen usage:'</span>, <span class="Special">&amp;</span>
         <span class="Constant">'mel [[[wavefile ...] infile] outfile]'</span>, <span class="Special">&amp;</span>
         <span class="Constant">'guitar [infile [outfile]]'</span>, <span class="Special">&amp;</span>
         <span class="Constant">'stick [[infile ...] outfile]'</span>, <span class="Special">&amp;</span>
         <span class="Constant">'stack [[infile ...] outfile]'</span>, <span class="Special">&amp;</span>
         <span class="Constant">'stretch [factor [infile [outfile]]]'</span>, <span class="Special">&amp;</span>
         <span class="Constant">'repeat [count [infile [outfile]]]'</span>, <span class="Special">&amp;</span>
         <span class="Constant">'trim [threshold [infile [outfile]]]'</span>, <span class="Special">&amp;</span>
         <span class="Constant">'mono [infile [outfile ...]]'</span>, <span class="Special">&amp;</span>
         <span class="Constant">'harmonics [label]'</span>, <span class="Special">&amp;</span>
         <span class="Constant">'inspect [file]'</span>, <span class="Special">&amp;</span>
         <span class="Constant">'riff2aiff [[infile] outfile]'</span>, <span class="Special">&amp;</span>
         <span class="Constant">'aiff2riff [[infile] outfile]'</span>, <span class="Special">&amp;</span>
         <span class="Constant">'tag [infile [datafile [outfile]]]'</span>
   <span class="PreProc">end subroutine</span> help
<span class="PreProc">end program</span> tz
</pre>
</body></html>
