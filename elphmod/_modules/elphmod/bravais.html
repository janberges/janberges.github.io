

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>elphmod.bravais &mdash; elphmod  documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../_static/style.css?v=1f476fd3" />

  
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../_static/documentation_options.js?v=5929fcd5"></script>
      <script src="../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: #e7f2fa" >

          
          
          <a href="../../index.html">
            
              <img src="../../_static/elphmod.svg" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Modules</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../modules/el.html">Electron</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules/ph.html">Phonon</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules/elph.html">Electron–phonon</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules/elel.html">Electron–electron</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules/MPI.html">MPI</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules/bravais.html">Bravais</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules/dispersion.html">Dispersion</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules/dos.html">DOS</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules/diagrams.html">Diagrams</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules/occupations.html">Occupations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules/md.html">MD</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules/eliashberg.html">Eliashberg</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules/plot.html">Plot</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules/misc.html">Miscellaneous</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Models</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../modules/models/graphene.html">Graphene</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules/models/tas2.html">TaS₂</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules/models/chain.html">Chain</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">More</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../pages/changelog.html">Changelog</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../pages/patches.html">Patches</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../genindex.html">Index</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../search.html">Search Page</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu"  style="background: #e7f2fa" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">elphmod</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">elphmod.bravais</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for elphmod.bravais</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright (C) 2017-2025 elphmod Developers</span>
<span class="c1"># This program is free software under the terms of the GNU GPLv3 or later.</span>

<span class="sd">&quot;&quot;&quot;Lattices, symmetries, and interpolation.&quot;&quot;&quot;</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">elphmod.misc</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">elphmod.MPI</span>

<span class="n">comm</span> <span class="o">=</span> <span class="n">elphmod</span><span class="o">.</span><span class="n">MPI</span><span class="o">.</span><span class="n">comm</span>
<span class="n">info</span> <span class="o">=</span> <span class="n">elphmod</span><span class="o">.</span><span class="n">MPI</span><span class="o">.</span><span class="n">info</span>

<span class="n">deg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">180</span>

<div class="viewcode-block" id="rotate">
<a class="viewcode-back" href="../../modules/bravais.html#elphmod.bravais.rotate">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">rotate</span><span class="p">(</span><span class="n">vector</span><span class="p">,</span> <span class="n">angle</span><span class="p">,</span> <span class="n">two_dimensional</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Rotate vector anti-clockwise.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    vector : array_like</span>
<span class="sd">        Two-dimensional vector.</span>
<span class="sd">    angle : float</span>
<span class="sd">        Rotation angle in radians.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ndarray</span>
<span class="sd">        Rotated vector.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">cos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span>
    <span class="n">sin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">two_dimensional</span><span class="p">:</span>
        <span class="n">rotation</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
            <span class="p">[</span><span class="n">cos</span><span class="p">,</span> <span class="o">-</span><span class="n">sin</span><span class="p">],</span>
            <span class="p">[</span><span class="n">sin</span><span class="p">,</span>  <span class="n">cos</span><span class="p">],</span>
            <span class="p">])</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">rotation</span><span class="p">,</span> <span class="n">vector</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">rotation</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
            <span class="p">[</span><span class="n">cos</span><span class="p">,</span> <span class="o">-</span><span class="n">sin</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>
            <span class="p">[</span><span class="n">sin</span><span class="p">,</span>  <span class="n">cos</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>
            <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span>  <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">],</span>
            <span class="p">])</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">rotation</span><span class="p">,</span> <span class="n">vector</span><span class="p">)</span></div>


<div class="viewcode-block" id="primitives">
<a class="viewcode-back" href="../../modules/bravais.html#elphmod.bravais.primitives">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">primitives</span><span class="p">(</span><span class="n">ibrav</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">cosbc</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">cosac</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">cosab</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
        <span class="n">celldm</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">bohr</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">r_cell</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cell_units</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">ignore</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Get primitive vectors of Bravais lattice as in QE.</span>

<span class="sd">    Adapted from Modules/latgen.f90 of Quantum ESPRESSO.</span>

<span class="sd">    For documentation, see http://www.quantum-espresso.org/Doc/INPUT_PW.html.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ibrav : int</span>
<span class="sd">        Bravais-lattice index.</span>
<span class="sd">    a, b, c, cosbc, cosac, cosab : float</span>
<span class="sd">        Traditional crystallographic constants in angstrom.</span>
<span class="sd">    celldm : list of float</span>
<span class="sd">        Alternative crystallographic constants. The first element is the</span>
<span class="sd">        lattice constant in bohr; the other elements are dimensionless.</span>
<span class="sd">    bohr : bool, default False</span>
<span class="sd">        Return lattice vectors in angstrom or bohr?</span>
<span class="sd">    r_cell, cell_units</span>
<span class="sd">        Cell parameters from &#39;func&#39;`read_pwi` used if `ibrav` is zero.</span>
<span class="sd">    **ignore</span>
<span class="sd">        Ignored keyword arguments, e.g., parameters from &#39;func&#39;`read_pwi`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ndarray</span>
<span class="sd">        Matrix of primitive Bravais lattice vectors.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">celldm</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">celldm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>

        <span class="n">celldm</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span> <span class="o">/</span> <span class="n">elphmod</span><span class="o">.</span><span class="n">misc</span><span class="o">.</span><span class="n">a0</span>
        <span class="n">celldm</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span> <span class="o">/</span> <span class="n">a</span>
        <span class="n">celldm</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span> <span class="o">/</span> <span class="n">a</span>

        <span class="k">if</span> <span class="n">ibrav</span> <span class="ow">in</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">14</span><span class="p">}:</span>
            <span class="n">celldm</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">cosbc</span>
            <span class="n">celldm</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">cosac</span>
            <span class="n">celldm</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="n">cosab</span>

        <span class="k">elif</span> <span class="n">ibrav</span> <span class="ow">in</span> <span class="p">{</span><span class="o">-</span><span class="mi">13</span><span class="p">,</span> <span class="o">-</span><span class="mi">12</span><span class="p">}:</span>
            <span class="n">celldm</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">cosac</span>

        <span class="k">elif</span> <span class="n">ibrav</span> <span class="ow">in</span> <span class="p">{</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">13</span><span class="p">}:</span>
            <span class="n">celldm</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">cosab</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">bohr</span><span class="p">:</span>
        <span class="n">celldm</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*=</span> <span class="n">elphmod</span><span class="o">.</span><span class="n">misc</span><span class="o">.</span><span class="n">a0</span>

    <span class="k">if</span> <span class="n">ibrav</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="c1"># free</span>
        <span class="k">if</span> <span class="n">r_cell</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">cell_units</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">info</span><span class="p">(</span><span class="s1">&#39;ibrav=0 requires r_cell and cell_units!&#39;</span><span class="p">,</span> <span class="n">error</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">r_cell</span><span class="p">)</span>

        <span class="k">if</span> <span class="s1">&#39;alat&#39;</span> <span class="ow">in</span> <span class="n">cell_units</span><span class="o">.</span><span class="n">lower</span><span class="p">():</span>
            <span class="n">a</span> <span class="o">*=</span> <span class="n">celldm</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">bohr</span> <span class="ow">and</span> <span class="s1">&#39;angstrom&#39;</span> <span class="ow">in</span> <span class="n">cell_units</span><span class="o">.</span><span class="n">lower</span><span class="p">():</span>
            <span class="n">a</span> <span class="o">/=</span> <span class="n">elphmod</span><span class="o">.</span><span class="n">misc</span><span class="o">.</span><span class="n">a0</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">bohr</span> <span class="ow">and</span> <span class="s1">&#39;bohr&#39;</span> <span class="ow">in</span> <span class="n">cell_units</span><span class="o">.</span><span class="n">lower</span><span class="p">():</span>
            <span class="n">a</span> <span class="o">*=</span> <span class="n">elphmod</span><span class="o">.</span><span class="n">misc</span><span class="o">.</span><span class="n">a0</span>

        <span class="k">return</span> <span class="n">a</span>

    <span class="k">if</span> <span class="n">ibrav</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span class="c1"># cubic (sc)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">*</span> <span class="n">celldm</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">ibrav</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span> <span class="c1"># cubic (fcc)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
            <span class="p">[</span><span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">],</span>
            <span class="p">[</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">],</span>
            <span class="p">[</span><span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>
            <span class="p">])</span> <span class="o">*</span> <span class="n">celldm</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span>

    <span class="k">if</span> <span class="n">ibrav</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span> <span class="c1"># cubic (bcc)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
            <span class="p">[</span> <span class="mf">1.0</span><span class="p">,</span>  <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">],</span>
            <span class="p">[</span><span class="o">-</span><span class="mf">1.0</span><span class="p">,</span>  <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">],</span>
            <span class="p">[</span><span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">],</span>
            <span class="p">])</span> <span class="o">*</span> <span class="n">celldm</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span>

    <span class="k">if</span> <span class="n">ibrav</span> <span class="o">==</span> <span class="o">-</span><span class="mi">3</span><span class="p">:</span> <span class="c1"># cubic (bcc, more symmetric axis)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
            <span class="p">[</span><span class="o">-</span><span class="mf">1.0</span><span class="p">,</span>  <span class="mf">1.0</span><span class="p">,</span>  <span class="mf">1.0</span><span class="p">],</span>
            <span class="p">[</span> <span class="mf">1.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">,</span>  <span class="mf">1.0</span><span class="p">],</span>
            <span class="p">[</span> <span class="mf">1.0</span><span class="p">,</span>  <span class="mf">1.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">],</span>
            <span class="p">])</span> <span class="o">*</span> <span class="n">celldm</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span>

    <span class="k">if</span> <span class="n">ibrav</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span> <span class="c1"># hexagonal &amp; trigonal</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
            <span class="p">[</span> <span class="mf">1.0</span><span class="p">,</span>              <span class="mf">0.0</span><span class="p">,</span>       <span class="mf">0.0</span><span class="p">],</span>
            <span class="p">[</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span>       <span class="mf">0.0</span><span class="p">],</span>
            <span class="p">[</span> <span class="mf">0.0</span><span class="p">,</span>              <span class="mf">0.0</span><span class="p">,</span> <span class="n">celldm</span><span class="p">[</span><span class="mi">2</span><span class="p">]],</span>
            <span class="p">])</span> <span class="o">*</span> <span class="n">celldm</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">ibrav</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span> <span class="c1"># trigonal (3-fold axis c)</span>
        <span class="n">tx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="mi">1</span> <span class="o">-</span> <span class="n">celldm</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">ty</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="mi">1</span> <span class="o">-</span> <span class="n">celldm</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span> <span class="o">/</span> <span class="mi">6</span><span class="p">)</span>
        <span class="n">tz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">celldm</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span> <span class="o">/</span> <span class="mi">3</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
            <span class="p">[</span> <span class="n">tx</span><span class="p">,</span>    <span class="o">-</span><span class="n">ty</span><span class="p">,</span> <span class="n">tz</span><span class="p">],</span>
            <span class="p">[</span>  <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">ty</span><span class="p">,</span> <span class="n">tz</span><span class="p">],</span>
            <span class="p">[</span><span class="o">-</span><span class="n">tx</span><span class="p">,</span>    <span class="o">-</span><span class="n">ty</span><span class="p">,</span> <span class="n">tz</span><span class="p">],</span>
            <span class="p">])</span> <span class="o">*</span> <span class="n">celldm</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">ibrav</span> <span class="o">==</span> <span class="o">-</span><span class="mi">5</span><span class="p">:</span> <span class="c1"># trigonal (3-fold axis &lt;111&gt;)</span>
        <span class="n">tx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="mi">1</span> <span class="o">-</span> <span class="n">celldm</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">ty</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="mi">1</span> <span class="o">-</span> <span class="n">celldm</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span> <span class="o">/</span> <span class="mi">6</span><span class="p">)</span>
        <span class="n">tz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">celldm</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span> <span class="o">/</span> <span class="mi">3</span><span class="p">)</span>

        <span class="n">u</span> <span class="o">=</span> <span class="n">tz</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">ty</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">tz</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">ty</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
            <span class="p">[</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">v</span><span class="p">],</span>
            <span class="p">[</span><span class="n">v</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">],</span>
            <span class="p">[</span><span class="n">v</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">u</span><span class="p">],</span>
            <span class="p">])</span> <span class="o">*</span> <span class="n">celldm</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">ibrav</span> <span class="o">==</span> <span class="mi">6</span><span class="p">:</span> <span class="c1"># tetragonal (st)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
            <span class="p">[</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span>       <span class="mf">0.0</span><span class="p">],</span>
            <span class="p">[</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span>       <span class="mf">0.0</span><span class="p">],</span>
            <span class="p">[</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">celldm</span><span class="p">[</span><span class="mi">2</span><span class="p">]],</span>
            <span class="p">])</span> <span class="o">*</span> <span class="n">celldm</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">ibrav</span> <span class="o">==</span> <span class="mi">7</span><span class="p">:</span> <span class="c1"># tetragonal (bct)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
            <span class="p">[</span> <span class="mf">1.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">celldm</span><span class="p">[</span><span class="mi">2</span><span class="p">]],</span>
            <span class="p">[</span> <span class="mf">1.0</span><span class="p">,</span>  <span class="mf">1.0</span><span class="p">,</span> <span class="n">celldm</span><span class="p">[</span><span class="mi">2</span><span class="p">]],</span>
            <span class="p">[</span><span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">celldm</span><span class="p">[</span><span class="mi">2</span><span class="p">]],</span>
            <span class="p">])</span> <span class="o">*</span> <span class="n">celldm</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span>

    <span class="k">if</span> <span class="n">ibrav</span> <span class="o">==</span> <span class="mi">8</span><span class="p">:</span> <span class="c1"># orthorhombic</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">celldm</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">celldm</span><span class="p">[</span><span class="mi">2</span><span class="p">]])</span> <span class="o">*</span> <span class="n">celldm</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">ibrav</span> <span class="o">==</span> <span class="mi">9</span><span class="p">:</span> <span class="c1"># orthorhombic (bco)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
            <span class="p">[</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">celldm</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>       <span class="mf">0.0</span><span class="p">],</span>
            <span class="p">[</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">celldm</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>       <span class="mf">0.0</span><span class="p">],</span>
            <span class="p">[</span> <span class="mf">0.0</span><span class="p">,</span>             <span class="mf">0.0</span><span class="p">,</span> <span class="n">celldm</span><span class="p">[</span><span class="mi">2</span><span class="p">]],</span>
            <span class="p">])</span> <span class="o">*</span> <span class="n">celldm</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">ibrav</span> <span class="o">==</span> <span class="o">-</span><span class="mi">9</span><span class="p">:</span> <span class="c1"># orthorhombic (bco, alternate description)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
            <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">celldm</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>       <span class="mf">0.0</span><span class="p">],</span>
            <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span>  <span class="mf">0.5</span> <span class="o">*</span> <span class="n">celldm</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>       <span class="mf">0.0</span><span class="p">],</span>
            <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span>              <span class="mf">0.0</span><span class="p">,</span> <span class="n">celldm</span><span class="p">[</span><span class="mi">2</span><span class="p">]],</span>
            <span class="p">])</span> <span class="o">*</span> <span class="n">celldm</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">ibrav</span> <span class="o">==</span> <span class="mi">91</span><span class="p">:</span> <span class="c1"># orthorhombic (A-type)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
            <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span>             <span class="mf">0.0</span><span class="p">,</span>              <span class="mf">0.0</span><span class="p">],</span>
            <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">celldm</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">-</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">celldm</span><span class="p">[</span><span class="mi">2</span><span class="p">]],</span>
            <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">celldm</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>  <span class="mf">0.5</span> <span class="o">*</span> <span class="n">celldm</span><span class="p">[</span><span class="mi">2</span><span class="p">]],</span>
            <span class="p">])</span> <span class="o">*</span> <span class="n">celldm</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">ibrav</span> <span class="o">==</span> <span class="mi">10</span><span class="p">:</span> <span class="c1"># orthorhombic (fco)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
            <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span>       <span class="mf">0.0</span><span class="p">,</span> <span class="n">celldm</span><span class="p">[</span><span class="mi">2</span><span class="p">]],</span>
            <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">celldm</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>       <span class="mf">0.0</span><span class="p">],</span>
            <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">celldm</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">celldm</span><span class="p">[</span><span class="mi">2</span><span class="p">]],</span>
            <span class="p">])</span> <span class="o">*</span> <span class="n">celldm</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span>

    <span class="k">if</span> <span class="n">ibrav</span> <span class="o">==</span> <span class="mi">11</span><span class="p">:</span> <span class="c1"># orthorhombic (bco)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
            <span class="p">[</span> <span class="mf">1.0</span><span class="p">,</span>  <span class="n">celldm</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">celldm</span><span class="p">[</span><span class="mi">2</span><span class="p">]],</span>
            <span class="p">[</span><span class="o">-</span><span class="mf">1.0</span><span class="p">,</span>  <span class="n">celldm</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">celldm</span><span class="p">[</span><span class="mi">2</span><span class="p">]],</span>
            <span class="p">[</span><span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="o">-</span><span class="n">celldm</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">celldm</span><span class="p">[</span><span class="mi">2</span><span class="p">]],</span>
            <span class="p">])</span> <span class="o">*</span> <span class="n">celldm</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span>

    <span class="k">if</span> <span class="n">ibrav</span> <span class="o">==</span> <span class="mi">12</span><span class="p">:</span> <span class="c1"># monoclinic (unique axis c)</span>
        <span class="n">cos</span> <span class="o">=</span> <span class="n">celldm</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
        <span class="n">sin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">cos</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
            <span class="p">[</span>            <span class="mf">1.0</span><span class="p">,</span>             <span class="mf">0.0</span><span class="p">,</span>       <span class="mf">0.0</span><span class="p">],</span>
            <span class="p">[</span><span class="n">celldm</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">cos</span><span class="p">,</span> <span class="n">celldm</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">sin</span><span class="p">,</span>       <span class="mf">0.0</span><span class="p">],</span>
            <span class="p">[</span>            <span class="mf">0.0</span><span class="p">,</span>             <span class="mf">0.0</span><span class="p">,</span> <span class="n">celldm</span><span class="p">[</span><span class="mi">2</span><span class="p">]],</span>
            <span class="p">])</span> <span class="o">*</span> <span class="n">celldm</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">ibrav</span> <span class="o">==</span> <span class="o">-</span><span class="mi">12</span><span class="p">:</span> <span class="c1"># monoclinic (unique axis b)</span>
        <span class="n">cos</span> <span class="o">=</span> <span class="n">celldm</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
        <span class="n">sin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">cos</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
            <span class="p">[</span>            <span class="mf">1.0</span><span class="p">,</span>       <span class="mf">0.0</span><span class="p">,</span>             <span class="mf">0.0</span><span class="p">],</span>
            <span class="p">[</span>            <span class="mf">0.0</span><span class="p">,</span> <span class="n">celldm</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>             <span class="mf">0.0</span><span class="p">],</span>
            <span class="p">[</span><span class="n">celldm</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">cos</span><span class="p">,</span>       <span class="mf">0.0</span><span class="p">,</span> <span class="n">celldm</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">sin</span><span class="p">],</span>
            <span class="p">])</span> <span class="o">*</span> <span class="n">celldm</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">ibrav</span> <span class="o">==</span> <span class="mi">13</span><span class="p">:</span> <span class="c1"># monoclinic (bcm, unique axis c)</span>
        <span class="n">cos</span> <span class="o">=</span> <span class="n">celldm</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
        <span class="n">sin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">cos</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
            <span class="p">[</span>            <span class="mf">0.5</span><span class="p">,</span>             <span class="mf">0.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">celldm</span><span class="p">[</span><span class="mi">2</span><span class="p">]],</span>
            <span class="p">[</span><span class="n">celldm</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">cos</span><span class="p">,</span> <span class="n">celldm</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">sin</span><span class="p">,</span>              <span class="mf">0.0</span><span class="p">],</span>
            <span class="p">[</span>            <span class="mf">0.5</span><span class="p">,</span>             <span class="mf">0.0</span><span class="p">,</span>  <span class="mf">0.5</span> <span class="o">*</span> <span class="n">celldm</span><span class="p">[</span><span class="mi">2</span><span class="p">]],</span>
            <span class="p">])</span> <span class="o">*</span> <span class="n">celldm</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">ibrav</span> <span class="o">==</span> <span class="o">-</span><span class="mi">13</span><span class="p">:</span> <span class="c1"># monoclinic (bcm, unique axis b)</span>
        <span class="n">cos</span> <span class="o">=</span> <span class="n">celldm</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
        <span class="n">sin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">cos</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
            <span class="p">[</span>            <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">celldm</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>             <span class="mf">0.0</span><span class="p">],</span>
            <span class="p">[</span>           <span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">celldm</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>             <span class="mf">0.0</span><span class="p">],</span>
            <span class="p">[</span><span class="n">celldm</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">cos</span><span class="p">,</span>             <span class="mf">0.0</span><span class="p">,</span> <span class="n">celldm</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">sin</span><span class="p">],</span>
            <span class="p">])</span> <span class="o">*</span> <span class="n">celldm</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">ibrav</span> <span class="o">==</span> <span class="mi">14</span><span class="p">:</span> <span class="c1"># triclinic</span>
        <span class="n">cosc</span> <span class="o">=</span> <span class="n">celldm</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span>
        <span class="n">sinc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">cosc</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>

        <span class="n">cosa</span> <span class="o">=</span> <span class="n">celldm</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
        <span class="n">cosb</span> <span class="o">=</span> <span class="n">celldm</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>

        <span class="n">ex1</span> <span class="o">=</span> <span class="p">(</span><span class="n">cosa</span> <span class="o">-</span> <span class="n">cosb</span> <span class="o">*</span> <span class="n">cosc</span><span class="p">)</span> <span class="o">/</span> <span class="n">sinc</span>
        <span class="n">ex2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">cosa</span> <span class="o">*</span> <span class="n">cosb</span> <span class="o">*</span> <span class="n">cosc</span>
            <span class="o">-</span> <span class="n">cosa</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">cosb</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">cosc</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">sinc</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
            <span class="p">[</span>             <span class="mf">1.0</span><span class="p">,</span>              <span class="mf">0.0</span><span class="p">,</span>            <span class="mf">0.0</span><span class="p">],</span>
            <span class="p">[</span><span class="n">celldm</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">cosc</span><span class="p">,</span> <span class="n">celldm</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">sinc</span><span class="p">,</span>            <span class="mf">0.0</span><span class="p">],</span>
            <span class="p">[</span><span class="n">celldm</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">cosb</span><span class="p">,</span> <span class="n">celldm</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">ex1</span><span class="p">,</span> <span class="n">celldm</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">ex2</span><span class="p">],</span>
            <span class="p">])</span> <span class="o">*</span> <span class="n">celldm</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">info</span><span class="p">(</span><span class="s1">&#39;Bravais lattice </span><span class="si">%s</span><span class="s1"> unknown!&#39;</span> <span class="o">%</span> <span class="n">ibrav</span><span class="p">,</span> <span class="n">error</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>


<div class="viewcode-block" id="translations">
<a class="viewcode-back" href="../../modules/bravais.html#elphmod.bravais.translations">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">translations</span><span class="p">(</span><span class="n">angle</span><span class="o">=</span><span class="mi">120</span><span class="p">,</span> <span class="n">angle0</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">two_dimensional</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generate translation vectors of Bravais lattice.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    angle : float</span>
<span class="sd">        Angle between first and second vector in degrees::</span>

<span class="sd">            VALUE  LATTICE</span>
<span class="sd">               60  hexagonal</span>
<span class="sd">               90  square</span>
<span class="sd">              120  hexagonal (ibrav = 4 in Quantum ESPRESSO)</span>

<span class="sd">    angle0 : float</span>
<span class="sd">        Angle between x axis and first vector in degrees.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ndarray, ndarray</span>
<span class="sd">        Translation vectors of Bravais lattice.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">two_dimensional</span><span class="p">:</span>
        <span class="n">a1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">])</span>

        <span class="n">a1</span> <span class="o">=</span> <span class="n">rotate</span><span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">angle0</span> <span class="o">*</span> <span class="n">deg</span><span class="p">)</span>
        <span class="n">a2</span> <span class="o">=</span> <span class="n">rotate</span><span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">angle</span> <span class="o">*</span> <span class="n">deg</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">a1</span><span class="p">,</span> <span class="n">a2</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">a1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">])</span>

        <span class="n">a1</span> <span class="o">=</span> <span class="n">rotate</span><span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">angle0</span> <span class="o">*</span> <span class="n">deg</span><span class="p">,</span> <span class="n">two_dimensional</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">a2</span> <span class="o">=</span> <span class="n">rotate</span><span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">angle</span> <span class="o">*</span> <span class="n">deg</span><span class="p">,</span> <span class="n">two_dimensional</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">a1</span><span class="p">,</span> <span class="n">a2</span></div>


<div class="viewcode-block" id="reciprocals">
<a class="viewcode-back" href="../../modules/bravais.html#elphmod.bravais.reciprocals">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">reciprocals</span><span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">,</span> <span class="n">a3</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Generate translation vectors of reciprocal lattice.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a1, a2 : ndarray</span>
<span class="sd">        Translation vectors of Bravais lattice.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ndarray, ndarray</span>
<span class="sd">        Translation vectors of reciprocal lattice (without :math:`2 \pi`).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">a3</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">b1</span> <span class="o">=</span> <span class="n">rotate</span><span class="p">(</span><span class="n">a2</span><span class="p">,</span> <span class="o">-</span><span class="mi">90</span> <span class="o">*</span> <span class="n">deg</span><span class="p">)</span>
        <span class="n">b2</span> <span class="o">=</span> <span class="n">rotate</span><span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="o">+</span><span class="mi">90</span> <span class="o">*</span> <span class="n">deg</span><span class="p">)</span>

        <span class="n">b1</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">b1</span><span class="p">)</span>
        <span class="n">b2</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">a2</span><span class="p">,</span> <span class="n">b2</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">b1</span><span class="p">,</span> <span class="n">b2</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="n">b1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">a2</span><span class="p">,</span> <span class="n">a3</span><span class="p">)</span>
        <span class="n">b2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">a3</span><span class="p">,</span> <span class="n">a1</span><span class="p">)</span>
        <span class="n">b3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">)</span>

        <span class="n">b1</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">b1</span><span class="p">)</span>
        <span class="n">b2</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">a2</span><span class="p">,</span> <span class="n">b2</span><span class="p">)</span>
        <span class="n">b3</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">a3</span><span class="p">,</span> <span class="n">b3</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">b1</span><span class="p">,</span> <span class="n">b2</span><span class="p">,</span> <span class="n">b3</span></div>


<div class="viewcode-block" id="volume">
<a class="viewcode-back" href="../../modules/bravais.html#elphmod.bravais.volume">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">volume</span><span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">a3</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate unit-cell volume/area/length.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a1, a2, a3 : ndarray</span>
<span class="sd">        Primite lattice vectors.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    float</span>
<span class="sd">        Unit-cell volume/area/length.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">a2</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">a3</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">a1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">a3</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">abs</span><span class="p">(</span><span class="n">a1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">a2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">a1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">a2</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="k">return</span> <span class="nb">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">a2</span><span class="p">,</span> <span class="n">a3</span><span class="p">)))</span></div>


<div class="viewcode-block" id="supercell">
<a class="viewcode-back" href="../../modules/bravais.html#elphmod.bravais.supercell">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">supercell</span><span class="p">(</span><span class="n">N1</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">N2</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">N3</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Set up supercell.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    N1, N2, N3 : tuple of int or int, default 1</span>
<span class="sd">        Supercell lattice vectors in units of primitive lattice vectors.</span>
<span class="sd">        Multiples of single primitive vector can be defined via a scalar</span>
<span class="sd">        integer, linear combinations via a 3-tuple of integers.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    int</span>
<span class="sd">        Number of unit cells in supercell.</span>
<span class="sd">    tuple of ndarray</span>
<span class="sd">        Integer vectors spanning the supercell.</span>
<span class="sd">    tuple of ndarray</span>
<span class="sd">        Integer vectors spanning the reciprocal supercell.</span>
<span class="sd">    list of tuple</span>
<span class="sd">        Integer positions of the unit cells in the supercell.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">N1</span><span class="p">,</span> <span class="s1">&#39;__len__&#39;</span><span class="p">):</span> <span class="n">N1</span> <span class="o">=</span> <span class="p">(</span><span class="n">N1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">N2</span><span class="p">,</span> <span class="s1">&#39;__len__&#39;</span><span class="p">):</span> <span class="n">N2</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">N2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">N3</span><span class="p">,</span> <span class="s1">&#39;__len__&#39;</span><span class="p">):</span> <span class="n">N3</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">N3</span><span class="p">)</span>

    <span class="n">N1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">N1</span><span class="p">)</span>
    <span class="n">N2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">N2</span><span class="p">)</span>
    <span class="n">N3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">N3</span><span class="p">)</span>

    <span class="n">N</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">N1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">N2</span><span class="p">,</span> <span class="n">N3</span><span class="p">))</span>

    <span class="n">B1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">N</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">N2</span><span class="p">,</span> <span class="n">N3</span><span class="p">)</span>
    <span class="n">B2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">N</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">N3</span><span class="p">,</span> <span class="n">N1</span><span class="p">)</span>
    <span class="n">B3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">N</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">N1</span><span class="p">,</span> <span class="n">N2</span><span class="p">)</span>

    <span class="n">N</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>

    <span class="n">cells</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">if</span> <span class="n">comm</span><span class="o">.</span><span class="n">rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">corners</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">n1</span> <span class="o">*</span> <span class="n">N1</span> <span class="o">+</span> <span class="n">n2</span> <span class="o">*</span> <span class="n">N2</span> <span class="o">+</span> <span class="n">n3</span> <span class="o">*</span> <span class="n">N3</span>
            <span class="k">for</span> <span class="n">n1</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">n2</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">n3</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">)])</span>

        <span class="n">n1_lower</span><span class="p">,</span> <span class="n">n2_lower</span><span class="p">,</span> <span class="n">n3_lower</span> <span class="o">=</span> <span class="n">corners</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">n1_upper</span><span class="p">,</span> <span class="n">n2_upper</span><span class="p">,</span> <span class="n">n3_upper</span> <span class="o">=</span> <span class="n">corners</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="k">for</span> <span class="n">n1</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n1_lower</span><span class="p">,</span> <span class="n">n1_upper</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">n2</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n2_lower</span><span class="p">,</span> <span class="n">n2_upper</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">n3</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n3_lower</span><span class="p">,</span> <span class="n">n3_upper</span><span class="p">):</span>
                    <span class="n">R</span> <span class="o">=</span> <span class="p">(</span><span class="n">n1</span><span class="p">,</span> <span class="n">n2</span><span class="p">,</span> <span class="n">n3</span><span class="p">)</span>

                    <span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">B1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">N</span> <span class="ow">and</span>
                        <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">B2</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">N</span> <span class="ow">and</span>
                        <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">B3</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">):</span>

                        <span class="n">cells</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">R</span><span class="p">)</span>

        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">cells</span><span class="p">)</span> <span class="o">==</span> <span class="n">N</span>

    <span class="n">cells</span> <span class="o">=</span> <span class="n">comm</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">cells</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">N</span><span class="p">,</span> <span class="p">(</span><span class="n">N1</span><span class="p">,</span> <span class="n">N2</span><span class="p">,</span> <span class="n">N3</span><span class="p">),</span> <span class="p">(</span><span class="n">B1</span><span class="p">,</span> <span class="n">B2</span><span class="p">,</span> <span class="n">B3</span><span class="p">),</span> <span class="n">cells</span></div>


<div class="viewcode-block" id="to_supercell">
<a class="viewcode-back" href="../../modules/bravais.html#elphmod.bravais.to_supercell">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">to_supercell</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">supercell</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Map lattice vector to supercell.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    R : tuple of int</span>
<span class="sd">        Unit-cell lattice vector.</span>
<span class="sd">    supercell : tuple</span>
<span class="sd">        Supercell info returned by :func:`supercell`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    tuple of int</span>
<span class="sd">        Supercell lattice vector.</span>
<span class="sd">    int</span>
<span class="sd">        Index of unit cell within supercell.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">N</span><span class="p">,</span> <span class="p">(</span><span class="n">N1</span><span class="p">,</span> <span class="n">N2</span><span class="p">,</span> <span class="n">N3</span><span class="p">),</span> <span class="p">(</span><span class="n">B1</span><span class="p">,</span> <span class="n">B2</span><span class="p">,</span> <span class="n">B3</span><span class="p">),</span> <span class="n">cells</span> <span class="o">=</span> <span class="n">supercell</span>

    <span class="n">R1</span><span class="p">,</span> <span class="n">r1</span> <span class="o">=</span> <span class="nb">divmod</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">B1</span><span class="p">),</span> <span class="n">N</span><span class="p">)</span>
    <span class="n">R2</span><span class="p">,</span> <span class="n">r2</span> <span class="o">=</span> <span class="nb">divmod</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">B2</span><span class="p">),</span> <span class="n">N</span><span class="p">)</span>
    <span class="n">R3</span><span class="p">,</span> <span class="n">r3</span> <span class="o">=</span> <span class="nb">divmod</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">B3</span><span class="p">),</span> <span class="n">N</span><span class="p">)</span>

    <span class="n">r</span> <span class="o">=</span> <span class="p">(</span><span class="n">r1</span> <span class="o">*</span> <span class="n">N1</span> <span class="o">+</span> <span class="n">r2</span> <span class="o">*</span> <span class="n">N2</span> <span class="o">+</span> <span class="n">r3</span> <span class="o">*</span> <span class="n">N3</span><span class="p">)</span> <span class="o">//</span> <span class="n">N</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">R1</span><span class="p">,</span> <span class="n">R2</span><span class="p">,</span> <span class="n">R3</span><span class="p">),</span> <span class="n">cells</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">r</span><span class="p">))</span></div>


<div class="viewcode-block" id="images">
<a class="viewcode-back" href="../../modules/bravais.html#elphmod.bravais.images">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">images</span><span class="p">(</span><span class="n">k1</span><span class="p">,</span> <span class="n">k2</span><span class="p">,</span> <span class="n">nk</span><span class="p">,</span> <span class="n">angle</span><span class="o">=</span><span class="mi">60</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generate symmetry-equivalent k points.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    k1, k2 : int</span>
<span class="sd">        Indices of point in uniform mesh.</span>
<span class="sd">    nk : int</span>
<span class="sd">        Number of mesh points per dimension.</span>
<span class="sd">    angle : float</span>
<span class="sd">        Angle between mesh axes in degrees.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    set</span>
<span class="sd">        Mesh-point indices of all equivalent k points.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">points</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="c1"># rotation:</span>

        <span class="k">if</span> <span class="n">angle</span> <span class="o">==</span> <span class="mi">60</span><span class="p">:</span> <span class="c1"># by 60 deg</span>
            <span class="n">k1</span><span class="p">,</span> <span class="n">k2</span> <span class="o">=</span> <span class="o">-</span><span class="n">k2</span><span class="p">,</span> <span class="n">k1</span> <span class="o">+</span> <span class="n">k2</span>
        <span class="k">elif</span> <span class="n">angle</span> <span class="o">==</span> <span class="mi">90</span><span class="p">:</span> <span class="c1"># by 90 deg</span>
            <span class="n">k1</span><span class="p">,</span> <span class="n">k2</span> <span class="o">=</span> <span class="o">-</span><span class="n">k2</span><span class="p">,</span> <span class="n">k1</span>
        <span class="k">elif</span> <span class="n">angle</span> <span class="o">==</span> <span class="mi">120</span><span class="p">:</span> <span class="c1"># by 60 deg</span>
            <span class="n">k1</span><span class="p">,</span> <span class="n">k2</span> <span class="o">=</span> <span class="n">k1</span> <span class="o">-</span> <span class="n">k2</span><span class="p">,</span> <span class="n">k1</span>

        <span class="c1"># mapping to [0, nk):</span>

        <span class="n">k1</span> <span class="o">%=</span> <span class="n">nk</span>
        <span class="n">k2</span> <span class="o">%=</span> <span class="n">nk</span>

        <span class="c1"># add point or break loop after full rotation:</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">k1</span><span class="p">,</span> <span class="n">k2</span><span class="p">)</span> <span class="ow">in</span> <span class="n">points</span><span class="p">:</span>
            <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">points</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">k1</span><span class="p">,</span> <span class="n">k2</span><span class="p">))</span>

    <span class="c1"># reflection:</span>

    <span class="n">points</span> <span class="o">|=</span> <span class="nb">set</span><span class="p">((</span><span class="n">k2</span><span class="p">,</span> <span class="n">k1</span><span class="p">)</span> <span class="k">for</span> <span class="n">k1</span><span class="p">,</span> <span class="n">k2</span> <span class="ow">in</span> <span class="n">points</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">points</span></div>


<div class="viewcode-block" id="irreducibles">
<a class="viewcode-back" href="../../modules/bravais.html#elphmod.bravais.irreducibles">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">irreducibles</span><span class="p">(</span><span class="n">nk</span><span class="p">,</span> <span class="n">angle</span><span class="o">=</span><span class="mi">60</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Generate set of irreducible k points.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    nk : int</span>
<span class="sd">        Number of mesh points per dimension.</span>
<span class="sd">    angle : float</span>
<span class="sd">        Angle between mesh axes in degrees.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    set</span>
<span class="sd">        Mesh-point indices of irreducible k points.</span>

<span class="sd">        Of all equivalent points, the first occurrence in the sequence</span>

<span class="sd">        .. math::</span>

<span class="sd">            (0, 0), (0, 1), \dots, (0, n_k - 1), (1, 0), (1, 1), \dots</span>

<span class="sd">        is chosen. :func:`sorted` should yield the same irreducible q points as</span>
<span class="sd">        used by Quantum ESPRESSO&#39;s PHonon code and found in the file *fildyn0*.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># set up sequence as described above:</span>

    <span class="n">points</span> <span class="o">=</span> <span class="p">[</span>
        <span class="p">(</span><span class="n">k1</span><span class="p">,</span> <span class="n">k2</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k1</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nk</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k2</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nk</span><span class="p">)]</span>

    <span class="n">irreducible</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>

    <span class="c1"># remove as many equivalent points as possible:</span>

    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">points</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">irreducible</span><span class="p">:</span>
            <span class="n">reducible</span> <span class="o">=</span> <span class="n">images</span><span class="p">(</span><span class="o">*</span><span class="n">k</span><span class="p">,</span> <span class="n">nk</span><span class="o">=</span><span class="n">nk</span><span class="p">,</span> <span class="n">angle</span><span class="o">=</span><span class="n">angle</span><span class="p">)</span>
            <span class="n">reducible</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
            <span class="n">irreducible</span> <span class="o">-=</span> <span class="n">reducible</span>

    <span class="k">return</span> <span class="n">irreducible</span></div>


<div class="viewcode-block" id="symmetries">
<a class="viewcode-back" href="../../modules/bravais.html#elphmod.bravais.symmetries">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">symmetries</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">epsilon</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">unity</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">angle</span><span class="o">=</span><span class="mi">60</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Find symmetries of data on Monkhorst-Pack mesh.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : ndarray</span>
<span class="sd">        Data on uniform k mesh.</span>
<span class="sd">    epsilon : float</span>
<span class="sd">        Maximum absolute difference of &quot;equal&quot; floats.</span>
<span class="sd">    unity : bool</span>
<span class="sd">        Return identity as first symmetry?</span>
<span class="sd">    angle : float</span>
<span class="sd">        Angle between mesh axes in degrees.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    iterator</span>
<span class="sd">        All symmetries found are returned one after the other.</span>

<span class="sd">        Each symmetry is described by a Boolean (&quot;reflection?&quot;) and a rotation</span>
<span class="sd">        angle in degrees, followed by a mapping between the k-point indices of</span>
<span class="sd">        the original and the transformed mesh.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">a1</span><span class="p">,</span> <span class="n">a2</span> <span class="o">=</span> <span class="n">translations</span><span class="p">(</span><span class="mi">180</span> <span class="o">-</span> <span class="n">angle</span><span class="p">,</span> <span class="n">angle0</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">b1</span><span class="p">,</span> <span class="n">b2</span> <span class="o">=</span> <span class="n">reciprocals</span><span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">)</span>

    <span class="c1"># a1 and b2 must point in x and y direction, respectively,</span>
    <span class="c1"># to make below reflection work properly.</span>

    <span class="n">nk</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">get_image</span><span class="p">(</span><span class="n">reflect</span><span class="p">,</span> <span class="n">angle</span><span class="p">):</span>
        <span class="n">image</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">nk</span><span class="p">,</span> <span class="n">nk</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">k1</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nk</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">k2</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nk</span><span class="p">):</span>
                <span class="c1"># rotation in Cartesian coordinates:</span>

                <span class="n">K</span> <span class="o">=</span> <span class="n">rotate</span><span class="p">(</span><span class="n">k1</span> <span class="o">*</span> <span class="n">b1</span> <span class="o">+</span> <span class="n">k2</span> <span class="o">*</span> <span class="n">b2</span><span class="p">,</span> <span class="n">angle</span> <span class="o">*</span> <span class="n">deg</span><span class="p">)</span>

                <span class="c1"># reflection across the ky axis:</span>

                <span class="k">if</span> <span class="n">reflect</span><span class="p">:</span>
                    <span class="n">K</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>

                <span class="c1"># transform to mesh-point indices in [0, nk):</span>

                <span class="n">K1</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">K</span><span class="p">,</span> <span class="n">a1</span><span class="p">)))</span> <span class="o">%</span> <span class="n">nk</span>
                <span class="n">K2</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">K</span><span class="p">,</span> <span class="n">a2</span><span class="p">)))</span> <span class="o">%</span> <span class="n">nk</span>

                <span class="c1"># discard this symmetry if it is not fulfilled by data:</span>

                <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">k1</span><span class="p">,</span> <span class="n">k2</span><span class="p">]</span> <span class="o">-</span> <span class="n">data</span><span class="p">[</span><span class="n">K1</span><span class="p">,</span> <span class="n">K2</span><span class="p">])</span> <span class="o">&gt;</span> <span class="n">epsilon</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">None</span>

                <span class="c1"># otherwise set another element of the k-point mapping:</span>

                <span class="n">image</span><span class="p">[</span><span class="n">k1</span><span class="p">,</span> <span class="n">k2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">K1</span><span class="p">,</span> <span class="n">K2</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">image</span>

    <span class="c1"># generate iterator through symmetries:</span>

    <span class="n">dangle</span> <span class="o">=</span> <span class="mi">90</span> <span class="k">if</span> <span class="n">angle</span> <span class="o">==</span> <span class="mi">90</span> <span class="k">else</span> <span class="mi">60</span>

    <span class="k">for</span> <span class="n">reflect</span> <span class="ow">in</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">angle</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">360</span><span class="p">,</span> <span class="n">dangle</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">reflect</span> <span class="ow">or</span> <span class="n">angle</span> <span class="ow">or</span> <span class="n">unity</span><span class="p">:</span>
                <span class="n">image</span> <span class="o">=</span> <span class="n">get_image</span><span class="p">(</span><span class="n">reflect</span><span class="p">,</span> <span class="n">angle</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">image</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">yield</span> <span class="p">(</span><span class="n">reflect</span><span class="p">,</span> <span class="n">angle</span><span class="p">),</span> <span class="n">image</span></div>


<div class="viewcode-block" id="complete">
<a class="viewcode-back" href="../../modules/bravais.html#elphmod.bravais.complete">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">complete</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">angle</span><span class="o">=</span><span class="mi">60</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Complete data on Monkhorst-Pack mesh.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : ndarray</span>
<span class="sd">        Incomplete data on uniform mesh. Missing values are represented by NaN.</span>
<span class="sd">    angle : float</span>
<span class="sd">        Angle between mesh axes in degrees.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ndarray</span>
<span class="sd">        Input data with missing values determined via the symmetries found.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">irreducible</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">data</span><span class="p">)))))</span>

    <span class="c1"># return if the data is already complete:</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">irreducible</span><span class="p">)</span> <span class="o">==</span> <span class="n">data</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
        <span class="k">return</span>

    <span class="c1"># test which expected lattice symmetries are fulfilled and fill the gaps:</span>

    <span class="k">for</span> <span class="n">symmetry</span><span class="p">,</span> <span class="n">image</span> <span class="ow">in</span> <span class="n">symmetries</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">unity</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">angle</span><span class="o">=</span><span class="n">angle</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">irreducible</span><span class="p">:</span>
            <span class="n">data</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">image</span><span class="p">[</span><span class="n">k</span><span class="p">])]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="k">return</span></div>


<div class="viewcode-block" id="complete_k">
<a class="viewcode-back" href="../../modules/bravais.html#elphmod.bravais.complete_k">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">complete_k</span><span class="p">(</span><span class="n">wedge</span><span class="p">,</span> <span class="n">nq</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate k dependence for equivalent q points.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    wedge : ndarray</span>
<span class="sd">        Data on irreducible q wedge and uniform k mesh.</span>
<span class="sd">    nq : int</span>
<span class="sd">        Number of q points per dimension.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ndarray</span>
<span class="sd">        Data on uniform q and k meshes.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">q</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">irreducibles</span><span class="p">(</span><span class="n">nq</span><span class="p">))</span>

    <span class="n">nQ</span><span class="p">,</span> <span class="n">nk</span><span class="p">,</span> <span class="n">nk</span> <span class="o">=</span> <span class="n">wedge</span><span class="o">.</span><span class="n">shape</span>

    <span class="n">mesh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">nq</span><span class="p">,</span> <span class="n">nq</span><span class="p">,</span> <span class="n">nk</span><span class="p">,</span> <span class="n">nk</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">wedge</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

    <span class="n">symmetries_q</span> <span class="o">=</span> <span class="p">[</span><span class="n">image</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">image</span> <span class="ow">in</span> <span class="n">symmetries</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nq</span><span class="p">,</span> <span class="n">nq</span><span class="p">)),</span> <span class="n">unity</span><span class="o">=</span><span class="kc">True</span><span class="p">)]</span>

    <span class="n">symmetries_k</span> <span class="o">=</span> <span class="p">[</span><span class="n">image</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">image</span> <span class="ow">in</span> <span class="n">symmetries</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nk</span><span class="p">,</span> <span class="n">nk</span><span class="p">)),</span> <span class="n">unity</span><span class="o">=</span><span class="kc">True</span><span class="p">)]</span>

    <span class="n">done</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">sym_q</span><span class="p">,</span> <span class="n">sym_k</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">symmetries_q</span><span class="p">,</span> <span class="n">symmetries_k</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">iq</span><span class="p">,</span> <span class="p">(</span><span class="n">q1</span><span class="p">,</span> <span class="n">q2</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">q</span><span class="p">):</span>
            <span class="n">Q1</span><span class="p">,</span> <span class="n">Q2</span> <span class="o">=</span> <span class="n">sym_q</span><span class="p">[</span><span class="n">q1</span><span class="p">,</span> <span class="n">q2</span><span class="p">]</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">Q1</span><span class="p">,</span> <span class="n">Q2</span><span class="p">)</span> <span class="ow">in</span> <span class="n">done</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="n">done</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">Q1</span><span class="p">,</span> <span class="n">Q2</span><span class="p">))</span>

            <span class="k">for</span> <span class="n">k1</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nk</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">k2</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nk</span><span class="p">):</span>
                    <span class="n">K1</span><span class="p">,</span> <span class="n">K2</span> <span class="o">=</span> <span class="n">sym_k</span><span class="p">[</span><span class="n">k1</span><span class="p">,</span> <span class="n">k2</span><span class="p">]</span>

                    <span class="n">mesh</span><span class="p">[</span><span class="n">Q1</span><span class="p">,</span> <span class="n">Q2</span><span class="p">,</span> <span class="n">K1</span><span class="p">,</span> <span class="n">K2</span><span class="p">]</span> <span class="o">=</span> <span class="n">wedge</span><span class="p">[</span><span class="n">iq</span><span class="p">,</span> <span class="n">k1</span><span class="p">,</span> <span class="n">k2</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">mesh</span></div>


<div class="viewcode-block" id="stack">
<a class="viewcode-back" href="../../modules/bravais.html#elphmod.bravais.stack">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">stack</span><span class="p">(</span><span class="o">*</span><span class="n">points</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Minimize distance of points on periodic axis via full-period shifts.</span>

<span class="sd">    Example:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        &gt;&gt;&gt; stack(3, 5, 9, 12, period=10)</span>
<span class="sd">        [13, 15, 9, 12]</span>

<span class="sd">    .. code-block:: text</span>

<span class="sd">         In: ... | ox x   x| xo o   o| oo o   o| ...</span>
<span class="sd">        Out: ... | oo o   x| xx x   o| oo o   o| ...</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    *points</span>
<span class="sd">        Points on periodic axis.</span>
<span class="sd">    period : float</span>
<span class="sd">        Period of axis. Specified via `**kwargs` for Python-2 compatibility.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ndarray</span>
<span class="sd">        Points equivalent to input, with minimal distance on non-periodic axis.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">period</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;period&#39;</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>

    <span class="c1"># map points onto interval [0, period):</span>

    <span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">points</span><span class="p">)</span> <span class="o">%</span> <span class="n">period</span>

    <span class="c1"># bring input into uniform shape:</span>

    <span class="n">shape</span> <span class="o">=</span> <span class="n">points</span><span class="o">.</span><span class="n">shape</span>

    <span class="n">points</span> <span class="o">=</span> <span class="n">points</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>

    <span class="c1"># generate list of indices that would sort points:</span>

    <span class="n">order</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="c1"># save &quot;stacking&quot;, shift lowest point up by one period, and repeat:</span>

    <span class="n">stackings</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">*</span><span class="n">points</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">points</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

    <span class="n">stackings</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">points</span>

    <span class="n">corresponding</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="c1"># vectorized equivalent of &quot;:&quot;</span>

    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">stackings</span><span class="p">[</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">stackings</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
        <span class="n">stackings</span><span class="p">[</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">order</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">corresponding</span><span class="p">]</span> <span class="o">+=</span> <span class="n">period</span>

    <span class="c1"># return most localized stacking:</span>

    <span class="n">localized</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">stackings</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">stackings</span><span class="p">[</span><span class="n">localized</span><span class="p">,</span> <span class="p">:,</span> <span class="n">corresponding</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span></div>


    <span class="c1"># re &quot;corresponding&quot; and &quot;.T&quot; see NumPy&#39;s &quot;Advanced indexing&quot; and &quot;NEP 21&quot;</span>

<div class="viewcode-block" id="linear_interpolation">
<a class="viewcode-back" href="../../modules/bravais.html#elphmod.bravais.linear_interpolation">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">linear_interpolation</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">angle</span><span class="o">=</span><span class="mi">60</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">period</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">polar</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Perform linear interpolation in one or two dimensions.</span>

<span class="sd">    The edges are interpolated using periodic boundary conditions.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : ndarray</span>
<span class="sd">        Data on uniform 1D or 2D (triangular or rectangular) lattice.</span>
<span class="sd">    angle : number</span>
<span class="sd">        Angle between lattice vectors in degrees.</span>
<span class="sd">    axes : int or 2-tuple of int</span>
<span class="sd">        Axes of `data` along which to interpolate (lattice vectors).</span>
<span class="sd">    period : number</span>
<span class="sd">        If the values of `data` are defined on a periodic axis (i.e., only with</span>
<span class="sd">        respect to the modulo operation), the period of this axis. This is used</span>
<span class="sd">        in combination with `stack` to always interpolate across the shortest</span>
<span class="sd">        distance of two neighboring points.</span>
<span class="sd">    polar : bool</span>
<span class="sd">        Interpolate complex values linearly in polar coordinates? This is</span>
<span class="sd">        helpful if neighboring data points have arbitrary complex phases.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    function</span>
<span class="sd">        Interpolant for `data`. ``linear_interpolation(data)(i, j)`` yields the</span>
<span class="sd">        same value as ``data[i, j]``. Thus the data array is &quot;generalized&quot; with</span>
<span class="sd">        respect to fractional indices.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    stack : Condense point cloud on periodic axis.</span>
<span class="sd">    resize : Compress or stretch data via linear interpolation.</span>
<span class="sd">    Fourier_interpolation : Alternative interpolation routine.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">polar</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">iscomplexobj</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">linear_interpolation</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="n">angle</span><span class="p">,</span> <span class="n">axes</span><span class="p">,</span> <span class="n">period</span><span class="o">=</span><span class="n">period</span><span class="p">)</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">linear_interpolation</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="n">angle</span><span class="p">,</span> <span class="n">axes</span><span class="p">,</span> <span class="n">period</span><span class="o">=</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">interpolant</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">r</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">p</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">interpolant</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">axes</span><span class="p">,</span> <span class="s1">&#39;__len__&#39;</span><span class="p">):</span>
        <span class="n">axes</span> <span class="o">=</span> <span class="p">(</span><span class="n">axes</span><span class="p">,)</span>

    <span class="c1"># move lattice axes to the front:</span>

    <span class="n">order</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">axes</span><span class="p">)</span> <span class="o">+</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span> <span class="k">if</span> <span class="n">n</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">axes</span><span class="p">)</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="n">order</span><span class="p">)</span>

    <span class="c1"># interpret &quot;fractional indices&quot;:</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">split</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">N</span><span class="p">):</span>
        <span class="n">n0</span><span class="p">,</span> <span class="n">dn</span> <span class="o">=</span> <span class="nb">divmod</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">n0</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">n0</span><span class="p">)</span> <span class="o">%</span> <span class="n">N</span>

        <span class="k">return</span> <span class="n">n0</span><span class="p">,</span> <span class="n">dn</span>

    <span class="c1"># define interpolation routines for different lattices:</span>

    <span class="n">N</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">axes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">M</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">axes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c1">#  ______</span>
        <span class="c1"># A  a1  B</span>
        <span class="c1">#</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">interpolant</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="n">n0</span><span class="p">,</span> <span class="n">dn</span> <span class="o">=</span> <span class="n">split</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span>

            <span class="n">A</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">n0</span><span class="p">]</span>
            <span class="n">B</span> <span class="o">=</span> <span class="n">data</span><span class="p">[(</span><span class="n">n0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">N</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">period</span><span class="p">:</span>
                <span class="n">A</span><span class="p">,</span> <span class="n">B</span> <span class="o">=</span> <span class="n">stack</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">period</span><span class="o">=</span><span class="n">period</span><span class="p">)</span>

            <span class="k">return</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">dn</span><span class="p">)</span> <span class="o">*</span> <span class="n">A</span> <span class="o">+</span> <span class="n">dn</span> <span class="o">*</span> <span class="n">B</span>

    <span class="k">elif</span> <span class="n">angle</span> <span class="o">==</span> <span class="mi">60</span><span class="p">:</span>
        <span class="c1">#</span>
        <span class="c1">#     B______C&#39;</span>
        <span class="c1">#     /\    /</span>
        <span class="c1"># a2 /  \  /</span>
        <span class="c1">#   /____\/</span>
        <span class="c1">#  C  a1  A</span>
        <span class="c1">#</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">interpolant</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
            <span class="n">n0</span><span class="p">,</span> <span class="n">dn</span> <span class="o">=</span> <span class="n">split</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span>
            <span class="n">m0</span><span class="p">,</span> <span class="n">dm</span> <span class="o">=</span> <span class="n">split</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">M</span><span class="p">)</span>

            <span class="n">A</span> <span class="o">=</span> <span class="n">data</span><span class="p">[(</span><span class="n">n0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">N</span><span class="p">,</span> <span class="n">m0</span><span class="p">]</span>
            <span class="n">B</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">n0</span><span class="p">,</span> <span class="p">(</span><span class="n">m0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">M</span><span class="p">]</span>

            <span class="n">prime</span> <span class="o">=</span> <span class="n">dn</span> <span class="o">+</span> <span class="n">dm</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="c1"># use C&#39; rather than C</span>

            <span class="k">if</span> <span class="n">prime</span><span class="p">:</span>
                <span class="n">C</span> <span class="o">=</span> <span class="n">data</span><span class="p">[(</span><span class="n">n0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">N</span><span class="p">,</span> <span class="p">(</span><span class="n">m0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">M</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">C</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">n0</span><span class="p">,</span> <span class="n">m0</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">period</span><span class="p">:</span>
                <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span> <span class="o">=</span> <span class="n">stack</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">period</span><span class="o">=</span><span class="n">period</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">prime</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">dm</span><span class="p">)</span> <span class="o">*</span> <span class="n">A</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">dn</span><span class="p">)</span> <span class="o">*</span> <span class="n">B</span> <span class="o">+</span> <span class="p">(</span><span class="n">dn</span> <span class="o">+</span> <span class="n">dm</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">C</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">dn</span> <span class="o">*</span> <span class="n">A</span> <span class="o">+</span> <span class="n">dm</span> <span class="o">*</span> <span class="n">B</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">dn</span> <span class="o">-</span> <span class="n">dm</span><span class="p">)</span> <span class="o">*</span> <span class="n">C</span>

    <span class="k">elif</span> <span class="n">angle</span> <span class="o">==</span> <span class="mi">90</span><span class="p">:</span>
        <span class="c1">#</span>
        <span class="c1">#   D ____ C</span>
        <span class="c1">#    |    |</span>
        <span class="c1"># a2 |    |</span>
        <span class="c1">#    |____|</span>
        <span class="c1">#   A  a1  B</span>
        <span class="c1">#</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">interpolant</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
            <span class="n">n0</span><span class="p">,</span> <span class="n">dn</span> <span class="o">=</span> <span class="n">split</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span>
            <span class="n">m0</span><span class="p">,</span> <span class="n">dm</span> <span class="o">=</span> <span class="n">split</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">M</span><span class="p">)</span>

            <span class="n">A</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">n0</span><span class="p">,</span> <span class="n">m0</span><span class="p">]</span>
            <span class="n">B</span> <span class="o">=</span> <span class="n">data</span><span class="p">[(</span><span class="n">n0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">N</span><span class="p">,</span> <span class="n">m0</span><span class="p">]</span>
            <span class="n">C</span> <span class="o">=</span> <span class="n">data</span><span class="p">[(</span><span class="n">n0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">N</span><span class="p">,</span> <span class="p">(</span><span class="n">m0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">M</span><span class="p">]</span>
            <span class="n">D</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">n0</span><span class="p">,</span> <span class="p">(</span><span class="n">m0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">M</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">period</span><span class="p">:</span>
                <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">D</span> <span class="o">=</span> <span class="n">stack</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">period</span><span class="o">=</span><span class="n">period</span><span class="p">)</span>

            <span class="k">return</span> <span class="p">((</span><span class="mi">1</span> <span class="o">-</span> <span class="n">dn</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">dm</span><span class="p">)</span> <span class="o">*</span> <span class="n">A</span> <span class="o">+</span> <span class="n">dn</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">dm</span><span class="p">)</span> <span class="o">*</span> <span class="n">B</span>
                <span class="o">+</span> <span class="n">dn</span> <span class="o">*</span> <span class="n">dm</span> <span class="o">*</span> <span class="n">C</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">dn</span><span class="p">)</span> <span class="o">*</span> <span class="n">dm</span> <span class="o">*</span> <span class="n">D</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">angle</span> <span class="o">==</span> <span class="mi">120</span><span class="p">:</span>
        <span class="c1">#</span>
        <span class="c1">#  C______B</span>
        <span class="c1">#   \    /\</span>
        <span class="c1"># a2 \  /  \</span>
        <span class="c1">#     \/____\</span>
        <span class="c1">#     A  a1  C&#39;</span>
        <span class="c1">#</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">interpolant</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
            <span class="n">n0</span><span class="p">,</span> <span class="n">dn</span> <span class="o">=</span> <span class="n">split</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span>
            <span class="n">m0</span><span class="p">,</span> <span class="n">dm</span> <span class="o">=</span> <span class="n">split</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">M</span><span class="p">)</span>

            <span class="n">A</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">n0</span><span class="p">,</span> <span class="n">m0</span><span class="p">]</span>
            <span class="n">B</span> <span class="o">=</span> <span class="n">data</span><span class="p">[(</span><span class="n">n0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">N</span><span class="p">,</span> <span class="p">(</span><span class="n">m0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">M</span><span class="p">]</span>

            <span class="n">prime</span> <span class="o">=</span> <span class="n">dn</span> <span class="o">&gt;</span> <span class="n">dm</span> <span class="c1"># use C&#39; rather than C</span>

            <span class="k">if</span> <span class="n">prime</span><span class="p">:</span>
                <span class="n">C</span> <span class="o">=</span> <span class="n">data</span><span class="p">[(</span><span class="n">n0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">N</span><span class="p">,</span> <span class="n">m0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">C</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">n0</span><span class="p">,</span> <span class="p">(</span><span class="n">m0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">M</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">period</span><span class="p">:</span>
                <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span> <span class="o">=</span> <span class="n">stack</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">period</span><span class="o">=</span><span class="n">period</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">prime</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">dn</span><span class="p">)</span> <span class="o">*</span> <span class="n">A</span> <span class="o">+</span> <span class="n">dm</span> <span class="o">*</span> <span class="n">B</span> <span class="o">+</span> <span class="p">(</span><span class="n">dn</span> <span class="o">-</span> <span class="n">dm</span><span class="p">)</span> <span class="o">*</span> <span class="n">C</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">dm</span><span class="p">)</span> <span class="o">*</span> <span class="n">A</span> <span class="o">+</span> <span class="n">dn</span> <span class="o">*</span> <span class="n">B</span> <span class="o">+</span> <span class="p">(</span><span class="n">dm</span> <span class="o">-</span> <span class="n">dn</span><span class="p">)</span> <span class="o">*</span> <span class="n">C</span>

    <span class="c1"># make interpolant function applicable to arrays and return:</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vectorize</span><span class="p">(</span><span class="n">interpolant</span><span class="p">)</span></div>


<div class="viewcode-block" id="resize">
<a class="viewcode-back" href="../../modules/bravais.html#elphmod.bravais.resize">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">resize</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">angle</span><span class="o">=</span><span class="mi">60</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">period</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">polar</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">periodic</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Resize array via linear interpolation along one or two axes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    shape : int or 2-tuple of int</span>
<span class="sd">        New lattice shape.</span>
<span class="sd">    shape, angle, axes, period, polar</span>
<span class="sd">        Parameters for :func:`linear_interpolation`.</span>
<span class="sd">    periodic : bool, default True</span>
<span class="sd">        Interpolate between last and first data point of each axis?</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ndarray</span>
<span class="sd">        Resized data array.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    linear_interpolation</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="s1">&#39;__len__&#39;</span><span class="p">):</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">shape</span><span class="p">,)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">axes</span><span class="p">,</span> <span class="s1">&#39;__len__&#39;</span><span class="p">):</span>
        <span class="n">axes</span> <span class="o">=</span> <span class="p">(</span><span class="n">axes</span><span class="p">,)</span>

    <span class="c1"># move lattice axes to the front:</span>

    <span class="n">order</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">axes</span><span class="p">)</span> <span class="o">+</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span> <span class="k">if</span> <span class="n">n</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">axes</span><span class="p">)</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="n">order</span><span class="p">)</span>

    <span class="c1"># set up interpolation function:</span>

    <span class="n">interpolant</span> <span class="o">=</span> <span class="n">linear_interpolation</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">angle</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)),</span>
        <span class="n">period</span><span class="o">=</span><span class="n">period</span><span class="p">,</span> <span class="n">polar</span><span class="o">=</span><span class="n">polar</span><span class="p">)</span>

    <span class="c1"># apply interpolation function at new lattice points in parallel:</span>

    <span class="n">size</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">sizes</span><span class="p">,</span> <span class="n">bounds</span> <span class="o">=</span> <span class="n">elphmod</span><span class="o">.</span><span class="n">MPI</span><span class="o">.</span><span class="n">distribute</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="n">my_new_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">sizes</span><span class="p">[</span><span class="n">comm</span><span class="o">.</span><span class="n">rank</span><span class="p">],</span> <span class="o">*</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">):]),</span>
        <span class="n">dtype</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">periodic</span><span class="p">:</span>
        <span class="n">scale</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)],</span> <span class="n">shape</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">scale</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)],</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="o">*</span><span class="n">bounds</span><span class="p">[</span><span class="n">comm</span><span class="o">.</span><span class="n">rank</span><span class="p">:</span><span class="n">comm</span><span class="o">.</span><span class="n">rank</span> <span class="o">+</span> <span class="mi">2</span><span class="p">])):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">m</span> <span class="o">//</span> <span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">m</span> <span class="o">%</span> <span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">my_new_data</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">interpolant</span><span class="p">(</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">scale</span><span class="p">))</span>

    <span class="n">new_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="o">*</span><span class="n">shape</span><span class="p">,</span> <span class="o">*</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">):]),</span>
        <span class="n">dtype</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

    <span class="n">comm</span><span class="o">.</span><span class="n">Allgatherv</span><span class="p">(</span><span class="n">my_new_data</span><span class="p">,</span>
        <span class="p">(</span><span class="n">new_data</span><span class="p">,</span> <span class="n">sizes</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">):],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)))</span>

    <span class="c1"># restore original order of axes and return:</span>

    <span class="n">new_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">new_data</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">order</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">new_data</span></div>


<div class="viewcode-block" id="squared_distance">
<a class="viewcode-back" href="../../modules/bravais.html#elphmod.bravais.squared_distance">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">squared_distance</span><span class="p">(</span><span class="n">k1</span><span class="p">,</span> <span class="n">k2</span><span class="p">,</span> <span class="n">angle</span><span class="o">=</span><span class="mi">60</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate squared distance of lattice point from origin.</span>

<span class="sd">    If the coordinates are given as integers, the result is numerically exact.</span>
<span class="sd">    For 60 or 120 deg. (triangular lattice) this yields the Loeschian numbers.</span>
<span class="sd">    Non-equivalent lattice sites may have the same distance from the origin!</span>
<span class="sd">    (E.g., there are non-equivalent 20th neighbors in a triangular lattice.)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    k1, k2 : int</span>
<span class="sd">        Point in lattice coordinates (crystal coordinates, mesh-indices, ...).</span>
<span class="sd">    angle : number</span>
<span class="sd">        Angle between lattice axes.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    number</span>
<span class="sd">        Squared distance of point from origin.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">sgn</span> <span class="o">=</span> <span class="p">{</span><span class="mi">60</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">90</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">120</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">}[</span><span class="n">angle</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">k1</span> <span class="o">*</span> <span class="n">k1</span> <span class="o">+</span> <span class="n">k2</span> <span class="o">*</span> <span class="n">k2</span> <span class="o">+</span> <span class="n">sgn</span> <span class="o">*</span> <span class="n">k1</span> <span class="o">*</span> <span class="n">k2</span></div>


<div class="viewcode-block" id="to_Voronoi">
<a class="viewcode-back" href="../../modules/bravais.html#elphmod.bravais.to_Voronoi">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">to_Voronoi</span><span class="p">(</span><span class="n">k1</span><span class="p">,</span> <span class="n">k2</span><span class="p">,</span> <span class="n">nk</span><span class="p">,</span> <span class="n">angle</span><span class="o">=</span><span class="mi">60</span><span class="p">,</span> <span class="n">dk1</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">dk2</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">epsilon</span><span class="o">=</span><span class="mf">0.0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Map any lattice point to the Voronoi cell* around the origin.</span>

<span class="sd">    (*) Wigner-Seitz cell/Brillouin zone for Bravais/reciprocal lattice.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    k1, k2 : int</span>
<span class="sd">        Mesh-point indices.</span>
<span class="sd">    nk : int</span>
<span class="sd">        Number of points per dimension.</span>
<span class="sd">    angle : number</span>
<span class="sd">        Angle between lattice vectors.</span>
<span class="sd">    dk1, dk2 : number</span>
<span class="sd">        Shift of Voronoi cell.</span>
<span class="sd">    epsilon : float</span>
<span class="sd">        Maximum absolute difference of &quot;equal&quot; floats.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    set</span>
<span class="sd">        All equivalent point within or on the edge of the Voronoi cell.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">k1</span> <span class="o">%=</span> <span class="n">nk</span>
    <span class="n">k2</span> <span class="o">%=</span> <span class="n">nk</span>

    <span class="n">images</span> <span class="o">=</span> <span class="p">[(</span><span class="n">k1</span><span class="p">,</span> <span class="n">k2</span><span class="p">),</span> <span class="p">(</span><span class="n">k1</span> <span class="o">-</span> <span class="n">nk</span><span class="p">,</span> <span class="n">k2</span><span class="p">),</span> <span class="p">(</span><span class="n">k1</span><span class="p">,</span> <span class="n">k2</span> <span class="o">-</span> <span class="n">nk</span><span class="p">),</span> <span class="p">(</span><span class="n">k1</span> <span class="o">-</span> <span class="n">nk</span><span class="p">,</span> <span class="n">k2</span> <span class="o">-</span> <span class="n">nk</span><span class="p">)]</span>

    <span class="k">if</span> <span class="n">nk</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
        <span class="n">images</span><span class="o">.</span><span class="n">extend</span><span class="p">([(</span><span class="n">k1</span> <span class="o">+</span> <span class="n">nk</span><span class="p">,</span> <span class="n">k2</span><span class="p">),</span> <span class="p">(</span><span class="n">k1</span><span class="p">,</span> <span class="n">k2</span> <span class="o">+</span> <span class="n">nk</span><span class="p">),</span> <span class="p">(</span><span class="n">k1</span> <span class="o">+</span> <span class="n">nk</span><span class="p">,</span> <span class="n">k2</span> <span class="o">+</span> <span class="n">nk</span><span class="p">)])</span>

    <span class="n">distances</span> <span class="o">=</span> <span class="p">[</span><span class="n">squared_distance</span><span class="p">(</span><span class="n">k1</span> <span class="o">-</span> <span class="n">dk1</span><span class="p">,</span> <span class="n">k2</span> <span class="o">-</span> <span class="n">dk2</span><span class="p">,</span> <span class="n">angle</span><span class="o">=</span><span class="n">angle</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k1</span><span class="p">,</span> <span class="n">k2</span> <span class="ow">in</span> <span class="n">images</span><span class="p">]</span>
    <span class="n">minimum</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">distances</span><span class="p">)</span>
    <span class="n">images</span> <span class="o">=</span> <span class="p">{</span><span class="n">image</span> <span class="k">for</span> <span class="n">image</span><span class="p">,</span> <span class="n">distance</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">images</span><span class="p">,</span> <span class="n">distances</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">distance</span> <span class="o">-</span> <span class="n">minimum</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">epsilon</span><span class="p">}</span>

    <span class="k">return</span> <span class="n">images</span></div>


<div class="viewcode-block" id="wigner_2d">
<a class="viewcode-back" href="../../modules/bravais.html#elphmod.bravais.wigner_2d">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">wigner_2d</span><span class="p">(</span><span class="n">nk</span><span class="p">,</span> <span class="n">angle</span><span class="o">=</span><span class="mi">120</span><span class="p">,</span> <span class="n">dk1</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">dk2</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">epsilon</span><span class="o">=</span><span class="mf">0.0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Find lattice points in Wigner-Seitz cell (including boundary).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    nk : int</span>
<span class="sd">        Number of points per dimension.</span>
<span class="sd">    angle : number</span>
<span class="sd">        Angle between lattice vectors.</span>
<span class="sd">    dk1, dk2 : float</span>
<span class="sd">        Shift of Wigner-Seitz cell.</span>
<span class="sd">    epsilon : float</span>
<span class="sd">        Maximum absolute difference of &quot;equal&quot; floats.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    list of tuple of int</span>
<span class="sd">        Mesh-point indices.</span>
<span class="sd">    list of int</span>
<span class="sd">        Degeneracies.</span>
<span class="sd">    list of float</span>
<span class="sd">        Lattice-vector lengths.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">points</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">k1</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nk</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">k2</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nk</span><span class="p">):</span>
            <span class="n">images</span> <span class="o">=</span> <span class="n">to_Voronoi</span><span class="p">(</span><span class="n">k1</span><span class="p">,</span> <span class="n">k2</span><span class="p">,</span> <span class="n">nk</span><span class="p">,</span> <span class="n">angle</span><span class="p">,</span> <span class="n">dk1</span><span class="p">,</span> <span class="n">dk2</span><span class="p">,</span> <span class="n">epsilon</span><span class="p">)</span>

            <span class="n">points</span><span class="o">.</span><span class="n">extend</span><span class="p">([(</span><span class="n">point</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">images</span><span class="p">))</span> <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="n">images</span><span class="p">])</span>

    <span class="n">points</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>

    <span class="n">irvec</span><span class="p">,</span> <span class="n">ndegen</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">points</span><span class="p">)</span>

    <span class="n">wslen</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">squared_distance</span><span class="p">(</span><span class="n">k1</span><span class="p">,</span> <span class="n">k2</span><span class="p">,</span> <span class="n">angle</span><span class="p">))</span> <span class="k">for</span> <span class="n">k1</span><span class="p">,</span> <span class="n">k2</span> <span class="ow">in</span> <span class="n">irvec</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">irvec</span><span class="p">,</span> <span class="n">ndegen</span><span class="p">,</span> <span class="n">wslen</span></div>


<div class="viewcode-block" id="read_wigner_file">
<a class="viewcode-back" href="../../modules/bravais.html#elphmod.bravais.read_wigner_file">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">read_wigner_file</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">old_ws</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">nat</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Read binary file with Wigner-Seitz data as used by EPW.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    name : str</span>
<span class="sd">        Name of file with Wigner-Seitz data.</span>
<span class="sd">    old_ws : bool</span>
<span class="sd">        Use previous definition of Wigner-Seitz cells? This is required if</span>
<span class="sd">        `patches/qe-6.3-backports.patch` has been used.</span>
<span class="sd">    nat : int</span>
<span class="sd">        Number of atoms per unit cell.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    elphmod.elph.Model</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">comm</span><span class="o">.</span><span class="n">rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">FileNotFoundError</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">name</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;.dat&#39;</span><span class="p">):</span>
                <span class="n">other</span> <span class="o">=</span> <span class="n">name</span><span class="p">[:</span><span class="o">-</span><span class="mi">4</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;.fmt&#39;</span>
            <span class="k">elif</span> <span class="n">name</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;.fmt&#39;</span><span class="p">):</span>
                <span class="n">other</span> <span class="o">=</span> <span class="n">name</span><span class="p">[:</span><span class="o">-</span><span class="mi">4</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;.dat&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span>

            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Warning: &quot;</span><span class="si">%s</span><span class="s1">&quot; not found, trying &quot;</span><span class="si">%s</span><span class="s1">&quot;!&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">other</span><span class="p">))</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">other</span>

            <span class="n">data</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span>

        <span class="n">binary</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;</span><span class="se">\x00</span><span class="s1">&#39;</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
        <span class="n">data</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">binary</span><span class="p">:</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">data</span><span class="p">:</span>
                <span class="n">integer</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span>
                <span class="n">double</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span>

                <span class="k">if</span> <span class="n">old_ws</span><span class="p">:</span>
                    <span class="n">dims</span> <span class="o">=</span> <span class="mi">1</span>
                    <span class="n">dims2</span> <span class="o">=</span> <span class="n">nat</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">dims</span><span class="p">,</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">integer</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                    <span class="n">dims2</span><span class="p">,</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">integer</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

                <span class="n">nrr_k</span><span class="p">,</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">integer</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">irvec_k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">integer</span><span class="p">,</span> <span class="n">nrr_k</span> <span class="o">*</span> <span class="mi">3</span><span class="p">)</span>
                <span class="n">irvec_k</span> <span class="o">=</span> <span class="n">irvec_k</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">nrr_k</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
                <span class="n">ndegen_k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">integer</span><span class="p">,</span> <span class="n">dims</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">nrr_k</span><span class="p">)</span>
                <span class="n">ndegen_k</span> <span class="o">=</span> <span class="n">ndegen_k</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">dims</span><span class="p">,</span> <span class="n">dims</span><span class="p">,</span> <span class="n">nrr_k</span><span class="p">))</span>

                <span class="k">if</span> <span class="n">old_ws</span><span class="p">:</span>
                    <span class="n">wslen_k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">double</span><span class="p">,</span> <span class="n">nrr_k</span><span class="p">)</span>
                    <span class="n">nrr_q</span><span class="p">,</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">integer</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                    <span class="n">irvec_q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">integer</span><span class="p">,</span> <span class="n">nrr_q</span> <span class="o">*</span> <span class="mi">3</span><span class="p">)</span>
                    <span class="n">irvec_q</span> <span class="o">=</span> <span class="n">irvec_q</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">nrr_q</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
                    <span class="n">ndegen_q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">integer</span><span class="p">,</span> <span class="n">dims2</span> <span class="o">*</span> <span class="n">dims2</span> <span class="o">*</span> <span class="n">nrr_q</span><span class="p">)</span>
                    <span class="n">ndegen_q</span> <span class="o">=</span> <span class="n">ndegen_q</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">dims2</span><span class="p">,</span> <span class="n">dims2</span><span class="p">,</span> <span class="n">nrr_q</span><span class="p">))</span>
                    <span class="n">wslen_q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">double</span><span class="p">,</span> <span class="n">nrr_q</span><span class="p">)</span>

                <span class="n">nrr_g</span><span class="p">,</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">integer</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">irvec_g</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">integer</span><span class="p">,</span> <span class="n">nrr_g</span> <span class="o">*</span> <span class="mi">3</span><span class="p">)</span>
                <span class="n">irvec_g</span> <span class="o">=</span> <span class="n">irvec_g</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">nrr_g</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>

                <span class="k">if</span> <span class="n">old_ws</span><span class="p">:</span>
                    <span class="n">ndegen_g</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">integer</span><span class="p">,</span> <span class="n">dims2</span> <span class="o">*</span> <span class="n">nrr_g</span><span class="p">)</span>
                    <span class="n">wslen_g</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">double</span><span class="p">,</span> <span class="n">nrr_g</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">ndegen_g</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">integer</span><span class="p">)</span>

                <span class="k">try</span><span class="p">:</span>
                    <span class="n">ndegen_g</span> <span class="o">=</span> <span class="n">ndegen_g</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">dims</span><span class="p">,</span> <span class="n">dims</span><span class="p">,</span> <span class="n">dims2</span><span class="p">,</span> <span class="n">nrr_g</span><span class="p">))</span>
                <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span> <span class="c1"># since QE 6.8</span>
                    <span class="n">ndegen_g</span> <span class="o">=</span> <span class="n">ndegen_g</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">dims2</span><span class="p">,</span> <span class="n">nrr_g</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dims</span><span class="p">))</span>
                    <span class="n">ndegen_g</span> <span class="o">=</span> <span class="n">ndegen_g</span><span class="o">.</span><span class="n">transpose</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">lines</span><span class="p">:</span>
                <span class="k">def</span><span class="w"> </span><span class="nf">integers</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
                    <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">next</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">()[:</span><span class="n">n</span><span class="p">]))</span>

                <span class="n">nrr_k</span><span class="p">,</span> <span class="n">nrr_q</span><span class="p">,</span> <span class="n">nrr_g</span><span class="p">,</span> <span class="n">dims</span><span class="p">,</span> <span class="n">dims2</span> <span class="o">=</span> <span class="n">integers</span><span class="p">()</span>

                <span class="n">irvec_k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">nrr_k</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
                <span class="n">irvec_q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">nrr_q</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
                <span class="n">irvec_g</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">nrr_g</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>

                <span class="n">ndegen_k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">dims</span><span class="p">,</span> <span class="n">dims</span><span class="p">,</span> <span class="n">nrr_k</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
                <span class="n">ndegen_q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">dims2</span><span class="p">,</span> <span class="n">dims2</span><span class="p">,</span> <span class="n">nrr_q</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
                <span class="n">ndegen_g</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="n">dims</span><span class="p">,</span> <span class="n">dims2</span><span class="p">,</span> <span class="n">nrr_g</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>

                <span class="k">for</span> <span class="n">ir</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nrr_k</span><span class="p">):</span>
                    <span class="n">irvec_k</span><span class="p">[</span><span class="n">ir</span><span class="p">]</span> <span class="o">=</span> <span class="n">integers</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>

                    <span class="k">for</span> <span class="n">iw</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dims</span><span class="p">):</span>
                        <span class="n">ndegen_k</span><span class="p">[:,</span> <span class="n">iw</span><span class="p">,</span> <span class="n">ir</span><span class="p">]</span> <span class="o">=</span> <span class="n">integers</span><span class="p">()</span>

                <span class="k">for</span> <span class="n">ir</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nrr_q</span><span class="p">):</span>
                    <span class="n">irvec_q</span><span class="p">[</span><span class="n">ir</span><span class="p">]</span> <span class="o">=</span> <span class="n">integers</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>

                    <span class="k">for</span> <span class="n">na</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dims2</span><span class="p">):</span>
                        <span class="n">ndegen_q</span><span class="p">[:,</span> <span class="n">na</span><span class="p">,</span> <span class="n">ir</span><span class="p">]</span> <span class="o">=</span> <span class="n">integers</span><span class="p">()</span>

                <span class="k">for</span> <span class="n">ir</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nrr_g</span><span class="p">):</span>
                    <span class="n">irvec_g</span><span class="p">[</span><span class="n">ir</span><span class="p">]</span> <span class="o">=</span> <span class="n">integers</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>

                    <span class="k">for</span> <span class="n">iw</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dims</span><span class="p">):</span>
                        <span class="n">ndegen_g</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">iw</span><span class="p">,</span> <span class="p">:,</span> <span class="n">ir</span><span class="p">]</span> <span class="o">=</span> <span class="n">integers</span><span class="p">()</span>

        <span class="n">data</span> <span class="o">=</span> <span class="n">irvec_k</span><span class="p">,</span> <span class="n">ndegen_k</span><span class="p">,</span> <span class="n">irvec_g</span><span class="p">,</span> <span class="n">ndegen_g</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">comm</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">data</span></div>


<div class="viewcode-block" id="wigner">
<a class="viewcode-back" href="../../modules/bravais.html#elphmod.bravais.wigner">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">wigner</span><span class="p">(</span><span class="n">nr1</span><span class="p">,</span> <span class="n">nr2</span><span class="p">,</span> <span class="n">nr3</span><span class="p">,</span> <span class="n">at</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">tau2</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="mf">1e-7</span><span class="p">,</span> <span class="n">sgn</span><span class="o">=+</span><span class="mi">1</span><span class="p">,</span> <span class="n">nsc</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Determine Wigner-Seitz lattice vectors with degenercies and lengths.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    nr1, nr2, nr3 : ndarray</span>
<span class="sd">        Dimensions of positive lattice-vector mesh.</span>
<span class="sd">    at : ndarray</span>
<span class="sd">        Bravais lattice vectors.</span>
<span class="sd">    tau : ndarray</span>
<span class="sd">        Positions of basis orbitals or atoms in original cell.</span>
<span class="sd">    tau2 : ndarray, optional</span>
<span class="sd">        Positions of basis orbitals or atoms in shifted cell. Defaults to `tau`.</span>
<span class="sd">    eps : float</span>
<span class="sd">        Tolerance for orbital or atomic distances to be considered equal.</span>
<span class="sd">    sgn : int</span>
<span class="sd">        Do the lattice vectors shift the first (``-1``) or second (``+1``)</span>
<span class="sd">        orbital/atom?</span>
<span class="sd">    nsc : int</span>
<span class="sd">        Number of supercells per dimension and direction where Wigner-Seitz</span>
<span class="sd">        lattice vectors are searched for.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    irvec : ndarray</span>
<span class="sd">        Wigner-Seitz lattice vectors.</span>
<span class="sd">    ndegen : ndarray</span>
<span class="sd">        Corresponding degeneracies.</span>
<span class="sd">    wslen : ndarray</span>
<span class="sd">        Corresponding lengths.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">tau2</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">tau2</span> <span class="o">=</span> <span class="n">tau</span>

    <span class="n">supercells</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="n">nsc</span><span class="p">,</span> <span class="n">nsc</span><span class="p">)</span> <span class="c1"># intentionally asymmetric (mesh is positive)</span>

    <span class="n">data</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

    <span class="n">N</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># counter for parallelization</span>

    <span class="k">for</span> <span class="n">m1</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nr1</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">m2</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nr2</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">m3</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nr3</span><span class="p">):</span>
                <span class="n">N</span> <span class="o">+=</span> <span class="mi">1</span>

                <span class="k">if</span> <span class="n">N</span> <span class="o">%</span> <span class="n">comm</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="n">comm</span><span class="o">.</span><span class="n">rank</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="c1"># determine equivalent unit cells within considered supercells:</span>

                <span class="n">copies</span> <span class="o">=</span> <span class="n">sgn</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span>
                        <span class="n">M1</span> <span class="o">*</span> <span class="n">nr1</span> <span class="o">+</span> <span class="n">m1</span><span class="p">,</span>
                        <span class="n">M2</span> <span class="o">*</span> <span class="n">nr2</span> <span class="o">+</span> <span class="n">m2</span><span class="p">,</span>
                        <span class="n">M3</span> <span class="o">*</span> <span class="n">nr3</span> <span class="o">+</span> <span class="n">m3</span><span class="p">,</span>
                        <span class="p">]</span>
                    <span class="k">for</span> <span class="n">M1</span> <span class="ow">in</span> <span class="n">supercells</span>
                    <span class="k">for</span> <span class="n">M2</span> <span class="ow">in</span> <span class="n">supercells</span>
                    <span class="k">for</span> <span class="n">M3</span> <span class="ow">in</span> <span class="n">supercells</span>
                    <span class="p">])</span>

                <span class="c1"># calculate corresponding translation vectors:</span>

                <span class="n">shifts</span> <span class="o">=</span> <span class="n">copies</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">at</span><span class="p">)</span>

                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">tau</span><span class="p">)):</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">tau2</span><span class="p">)):</span>
                        <span class="c1"># find equivalent bond(s) within Wigner-Seitz cell:</span>

                        <span class="n">bonds</span> <span class="o">=</span> <span class="p">[</span><span class="n">r</span> <span class="o">+</span> <span class="n">tau2</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="n">tau</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">shifts</span><span class="p">]</span>
                        <span class="n">lengths</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">r</span><span class="p">))</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">bonds</span><span class="p">]</span>
                        <span class="n">length</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">lengths</span><span class="p">)</span>

                        <span class="n">selected</span> <span class="o">=</span> <span class="n">copies</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">lengths</span> <span class="o">-</span> <span class="n">length</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">eps</span><span class="p">)]</span>

                        <span class="c1"># save mapped lattice vectors and degeneracy and length:</span>

                        <span class="k">for</span> <span class="n">R</span> <span class="ow">in</span> <span class="n">selected</span><span class="p">:</span>
                            <span class="n">R</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">R</span><span class="p">)</span>

                            <span class="k">if</span> <span class="n">R</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
                                <span class="n">data</span><span class="p">[</span><span class="n">R</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
                                    <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">tau</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">tau2</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">),</span>
                                    <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">tau</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">tau2</span><span class="p">)))]</span>

                            <span class="n">data</span><span class="p">[</span><span class="n">R</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">selected</span><span class="p">)</span>
                            <span class="n">data</span><span class="p">[</span><span class="n">R</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">length</span>

    <span class="c1"># convert dictionary into arrays:</span>

    <span class="n">my_count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="n">my_irvec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">keys</span><span class="p">()),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">my_ndegen</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">my_count</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">tau</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">tau2</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">my_wslen</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">my_count</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">tau</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">tau2</span><span class="p">)))</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">l</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
        <span class="n">my_ndegen</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span>
        <span class="n">my_wslen</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">l</span>

    <span class="c1"># gather data of all processes:</span>

    <span class="n">my_counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">comm</span><span class="o">.</span><span class="n">allgather</span><span class="p">(</span><span class="n">my_count</span><span class="p">))</span>
    <span class="n">count</span> <span class="o">=</span> <span class="n">my_counts</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

    <span class="n">irvec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">count</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">ndegen</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">count</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">tau</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">tau2</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">wslen</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">count</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">tau</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">tau2</span><span class="p">)))</span>

    <span class="n">comm</span><span class="o">.</span><span class="n">Allgatherv</span><span class="p">(</span><span class="n">my_irvec</span><span class="p">,</span> <span class="p">(</span><span class="n">irvec</span><span class="p">,</span> <span class="n">my_counts</span> <span class="o">*</span> <span class="mi">3</span><span class="p">))</span>
    <span class="n">comm</span><span class="o">.</span><span class="n">Allgatherv</span><span class="p">(</span><span class="n">my_ndegen</span><span class="p">,</span> <span class="p">(</span><span class="n">ndegen</span><span class="p">,</span> <span class="n">my_counts</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">tau</span><span class="p">)</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">tau2</span><span class="p">)))</span>
    <span class="n">comm</span><span class="o">.</span><span class="n">Allgatherv</span><span class="p">(</span><span class="n">my_wslen</span><span class="p">,</span> <span class="p">(</span><span class="n">wslen</span><span class="p">,</span> <span class="n">my_counts</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">tau</span><span class="p">)</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">tau2</span><span class="p">)))</span>

    <span class="c1"># (see cdef _p_message message_vector in mpi4py/src/mpi4py/MPI/msgbuffer.pxi</span>
    <span class="c1"># for possible formats of second argument &#39;recvbuf&#39;)</span>

    <span class="k">return</span> <span class="n">irvec</span><span class="p">,</span> <span class="n">ndegen</span><span class="p">,</span> <span class="n">wslen</span></div>


<div class="viewcode-block" id="short_range_model">
<a class="viewcode-back" href="../../modules/bravais.html#elphmod.bravais.short_range_model">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">short_range_model</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">at</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">sgn</span><span class="o">=+</span><span class="mi">1</span><span class="p">,</span> <span class="n">divide_ndegen</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Map hoppings or force constants onto Wigner-Seitz cell.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : ndarray</span>
<span class="sd">        Hoppings or force constants on (positive) Fourier-transform mesh. The</span>
<span class="sd">        first two dimensions correspond to the orbitals or atoms, the following</span>
<span class="sd">        three to the mesh axes, and the last two (optional, relevant for force</span>
<span class="sd">        constants only) to Cartesian directions.</span>
<span class="sd">    at : ndarray</span>
<span class="sd">        Bravais lattice vectors.</span>
<span class="sd">    tau : ndarray</span>
<span class="sd">        Positions of basis orbitals or atoms.</span>
<span class="sd">    sgn : int</span>
<span class="sd">        Do the lattice vectors shift the first (``-1``) or second (``+1``)</span>
<span class="sd">        orbital/atom?</span>
<span class="sd">    divide_ndegen : bool</span>
<span class="sd">        Divide hoppings for force constants by lattice-vector degeneracy?</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    irvec : ndarray</span>
<span class="sd">        Wigner-Seitz lattice vectors.</span>
<span class="sd">    const : ndarray</span>
<span class="sd">        Corresponding hoppings or force constants.</span>
<span class="sd">    wslen : ndarray</span>
<span class="sd">        Corresponding lengths.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">while</span> <span class="n">data</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;</span> <span class="mi">7</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>

    <span class="n">nbasis</span><span class="p">,</span> <span class="n">nbasis</span><span class="p">,</span> <span class="n">nr1</span><span class="p">,</span> <span class="n">nr2</span><span class="p">,</span> <span class="n">nr3</span><span class="p">,</span> <span class="n">ncart</span><span class="p">,</span> <span class="n">ncart</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span>

    <span class="n">irvec</span><span class="p">,</span> <span class="n">ndegen</span><span class="p">,</span> <span class="n">wslen</span> <span class="o">=</span> <span class="n">wigner</span><span class="p">(</span><span class="n">nr1</span><span class="p">,</span> <span class="n">nr2</span><span class="p">,</span> <span class="n">nr3</span><span class="p">,</span> <span class="n">at</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">sgn</span><span class="o">=</span><span class="n">sgn</span><span class="p">)</span>

    <span class="n">sizes</span><span class="p">,</span> <span class="n">bounds</span> <span class="o">=</span> <span class="n">elphmod</span><span class="o">.</span><span class="n">MPI</span><span class="o">.</span><span class="n">distribute</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">irvec</span><span class="p">),</span> <span class="n">bounds</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="n">my_const</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">sizes</span><span class="p">[</span><span class="n">comm</span><span class="o">.</span><span class="n">rank</span><span class="p">],</span> <span class="n">nbasis</span> <span class="o">*</span> <span class="n">ncart</span><span class="p">,</span> <span class="n">nbasis</span> <span class="o">*</span> <span class="n">ncart</span><span class="p">),</span>
        <span class="n">dtype</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">my_n</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="o">*</span><span class="n">bounds</span><span class="p">[</span><span class="n">comm</span><span class="o">.</span><span class="n">rank</span><span class="p">:</span><span class="n">comm</span><span class="o">.</span><span class="n">rank</span> <span class="o">+</span> <span class="mi">2</span><span class="p">])):</span>
        <span class="n">m1</span> <span class="o">=</span> <span class="n">sgn</span> <span class="o">*</span> <span class="n">irvec</span><span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">%</span> <span class="n">nr1</span>
        <span class="n">m2</span> <span class="o">=</span> <span class="n">sgn</span> <span class="o">*</span> <span class="n">irvec</span><span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">%</span> <span class="n">nr2</span>
        <span class="n">m3</span> <span class="o">=</span> <span class="n">sgn</span> <span class="o">*</span> <span class="n">irvec</span><span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">%</span> <span class="n">nr3</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nbasis</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nbasis</span><span class="p">):</span>
                <span class="n">tmp</span> <span class="o">=</span> <span class="n">my_const</span><span class="p">[</span><span class="n">my_n</span><span class="p">,</span>
                    <span class="n">i</span> <span class="o">*</span> <span class="n">ncart</span><span class="p">:(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">ncart</span><span class="p">,</span>
                    <span class="n">j</span> <span class="o">*</span> <span class="n">ncart</span><span class="p">:(</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">ncart</span><span class="p">]</span>

                <span class="n">tmp</span><span class="p">[:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">m1</span><span class="p">,</span> <span class="n">m2</span><span class="p">,</span> <span class="n">m3</span><span class="p">]</span>

                <span class="k">if</span> <span class="n">divide_ndegen</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">ndegen</span><span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]:</span>
                        <span class="n">tmp</span> <span class="o">/=</span> <span class="n">ndegen</span><span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">tmp</span><span class="p">[:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">0.0</span>

    <span class="n">const</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">irvec</span><span class="p">),</span> <span class="n">nbasis</span> <span class="o">*</span> <span class="n">ncart</span><span class="p">,</span> <span class="n">nbasis</span> <span class="o">*</span> <span class="n">ncart</span><span class="p">),</span>
        <span class="n">dtype</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

    <span class="n">comm</span><span class="o">.</span><span class="n">Allgatherv</span><span class="p">(</span><span class="n">my_const</span><span class="p">,</span> <span class="p">(</span><span class="n">const</span><span class="p">,</span> <span class="n">comm</span><span class="o">.</span><span class="n">allgather</span><span class="p">(</span><span class="n">my_const</span><span class="o">.</span><span class="n">size</span><span class="p">)))</span>

    <span class="k">return</span> <span class="n">irvec</span><span class="p">,</span> <span class="n">const</span><span class="p">,</span> <span class="n">wslen</span></div>


<div class="viewcode-block" id="Fourier_interpolation">
<a class="viewcode-back" href="../../modules/bravais.html#elphmod.bravais.Fourier_interpolation">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">Fourier_interpolation</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">angle</span><span class="o">=</span><span class="mi">60</span><span class="p">,</span> <span class="n">sign</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">function</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Perform Fourier interpolation on triangular or rectangular lattice.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : ndarray</span>
<span class="sd">        Data on uniform triangular or rectangular lattice.</span>
<span class="sd">    angle : number</span>
<span class="sd">        Angle between lattice vectors in degrees.</span>
<span class="sd">    sign : number</span>
<span class="sd">        Sign in exponential function in first Fourier transform.</span>
<span class="sd">    function : bool</span>
<span class="sd">        Return interpolation function or parameter dictionary?</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    function</span>
<span class="sd">        Interpolant for `data`. ``Fourier_interpolation(data)(i, j)`` yields</span>
<span class="sd">        the same value as ``data[i, j]``. Thus the data array is &quot;generalized&quot;</span>
<span class="sd">        with respect to fractional indices.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    linear_interpolation : Alternative interpolation routine.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">N</span><span class="p">,</span> <span class="n">N</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>

    <span class="c1"># do first Fourier transform to obtain coefficients:</span>

    <span class="n">i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>

    <span class="n">transform</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">sign</span> <span class="o">*</span> <span class="mi">2</span><span class="n">j</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="n">N</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span> <span class="o">/</span> <span class="n">N</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ni,ij...,jm-&gt;nm...&#39;</span><span class="p">,</span> <span class="n">transform</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">transform</span><span class="p">)</span>

    <span class="c1"># construct smooth inverse transform (formally tight-binding model):</span>

    <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">N</span> <span class="o">*</span> <span class="n">N</span> <span class="o">*</span> <span class="mi">4</span><span class="p">,</span> <span class="o">*</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">:]),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
    <span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">N</span> <span class="o">*</span> <span class="n">N</span> <span class="o">*</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">N</span> <span class="o">*</span> <span class="n">N</span> <span class="o">*</span> <span class="mi">4</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

    <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">])</span> <span class="o">&lt;</span> <span class="mf">1e-6</span><span class="p">):</span>
                <span class="k">continue</span>

            <span class="n">images</span> <span class="o">=</span> <span class="n">to_Voronoi</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">angle</span><span class="o">=</span><span class="mi">180</span> <span class="o">-</span> <span class="n">angle</span><span class="p">)</span>

            <span class="c1"># angle transform: from real to reciprocal lattice or vice versa</span>

            <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="n">images</span><span class="p">:</span>
                <span class="n">values</span><span class="p">[</span><span class="n">count</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">]</span>
                <span class="n">points</span><span class="p">[</span><span class="n">count</span><span class="p">]</span> <span class="o">=</span> <span class="n">point</span>
                <span class="n">counts</span><span class="p">[</span><span class="n">count</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">images</span><span class="p">)</span>
                <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="n">values</span> <span class="o">=</span> <span class="n">values</span><span class="p">[:</span><span class="n">count</span><span class="p">]</span>
    <span class="n">points</span> <span class="o">=</span> <span class="n">points</span><span class="p">[:</span><span class="n">count</span><span class="p">]</span>
    <span class="n">counts</span> <span class="o">=</span> <span class="n">counts</span><span class="p">[:</span><span class="n">count</span><span class="p">]</span>

    <span class="c1"># fix weights of interpolation coefficients:</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">count</span><span class="p">):</span>
        <span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/=</span> <span class="n">counts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

    <span class="c1"># define interpolation function and generalize is with respect to arrays:</span>

    <span class="n">idphi</span> <span class="o">=</span> <span class="o">-</span><span class="n">sign</span> <span class="o">*</span> <span class="mi">2</span><span class="n">j</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="n">N</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">interpolant</span><span class="p">(</span><span class="o">*</span><span class="n">point</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">idphi</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">point</span><span class="p">)),</span> <span class="n">values</span><span class="p">)</span><span class="o">.</span><span class="n">real</span>

    <span class="k">if</span> <span class="n">function</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vectorize</span><span class="p">(</span><span class="n">interpolant</span><span class="p">)</span>

    <span class="c1"># return either interpolation function or parameter dictionary:</span>

    <span class="k">return</span> <span class="nb">dict</span><span class="p">((</span><span class="nb">tuple</span><span class="p">(</span><span class="n">point</span><span class="p">),</span> <span class="n">value</span><span class="p">)</span> <span class="k">for</span> <span class="n">point</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">values</span><span class="p">))</span></div>


<div class="viewcode-block" id="path">
<a class="viewcode-back" href="../../modules/bravais.html#elphmod.bravais.path">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">path</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span> <span class="n">recvec</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">qe</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">moveG</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Generate arbitrary path through Brillouin zone.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    points : ndarray</span>
<span class="sd">        List of high-symmetry points in crystal coordinates. Some well-known</span>
<span class="sd">        labels such as ``G`` (|Ggr|), ``M``, or ``K`` may also be used. Mostly,</span>
<span class="sd">        the definitions follow https://lampx.tugraz.at/~hadley/ss1/bzones/.</span>
<span class="sd">    N : float</span>
<span class="sd">        Number of points per :math:`2 \pi / a`.</span>
<span class="sd">    recvec : ndarray, optional</span>
<span class="sd">        List of reciprocal lattice vectors.</span>
<span class="sd">    qe : bool, default False</span>
<span class="sd">        Also return path in QE input format?</span>
<span class="sd">    moveG : float, default 0</span>
<span class="sd">        Move Gamma point to the closest nonzero point multiplied by this value.</span>
<span class="sd">        This is useful, e.g., to plot phonon dispersions with TO-LO splitting.</span>
<span class="sd">    **kwargs</span>
<span class="sd">        Arguments passed to :func:`primitives`, e.g., parameters from</span>
<span class="sd">        &#39;func&#39;`read_pwi`, particularly the Bravais-lattice index `ibrav`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ndarray</span>
<span class="sd">        Points in crystal coordinates with period :math:`2 \pi`.</span>
<span class="sd">    ndarray</span>
<span class="sd">        Cumulative path distance.</span>
<span class="sd">    list</span>
<span class="sd">        Indices of corner/high-symmetry points.</span>
<span class="sd">    dict, optional</span>
<span class="sd">        Path in format suitable for :func:`write_pwi`.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    primitives</span>
<span class="sd">    reciprocals</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">labels</span> <span class="o">=</span> <span class="p">{</span>
        <span class="mi">1</span><span class="p">:</span> <span class="p">{</span> <span class="c1"># cubic (sc)</span>
            <span class="s1">&#39;M&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span>
            <span class="s1">&#39;R&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span>
            <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span>
            <span class="p">},</span>
        <span class="mi">2</span><span class="p">:</span> <span class="p">{</span> <span class="c1"># cubic (fcc)</span>
            <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span>
            <span class="s1">&#39;L&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span>
            <span class="s1">&#39;W&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span>
            <span class="s1">&#39;U&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.625</span><span class="p">,</span> <span class="mf">0.625</span><span class="p">],</span>
            <span class="s1">&#39;K&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.375</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">,</span> <span class="mf">0.375</span><span class="p">],</span>
            <span class="p">},</span>
        <span class="mi">3</span><span class="p">:</span> <span class="p">{</span> <span class="c1"># cubic (bcc) (*)</span>
            <span class="s1">&#39;H&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span>
            <span class="s1">&#39;P&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.75</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.25</span><span class="p">],</span>
            <span class="s1">&#39;N&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>
            <span class="p">},</span>
        <span class="o">-</span><span class="mi">3</span><span class="p">:</span> <span class="p">{</span> <span class="c1"># cubic (bcc, more symmetric axis)</span>
            <span class="s1">&#39;H&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">],</span>
            <span class="s1">&#39;P&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">],</span>
            <span class="s1">&#39;N&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>
            <span class="p">},</span>
        <span class="mi">4</span><span class="p">:</span> <span class="p">{</span> <span class="c1"># hexagonal &amp; trigonal</span>
            <span class="s1">&#39;A&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span>
            <span class="s1">&#39;M&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>
            <span class="s1">&#39;L&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span>
            <span class="s1">&#39;K&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span> <span class="o">/</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span> <span class="o">/</span> <span class="mi">3</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>
            <span class="s1">&#39;H&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span> <span class="o">/</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span> <span class="o">/</span> <span class="mi">3</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span>
            <span class="p">},</span>
        <span class="mi">6</span><span class="p">:</span> <span class="p">{</span> <span class="c1"># tetragonal (st)</span>
            <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>
            <span class="s1">&#39;M&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>
            <span class="s1">&#39;Z&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span>
            <span class="s1">&#39;R&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span>
            <span class="s1">&#39;A&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span>
            <span class="p">},</span>
        <span class="mi">7</span><span class="p">:</span> <span class="p">{</span> <span class="c1"># tetragonal (bct) (generated from 6)</span>
            <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.25</span><span class="p">],</span>
            <span class="s1">&#39;M&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.00</span><span class="p">,</span> <span class="mf">0.50</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.50</span><span class="p">],</span>
            <span class="s1">&#39;Z&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">],</span>
            <span class="s1">&#39;R&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.50</span><span class="p">,</span> <span class="mf">0.50</span><span class="p">,</span> <span class="mf">0.00</span><span class="p">],</span>
            <span class="s1">&#39;A&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.25</span><span class="p">],</span>
            <span class="p">},</span>
        <span class="mi">8</span><span class="p">:</span> <span class="p">{</span> <span class="c1"># orthorhombic</span>
            <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>
            <span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>
            <span class="s1">&#39;Z&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span>
            <span class="s1">&#39;S&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>
            <span class="s1">&#39;T&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span>
            <span class="s1">&#39;U&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span>
            <span class="s1">&#39;R&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span>
            <span class="p">},</span>
        <span class="mi">9</span><span class="p">:</span> <span class="p">{</span> <span class="c1"># orthorhombic (bco) (*)</span>
            <span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>
            <span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>
            <span class="s1">&#39;Z&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span>
            <span class="s1">&#39;T&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span>
            <span class="s1">&#39;t&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span>
            <span class="s1">&#39;S&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>
            <span class="s1">&#39;R&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span>
            <span class="p">},</span>
        <span class="o">-</span><span class="mi">9</span><span class="p">:</span> <span class="p">{</span> <span class="c1"># orthorhombic (bco, alternate description)</span>
            <span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>
            <span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="p">[</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>
            <span class="s1">&#39;Z&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span>
            <span class="s1">&#39;T&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span>
            <span class="s1">&#39;t&#39;</span><span class="p">:</span> <span class="p">[</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span>
            <span class="s1">&#39;S&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>
            <span class="s1">&#39;R&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span>
            <span class="p">},</span>
        <span class="mi">12</span><span class="p">:</span> <span class="p">{</span> <span class="c1"># monoclinic (unique axis c) (*)</span>
            <span class="s1">&#39;B&#39;</span><span class="p">:</span> <span class="p">[</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>
            <span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>
            <span class="s1">&#39;Z&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span>
            <span class="s1">&#39;D&#39;</span><span class="p">:</span> <span class="p">[</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>
            <span class="s1">&#39;C&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span>
            <span class="s1">&#39;A&#39;</span><span class="p">:</span> <span class="p">[</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span>
            <span class="s1">&#39;E&#39;</span><span class="p">:</span> <span class="p">[</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span>
            <span class="p">},</span>
        <span class="o">-</span><span class="mi">12</span><span class="p">:</span> <span class="p">{</span> <span class="c1"># monoclinic (unique axis b)</span>
            <span class="s1">&#39;B&#39;</span><span class="p">:</span> <span class="p">[</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>
            <span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>
            <span class="s1">&#39;Z&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span>
            <span class="s1">&#39;D&#39;</span><span class="p">:</span> <span class="p">[</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>
            <span class="s1">&#39;C&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span>
            <span class="s1">&#39;A&#39;</span><span class="p">:</span> <span class="p">[</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span>
            <span class="s1">&#39;E&#39;</span><span class="p">:</span> <span class="p">[</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span>
            <span class="p">},</span>
        <span class="p">}</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;ibrav&#39;</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span> <span class="p">{})</span>

    <span class="c1"># (*) generated from points for Bravais lattice with index of opposite sign</span>
    <span class="c1"># through X&#39;[k] = X[i] b[i, j] a&#39;[k, j], where b are the reciprocals of a.</span>

    <span class="n">labels</span><span class="p">[</span><span class="s1">&#39;G&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">]</span>

    <span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">labels</span><span class="p">[</span><span class="n">point</span><span class="p">]</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">else</span> <span class="n">point</span>
        <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="n">points</span><span class="p">])</span>

    <span class="k">if</span> <span class="n">recvec</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">primitives</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">reciprocals</span><span class="p">(</span><span class="o">*</span><span class="n">a</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">recvec</span>

    <span class="n">points_cart</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;kc,cx-&gt;kx&#39;</span><span class="p">,</span> <span class="n">points</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>

    <span class="n">k</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">x</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">corners</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">x0</span> <span class="o">=</span> <span class="mf">0.0</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">dx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">points_cart</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">points_cart</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">N</span> <span class="o">*</span> <span class="n">dx</span><span class="p">)))</span>

        <span class="n">x1</span> <span class="o">=</span> <span class="n">x0</span> <span class="o">+</span> <span class="n">dx</span>

        <span class="n">j0</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">moveG</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">else</span> <span class="mi">1</span>

        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">j0</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">k</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">j</span> <span class="o">*</span> <span class="n">points</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">j</span><span class="p">)</span> <span class="o">*</span> <span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">/</span> <span class="n">n</span><span class="p">)</span>
            <span class="n">x</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">j</span> <span class="o">*</span> <span class="n">x1</span> <span class="o">+</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">j</span><span class="p">)</span> <span class="o">*</span> <span class="n">x0</span><span class="p">)</span> <span class="o">/</span> <span class="n">n</span><span class="p">)</span>

        <span class="n">x0</span> <span class="o">=</span> <span class="n">x1</span>

        <span class="n">corners</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">moveG</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">k</span><span class="p">[</span><span class="n">corners</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">+=</span> <span class="n">moveG</span> <span class="o">*</span> <span class="n">k</span><span class="p">[</span><span class="n">corners</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">k</span><span class="p">[</span><span class="n">corners</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">+=</span> <span class="n">moveG</span> <span class="o">*</span> <span class="n">k</span><span class="p">[</span><span class="n">corners</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>

                    <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">corners</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">k</span><span class="p">[</span><span class="n">corners</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">moveG</span> <span class="o">*</span> <span class="n">k</span><span class="p">[</span><span class="n">corners</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">qe</span><span class="p">:</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;ktyp&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;crystal_b&#39;</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;nks&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">corners</span><span class="p">)</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;k_points&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">corners</span><span class="p">),</span> <span class="mi">4</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">corners</span><span class="p">)):</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;k_points&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">k</span><span class="p">[</span><span class="n">corners</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;k_points&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">corners</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">corners</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;k_points&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">return</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">k</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">corners</span><span class="p">,</span> <span class="n">kwargs</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">k</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">corners</span></div>


<div class="viewcode-block" id="GMKG">
<a class="viewcode-back" href="../../modules/bravais.html#elphmod.bravais.GMKG">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">GMKG</span><span class="p">(</span><span class="n">N</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span> <span class="n">corner_indices</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">mesh</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">angle</span><span class="o">=</span><span class="mi">60</span><span class="p">,</span> <span class="n">straight</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">lift_degen</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Generate path |Ggr|-M-K-|Ggr| through Brillouin zone.</span>

<span class="sd">    (This function should be replaced by a more general one to produce arbitrary</span>
<span class="sd">    paths through both triangular and rectangular Brillouin zones, where special</span>
<span class="sd">    points can be defined using labels such as ``&#39;G&#39;``, ``&#39;M&#39;``, or ``&#39;K&#39;``.)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    N : int</span>
<span class="sd">        Number of mesh points per dimension if `mesh` is ``True`` and `N` is a</span>
<span class="sd">        multiple of 6. Otherwise the number of points per :math:`2 \pi / a`.</span>
<span class="sd">    corner_indices : bool</span>
<span class="sd">        Return indices of corner/high-symmetry points?</span>
<span class="sd">    mesh : bool</span>
<span class="sd">        Return points of uniform mesh that exactly lie on the path? If ``True``,</span>
<span class="sd">        `N` must be a multiple of 6.</span>
<span class="sd">    angle : number</span>
<span class="sd">        Angle between reciprocal basis lattice vectors.</span>
<span class="sd">    straight : bool</span>
<span class="sd">        Cross K in a straight line? In this case, the path does not enclose the</span>
<span class="sd">        irreducible wedge.</span>
<span class="sd">    lift_degen : bool</span>
<span class="sd">        Lift degeneracy at K by infinitesimal shift toward |Ggr|?</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ndarray</span>
<span class="sd">        Points in crystal coordinates with period :math:`2 \pi`.</span>
<span class="sd">    ndarray</span>
<span class="sd">        Cumulative path distance.</span>
<span class="sd">    list, optional</span>
<span class="sd">        Indices of corner/high-symmetry points.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">G</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">])</span>
    <span class="n">M</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">])</span> <span class="o">/</span> <span class="mi">2</span>

    <span class="k">if</span> <span class="n">angle</span> <span class="o">==</span> <span class="mi">60</span><span class="p">:</span>
        <span class="n">K</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">])</span> <span class="o">/</span> <span class="mi">3</span>
        <span class="n">k</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mf">2.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">])</span> <span class="o">/</span> <span class="mi">3</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="n">K</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span> <span class="mf">1.0</span><span class="p">,</span>  <span class="mf">2.0</span><span class="p">])</span> <span class="o">/</span> <span class="mi">3</span>
        <span class="n">k</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mf">2.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">])</span> <span class="o">/</span> <span class="mi">3</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">straight</span><span class="p">:</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">K</span>

    <span class="k">if</span> <span class="n">lift_degen</span><span class="p">:</span>
        <span class="n">shrink</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="mf">1e-10</span>

        <span class="n">k</span> <span class="o">*=</span> <span class="n">shrink</span>
        <span class="n">K</span> <span class="o">*=</span> <span class="n">shrink</span>

    <span class="n">L1</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">L2</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="mi">3</span>
    <span class="n">L3</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">/</span> <span class="mi">3</span>

    <span class="k">if</span> <span class="n">mesh</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">N</span> <span class="o">%</span> <span class="mi">6</span><span class="p">:</span> <span class="c1"># use only points of N x N mesh</span>
        <span class="n">N1</span> <span class="o">=</span> <span class="n">N</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="n">N2</span> <span class="o">=</span> <span class="n">N</span> <span class="o">//</span> <span class="mi">6</span>
        <span class="n">N3</span> <span class="o">=</span> <span class="n">N</span> <span class="o">//</span> <span class="mi">3</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">N1</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">N</span> <span class="o">*</span> <span class="n">L1</span><span class="p">))</span>
        <span class="n">N2</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">N</span> <span class="o">*</span> <span class="n">L2</span><span class="p">))</span>
        <span class="n">N3</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">N</span> <span class="o">*</span> <span class="n">L3</span><span class="p">))</span>

    <span class="n">N3</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">line</span><span class="p">(</span><span class="n">k1</span><span class="p">,</span> <span class="n">k2</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="n">q1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">k1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">k2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">N</span><span class="p">,</span> <span class="n">endpoint</span><span class="p">)</span>
        <span class="n">q2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">k1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">k2</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">N</span><span class="p">,</span> <span class="n">endpoint</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">q1</span><span class="p">,</span> <span class="n">q2</span><span class="p">))</span>

    <span class="n">path</span> <span class="o">=</span> <span class="n">line</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">N1</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span> \
         <span class="o">+</span> <span class="n">line</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">K</span><span class="p">,</span> <span class="n">N2</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span> \
         <span class="o">+</span> <span class="n">line</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">N3</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>

    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">N1</span> <span class="o">+</span> <span class="n">N2</span> <span class="o">+</span> <span class="n">N3</span><span class="p">)</span>

    <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">N1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">L1</span><span class="p">,</span> <span class="n">N1</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
    <span class="n">x</span><span class="p">[</span><span class="n">N1</span><span class="p">:</span><span class="n">N1</span> <span class="o">+</span> <span class="n">N2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">L1</span><span class="p">,</span> <span class="n">L1</span> <span class="o">+</span> <span class="n">L2</span><span class="p">,</span> <span class="n">N2</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
    <span class="n">x</span><span class="p">[</span><span class="n">N2</span> <span class="o">+</span> <span class="n">N1</span><span class="p">:</span><span class="n">N1</span> <span class="o">+</span> <span class="n">N2</span> <span class="o">+</span> <span class="n">N3</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">L2</span> <span class="o">+</span> <span class="n">L1</span><span class="p">,</span> <span class="n">L1</span> <span class="o">+</span> <span class="n">L2</span> <span class="o">+</span> <span class="n">L3</span><span class="p">,</span> <span class="n">N3</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">corner_indices</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">path</span><span class="p">),</span> <span class="n">x</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">N1</span><span class="p">,</span> <span class="n">N1</span> <span class="o">+</span> <span class="n">N2</span><span class="p">,</span> <span class="n">N1</span> <span class="o">+</span> <span class="n">N2</span> <span class="o">+</span> <span class="n">N3</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">path</span><span class="p">),</span> <span class="n">x</span></div>


<div class="viewcode-block" id="BZ">
<a class="viewcode-back" href="../../modules/bravais.html#elphmod.bravais.BZ">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">BZ</span><span class="p">(</span><span class="n">angle</span><span class="o">=</span><span class="mi">120</span><span class="p">,</span> <span class="n">angle0</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Draw Brillouin zone outline.&quot;&quot;&quot;</span>

    <span class="n">a1</span><span class="p">,</span> <span class="n">a2</span> <span class="o">=</span> <span class="n">translations</span><span class="p">(</span><span class="n">angle</span><span class="o">=</span><span class="n">angle</span><span class="p">,</span> <span class="n">angle0</span><span class="o">=</span><span class="n">angle0</span><span class="p">)</span>
    <span class="n">b1</span><span class="p">,</span> <span class="n">b2</span> <span class="o">=</span> <span class="n">reciprocals</span><span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">angle</span> <span class="o">==</span> <span class="mi">60</span><span class="p">:</span>
        <span class="n">K</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)]</span>
        <span class="n">outline</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">k1</span> <span class="o">*</span> <span class="n">b1</span> <span class="o">+</span> <span class="n">k2</span> <span class="o">*</span> <span class="n">b2</span> <span class="k">for</span> <span class="n">k1</span><span class="p">,</span> <span class="n">k2</span> <span class="ow">in</span> <span class="n">K</span><span class="p">])</span> <span class="o">/</span> <span class="mi">3</span>

    <span class="k">elif</span> <span class="n">angle</span> <span class="o">==</span> <span class="mi">90</span><span class="p">:</span>
        <span class="n">M</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]</span>
        <span class="n">outline</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">k1</span> <span class="o">*</span> <span class="n">b1</span> <span class="o">+</span> <span class="n">k2</span> <span class="o">*</span> <span class="n">b2</span> <span class="k">for</span> <span class="n">k1</span><span class="p">,</span> <span class="n">k2</span> <span class="ow">in</span> <span class="n">M</span><span class="p">])</span>

    <span class="k">elif</span> <span class="n">angle</span> <span class="o">==</span> <span class="mi">120</span><span class="p">:</span>
        <span class="n">K</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]</span>
        <span class="n">outline</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">k1</span> <span class="o">*</span> <span class="n">b1</span> <span class="o">+</span> <span class="n">k2</span> <span class="o">*</span> <span class="n">b2</span> <span class="k">for</span> <span class="n">k1</span><span class="p">,</span> <span class="n">k2</span> <span class="ow">in</span> <span class="n">K</span><span class="p">])</span> <span class="o">/</span> <span class="mi">3</span>

    <span class="k">return</span> <span class="n">outline</span></div>


<div class="viewcode-block" id="read_pwi">
<a class="viewcode-back" href="../../modules/bravais.html#elphmod.bravais.read_pwi">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">read_pwi</span><span class="p">(</span><span class="n">pwi</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Read input data and crystal structure from PWscf input file.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    pwi : str</span>
<span class="sd">        Filename.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dict</span>
<span class="sd">        Input data and crystal structure.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">struct</span> <span class="o">=</span> <span class="n">elphmod</span><span class="o">.</span><span class="n">misc</span><span class="o">.</span><span class="n">read_input_data</span><span class="p">(</span><span class="n">pwi</span><span class="p">,</span> <span class="n">broadcast</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">comm</span><span class="o">.</span><span class="n">rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;celldm&#39;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">struct</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">struct</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="nb">list</span><span class="p">):</span>
                <span class="n">struct</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">struct</span><span class="p">[</span><span class="n">key</span><span class="p">]]</span>

        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">pwi</span><span class="p">)</span> <span class="k">as</span> <span class="n">lines</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">lines</span><span class="p">:</span>
                <span class="n">words</span> <span class="o">=</span> <span class="p">[</span><span class="n">word</span> <span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()</span> <span class="k">if</span> <span class="n">word</span><span class="p">]</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="n">words</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="n">key</span> <span class="o">=</span> <span class="n">words</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>

                <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="s1">&#39;atomic_species&#39;</span><span class="p">:</span>
                    <span class="n">struct</span><span class="p">[</span><span class="s1">&#39;at_species&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="n">struct</span><span class="p">[</span><span class="s1">&#39;mass&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="n">struct</span><span class="p">[</span><span class="s1">&#39;pp&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

                    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">struct</span><span class="p">[</span><span class="s1">&#39;ntyp&#39;</span><span class="p">]):</span>
                        <span class="n">words</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>

                        <span class="n">struct</span><span class="p">[</span><span class="s1">&#39;at_species&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">words</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                        <span class="n">struct</span><span class="p">[</span><span class="s1">&#39;mass&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">words</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
                        <span class="n">struct</span><span class="p">[</span><span class="s1">&#39;pp&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">words</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>

                <span class="k">elif</span> <span class="n">key</span> <span class="o">==</span> <span class="s1">&#39;atomic_positions&#39;</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">words</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">struct</span><span class="p">[</span><span class="s1">&#39;coords&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;alat&#39;</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">struct</span><span class="p">[</span><span class="s1">&#39;coords&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">words</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
                            <span class="k">if</span> <span class="n">c</span> <span class="ow">not</span> <span class="ow">in</span> <span class="s1">&#39;{ }&#39;</span><span class="p">)</span>

                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Read crystal structure in units &#39;</span><span class="si">%s</span><span class="s2">&#39;&quot;</span>
                        <span class="o">%</span> <span class="n">struct</span><span class="p">[</span><span class="s1">&#39;coords&#39;</span><span class="p">])</span>

                    <span class="n">struct</span><span class="p">[</span><span class="s1">&#39;at&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

                    <span class="k">if</span> <span class="s1">&#39;crystal_sg&#39;</span> <span class="ow">in</span> <span class="n">struct</span><span class="p">[</span><span class="s1">&#39;coords&#39;</span><span class="p">]:</span>
                        <span class="n">struct</span><span class="p">[</span><span class="s1">&#39;r&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">struct</span><span class="p">[</span><span class="s1">&#39;r&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">struct</span><span class="p">[</span><span class="s1">&#39;nat&#39;</span><span class="p">],</span> <span class="mi">3</span><span class="p">))</span>

                    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">struct</span><span class="p">[</span><span class="s1">&#39;nat&#39;</span><span class="p">]):</span>
                        <span class="n">words</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>

                        <span class="n">struct</span><span class="p">[</span><span class="s1">&#39;at&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">words</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

                        <span class="k">if</span> <span class="s1">&#39;crystal_sg&#39;</span> <span class="ow">in</span> <span class="n">struct</span><span class="p">[</span><span class="s1">&#39;coords&#39;</span><span class="p">]:</span>
                            <span class="n">struct</span><span class="p">[</span><span class="s1">&#39;r&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">words</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
                                <span class="n">struct</span><span class="p">[</span><span class="s1">&#39;r&#39;</span><span class="p">][</span><span class="n">n</span><span class="p">,</span> <span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">words</span><span class="p">[</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span><span class="p">])</span>

                <span class="k">elif</span> <span class="n">key</span> <span class="o">==</span> <span class="s1">&#39;k_points&#39;</span><span class="p">:</span>
                    <span class="n">struct</span><span class="p">[</span><span class="s1">&#39;ktyp&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">words</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>

                    <span class="k">if</span> <span class="s1">&#39;automatic&#39;</span> <span class="ow">in</span> <span class="n">struct</span><span class="p">[</span><span class="s1">&#39;ktyp&#39;</span><span class="p">]:</span>
                        <span class="n">struct</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">next</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">()[:</span><span class="mi">6</span><span class="p">]))</span>
                    <span class="k">elif</span> <span class="s1">&#39;gamma&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">struct</span><span class="p">[</span><span class="s1">&#39;ktyp&#39;</span><span class="p">]:</span>
                        <span class="n">struct</span><span class="p">[</span><span class="s1">&#39;nks&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">lines</span><span class="p">))</span>
                        <span class="n">struct</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">struct</span><span class="p">[</span><span class="s1">&#39;nks&#39;</span><span class="p">],</span> <span class="mi">4</span><span class="p">))</span>

                        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">struct</span><span class="p">[</span><span class="s1">&#39;nks&#39;</span><span class="p">]):</span>
                            <span class="n">struct</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span>
                                <span class="nb">next</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">()[:</span><span class="mi">4</span><span class="p">]))</span>

                <span class="k">elif</span> <span class="n">key</span> <span class="o">==</span> <span class="s1">&#39;cell_parameters&#39;</span><span class="p">:</span>
                    <span class="n">struct</span><span class="p">[</span><span class="s1">&#39;r_cell&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>

                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">words</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">struct</span><span class="p">[</span><span class="s1">&#39;cell_units&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;bohr&#39;</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">struct</span><span class="p">[</span><span class="s1">&#39;cell_units&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">words</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Read cell parameters in units &#39;</span><span class="si">%s</span><span class="s2">&#39;&quot;</span>
                        <span class="o">%</span> <span class="n">struct</span><span class="p">[</span><span class="s1">&#39;cell_units&#39;</span><span class="p">])</span>

                    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
                        <span class="n">words</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>

                        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
                            <span class="n">struct</span><span class="p">[</span><span class="s1">&#39;r_cell&#39;</span><span class="p">][</span><span class="n">n</span><span class="p">,</span> <span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">words</span><span class="p">[</span><span class="n">x</span><span class="p">])</span>

    <span class="n">struct</span> <span class="o">=</span> <span class="n">comm</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">struct</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">struct</span></div>


<div class="viewcode-block" id="write_pwi">
<a class="viewcode-back" href="../../modules/bravais.html#elphmod.bravais.write_pwi">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">write_pwi</span><span class="p">(</span><span class="n">pwi</span><span class="p">,</span> <span class="n">struct</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Write crystal structure to PWscf input file.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    pwi : str</span>
<span class="sd">        Filename.</span>
<span class="sd">    struct : dict</span>
<span class="sd">        Crystal structure.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">comm</span><span class="o">.</span><span class="n">rank</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span>

    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">pwi</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">data</span><span class="p">:</span>
        <span class="n">data</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;&amp;CONTROL</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;title&#39;</span><span class="p">,</span> <span class="s1">&#39;prefix&#39;</span><span class="p">,</span> <span class="s1">&#39;outdir&#39;</span><span class="p">,</span> <span class="s1">&#39;pseudo_dir&#39;</span><span class="p">,</span> <span class="s1">&#39;calculation&#39;</span><span class="p">,</span>
                <span class="s1">&#39;tprnfor&#39;</span><span class="p">,</span> <span class="s1">&#39;tstress&#39;</span><span class="p">,</span> <span class="s1">&#39;nstep&#39;</span><span class="p">,</span> <span class="s1">&#39;forc_conv_thr&#39;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">struct</span><span class="p">:</span>
                <span class="n">data</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> = </span><span class="si">%r</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">struct</span><span class="p">[</span><span class="n">key</span><span class="p">]))</span>

        <span class="n">data</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;/</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="n">data</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;&amp;SYSTEM</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="s1">&#39;celldm&#39;</span> <span class="ow">in</span> <span class="n">struct</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">celldm</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">struct</span><span class="p">[</span><span class="s1">&#39;celldm&#39;</span><span class="p">],</span> <span class="mi">1</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">celldm</span><span class="p">:</span>
                    <span class="n">data</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;celldm(</span><span class="si">%d</span><span class="s1">) = </span><span class="si">%r</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">celldm</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;ibrav&#39;</span><span class="p">,</span> <span class="s1">&#39;ntyp&#39;</span><span class="p">,</span> <span class="s1">&#39;nat&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;cosbc&#39;</span><span class="p">,</span> <span class="s1">&#39;cosac&#39;</span><span class="p">,</span>
                <span class="s1">&#39;cosab&#39;</span><span class="p">,</span> <span class="s1">&#39;ecutwfc&#39;</span><span class="p">,</span> <span class="s1">&#39;ecutrho&#39;</span><span class="p">,</span> <span class="s1">&#39;nbnd&#39;</span><span class="p">,</span> <span class="s1">&#39;occupations&#39;</span><span class="p">,</span>
                <span class="s1">&#39;smearing&#39;</span><span class="p">,</span> <span class="s1">&#39;degauss&#39;</span><span class="p">,</span> <span class="s1">&#39;nosym&#39;</span><span class="p">,</span> <span class="s1">&#39;noinv&#39;</span><span class="p">,</span> <span class="s1">&#39;tot_charge&#39;</span><span class="p">,</span>
                <span class="s1">&#39;assume_isolated&#39;</span><span class="p">,</span> <span class="s1">&#39;nspin&#39;</span><span class="p">,</span> <span class="s1">&#39;noncolin&#39;</span><span class="p">,</span> <span class="s1">&#39;lspinorb&#39;</span><span class="p">,</span>
                <span class="s1">&#39;tot_magnetization&#39;</span><span class="p">,</span> <span class="s1">&#39;starting_magnetization&#39;</span><span class="p">,</span> <span class="s1">&#39;space_group&#39;</span><span class="p">,</span>
                <span class="s1">&#39;uniqueb&#39;</span><span class="p">,</span> <span class="s1">&#39;origin_choice&#39;</span><span class="p">,</span> <span class="s1">&#39;rhombohedral&#39;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">struct</span><span class="p">:</span>
                <span class="n">data</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> = </span><span class="si">%r</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">struct</span><span class="p">[</span><span class="n">key</span><span class="p">]))</span>

        <span class="n">data</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;/</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="n">data</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;&amp;ELECTRONS</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;electron_maxstep&#39;</span><span class="p">,</span> <span class="s1">&#39;conv_thr&#39;</span><span class="p">,</span> <span class="s1">&#39;diagonalization&#39;</span><span class="p">,</span>
                <span class="s1">&#39;diago_full_acc&#39;</span><span class="p">,</span> <span class="s1">&#39;mixing_beta&#39;</span><span class="p">,</span> <span class="s1">&#39;startingpot&#39;</span><span class="p">,</span> <span class="s1">&#39;startingwfc&#39;</span><span class="p">,</span>
                <span class="s1">&#39;scf_must_converge&#39;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">struct</span><span class="p">:</span>
                <span class="n">data</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> = </span><span class="si">%r</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">struct</span><span class="p">[</span><span class="n">key</span><span class="p">]))</span>

        <span class="n">data</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;/</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">struct</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;calculation&#39;</span><span class="p">)</span> <span class="ow">in</span> <span class="p">{</span><span class="s1">&#39;relax&#39;</span><span class="p">,</span> <span class="s1">&#39;md&#39;</span><span class="p">,</span> <span class="s1">&#39;vc-relax&#39;</span><span class="p">,</span> <span class="s1">&#39;vc-md&#39;</span><span class="p">}:</span>
            <span class="n">data</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;&amp;IONS</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;ion_dynamics&#39;</span><span class="p">,</span> <span class="s1">&#39;upscale&#39;</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">struct</span><span class="p">:</span>
                    <span class="n">data</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> = </span><span class="si">%r</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">struct</span><span class="p">[</span><span class="n">key</span><span class="p">]))</span>

            <span class="n">data</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;/</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">struct</span><span class="p">[</span><span class="s1">&#39;calculation&#39;</span><span class="p">]</span> <span class="ow">in</span> <span class="p">{</span><span class="s1">&#39;vc-relax&#39;</span><span class="p">,</span> <span class="s1">&#39;vc-md&#39;</span><span class="p">}:</span>
                <span class="n">data</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;&amp;CELL</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>

                <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;cell_dynamics&#39;</span><span class="p">,</span> <span class="s1">&#39;cell_dofree&#39;</span><span class="p">,</span> <span class="s1">&#39;press&#39;</span><span class="p">,</span>
                        <span class="s1">&#39;press_conv_thr&#39;</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">struct</span><span class="p">:</span>
                        <span class="n">data</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> = </span><span class="si">%r</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">struct</span><span class="p">[</span><span class="n">key</span><span class="p">]))</span>

                <span class="n">data</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;/</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="n">data</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;ATOMIC_SPECIES</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">struct</span><span class="p">[</span><span class="s1">&#39;ntyp&#39;</span><span class="p">]):</span>
            <span class="n">data</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> </span><span class="si">%.12g</span><span class="s1"> </span><span class="si">%s</span><span class="se">\n</span><span class="s1">&#39;</span>
                <span class="o">%</span> <span class="p">(</span><span class="n">struct</span><span class="p">[</span><span class="s1">&#39;at_species&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">],</span> <span class="n">struct</span><span class="p">[</span><span class="s1">&#39;mass&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">],</span> <span class="n">struct</span><span class="p">[</span><span class="s1">&#39;pp&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]))</span>

        <span class="n">data</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="n">data</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;ATOMIC_POSITIONS </span><span class="si">%s</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">struct</span><span class="p">[</span><span class="s1">&#39;coords&#39;</span><span class="p">])</span>

        <span class="k">if</span> <span class="s1">&#39;crystal_sg&#39;</span> <span class="ow">in</span> <span class="n">struct</span><span class="p">[</span><span class="s1">&#39;coords&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">Xr</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">struct</span><span class="p">[</span><span class="s1">&#39;at&#39;</span><span class="p">],</span> <span class="n">struct</span><span class="p">[</span><span class="s1">&#39;r&#39;</span><span class="p">]):</span>
                <span class="n">data</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%2s</span><span class="s1"> </span><span class="si">%s</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">Xr</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">X</span><span class="p">,</span> <span class="p">(</span><span class="n">r1</span><span class="p">,</span> <span class="n">r2</span><span class="p">,</span> <span class="n">r3</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">struct</span><span class="p">[</span><span class="s1">&#39;at&#39;</span><span class="p">],</span> <span class="n">struct</span><span class="p">[</span><span class="s1">&#39;r&#39;</span><span class="p">]):</span>
                <span class="n">data</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%2s</span><span class="s1"> </span><span class="si">%12.9f</span><span class="s1"> </span><span class="si">%12.9f</span><span class="s1"> </span><span class="si">%12.9f</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">r1</span><span class="p">,</span> <span class="n">r2</span><span class="p">,</span> <span class="n">r3</span><span class="p">))</span>

        <span class="k">if</span> <span class="s1">&#39;ktyp&#39;</span> <span class="ow">in</span> <span class="n">struct</span><span class="p">:</span>
            <span class="n">data</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>

            <span class="n">data</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;K_POINTS </span><span class="si">%s</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">struct</span><span class="p">[</span><span class="s1">&#39;ktyp&#39;</span><span class="p">])</span>

            <span class="k">if</span> <span class="s1">&#39;automatic&#39;</span> <span class="ow">in</span> <span class="n">struct</span><span class="p">[</span><span class="s1">&#39;ktyp&#39;</span><span class="p">]:</span>
                <span class="n">data</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%d</span><span class="s1"> </span><span class="si">%d</span><span class="s1"> </span><span class="si">%d</span><span class="s1"> </span><span class="si">%d</span><span class="s1"> </span><span class="si">%d</span><span class="s1"> </span><span class="si">%d</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">struct</span><span class="p">[</span><span class="s1">&#39;k_points&#39;</span><span class="p">]))</span>
            <span class="k">elif</span> <span class="s1">&#39;gamma&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">struct</span><span class="p">[</span><span class="s1">&#39;ktyp&#39;</span><span class="p">]:</span>
                <span class="n">data</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%d</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">struct</span><span class="p">[</span><span class="s1">&#39;nks&#39;</span><span class="p">])</span>

                <span class="k">for</span> <span class="p">(</span><span class="n">kx</span><span class="p">,</span> <span class="n">ky</span><span class="p">,</span> <span class="n">kz</span><span class="p">,</span> <span class="n">wk</span><span class="p">)</span> <span class="ow">in</span> <span class="n">struct</span><span class="p">[</span><span class="s1">&#39;k_points&#39;</span><span class="p">]:</span>
                    <span class="n">data</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%12.9f</span><span class="s1"> </span><span class="si">%12.9f</span><span class="s1"> </span><span class="si">%12.9f</span><span class="s1"> &#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">kx</span><span class="p">,</span> <span class="n">ky</span><span class="p">,</span> <span class="n">kz</span><span class="p">))</span>

                    <span class="k">if</span> <span class="n">wk</span> <span class="o">==</span> <span class="nb">int</span><span class="p">(</span><span class="n">wk</span><span class="p">):</span>
                        <span class="n">data</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%d</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">wk</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">data</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%12.9f</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">wk</span><span class="p">)</span>

        <span class="k">if</span> <span class="s1">&#39;r_cell&#39;</span> <span class="ow">in</span> <span class="n">struct</span><span class="p">:</span>
            <span class="n">data</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>

            <span class="n">data</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;CELL_PARAMETERS </span><span class="si">%s</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">struct</span><span class="p">[</span><span class="s1">&#39;cell_units&#39;</span><span class="p">])</span>

            <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">struct</span><span class="p">[</span><span class="s1">&#39;r_cell&#39;</span><span class="p">]:</span>
                <span class="n">data</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%12.9f</span><span class="s1"> </span><span class="si">%12.9f</span><span class="s1"> </span><span class="si">%12.9f</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">r</span><span class="p">))</span></div>


<div class="viewcode-block" id="read_win">
<a class="viewcode-back" href="../../modules/bravais.html#elphmod.bravais.read_win">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">read_win</span><span class="p">(</span><span class="n">win</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Read input data from .win file (Wannier90).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    win : str</span>
<span class="sd">        Filename.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dict</span>
<span class="sd">        Crystal structure.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">comm</span><span class="o">.</span><span class="n">rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">struct</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">win</span><span class="p">)</span> <span class="k">as</span> <span class="n">lines</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">lines</span><span class="p">:</span>
                <span class="n">words</span> <span class="o">=</span> <span class="p">[</span><span class="n">word</span>
                    <span class="k">for</span> <span class="n">column</span> <span class="ow">in</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
                    <span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">column</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;=&#39;</span><span class="p">)</span> <span class="k">if</span> <span class="n">word</span><span class="p">]</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="n">words</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="n">key</span> <span class="o">=</span> <span class="n">words</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>

                <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="s1">&#39;num_bands&#39;</span><span class="p">:</span>
                    <span class="n">struct</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">words</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="k">elif</span> <span class="n">key</span> <span class="o">==</span> <span class="s1">&#39;num_wann&#39;</span><span class="p">:</span>
                    <span class="n">struct</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">words</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

                <span class="k">elif</span> <span class="n">key</span> <span class="o">==</span> <span class="s1">&#39;dis_win_min&#39;</span><span class="p">:</span>
                    <span class="n">struct</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">words</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="k">elif</span> <span class="n">key</span> <span class="o">==</span> <span class="s1">&#39;dis_win_max&#39;</span><span class="p">:</span>
                    <span class="n">struct</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">words</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="k">elif</span> <span class="n">key</span> <span class="o">==</span> <span class="s1">&#39;dis_froz_min&#39;</span><span class="p">:</span>
                    <span class="n">struct</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">words</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="k">elif</span> <span class="n">key</span> <span class="o">==</span> <span class="s1">&#39;dis_froz_max&#39;</span><span class="p">:</span>
                    <span class="n">struct</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">words</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

                <span class="k">elif</span> <span class="n">key</span> <span class="o">==</span> <span class="s1">&#39;write_hr&#39;</span><span class="p">:</span>
                    <span class="n">struct</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;t&#39;</span> <span class="ow">in</span> <span class="n">words</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
                <span class="k">elif</span> <span class="n">key</span> <span class="o">==</span> <span class="s1">&#39;bands_plot&#39;</span><span class="p">:</span>
                    <span class="n">struct</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;t&#39;</span> <span class="ow">in</span> <span class="n">words</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
                <span class="k">elif</span> <span class="n">key</span> <span class="o">==</span> <span class="s1">&#39;wannier_plot&#39;</span><span class="p">:</span>
                    <span class="n">struct</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;t&#39;</span> <span class="ow">in</span> <span class="n">words</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>

                <span class="k">elif</span> <span class="n">key</span> <span class="o">==</span> <span class="s1">&#39;dis_num_iter&#39;</span><span class="p">:</span>
                    <span class="n">struct</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">words</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="k">elif</span> <span class="n">key</span> <span class="o">==</span> <span class="s1">&#39;num_iter&#39;</span><span class="p">:</span>
                    <span class="n">struct</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">words</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="k">elif</span> <span class="n">key</span> <span class="o">==</span> <span class="s1">&#39;search_shells&#39;</span><span class="p">:</span>
                    <span class="n">struct</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">words</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

                <span class="k">elif</span> <span class="n">key</span> <span class="o">==</span> <span class="s1">&#39;mp_grid&#39;</span><span class="p">:</span>
                    <span class="n">mp_grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
                        <span class="n">mp_grid</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">words</span><span class="p">[</span><span class="mi">1</span> <span class="o">+</span> <span class="n">i</span><span class="p">])</span>
                    <span class="n">struct</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">mp_grid</span>

                <span class="k">elif</span> <span class="n">key</span> <span class="o">==</span> <span class="s1">&#39;begin&#39;</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">words</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;projections&#39;</span><span class="p">:</span>
                        <span class="c1"># create sub-dict for projections</span>
                        <span class="c1"># complicated solution</span>
                        <span class="c1"># not able to save different wannier centres</span>
                        <span class="c1"># order of projections not preserved</span>
                        <span class="n">proj_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
                        <span class="k">while</span> <span class="s1">&#39;end&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">words</span><span class="p">:</span>
                            <span class="n">words</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span>
                            <span class="k">if</span> <span class="s1">&#39;end&#39;</span> <span class="ow">in</span> <span class="n">words</span><span class="p">:</span>
                                <span class="k">continue</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">atom_pos</span><span class="p">,</span> <span class="n">orbital</span> <span class="o">=</span> <span class="n">words</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;:&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                                <span class="n">proj_dict</span><span class="p">[</span><span class="n">atom_pos</span><span class="o">.</span><span class="n">strip</span><span class="p">()]</span> <span class="o">=</span> <span class="n">orbital</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>

                        <span class="n">struct</span><span class="p">[</span><span class="s1">&#39;proj&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">proj_dict</span>

                    <span class="k">elif</span> <span class="n">words</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;kpoint_path&#39;</span><span class="p">:</span>
                        <span class="n">struct</span><span class="p">[</span><span class="s1">&#39;kpoint_path&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

                        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
                            <span class="n">line</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>

                            <span class="k">if</span> <span class="n">line</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;end&#39;</span><span class="p">):</span>
                                <span class="k">break</span>

                            <span class="n">struct</span><span class="p">[</span><span class="s1">&#39;kpoint_path&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>

                    <span class="k">elif</span> <span class="n">words</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;unit_cell_cart&#39;</span><span class="p">:</span>
                        <span class="n">struct</span><span class="p">[</span><span class="s1">&#39;unit_cell&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>

                        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
                            <span class="n">words</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>

                            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
                                <span class="n">struct</span><span class="p">[</span><span class="s1">&#39;unit_cell&#39;</span><span class="p">][</span><span class="n">n</span><span class="p">,</span> <span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">words</span><span class="p">[</span><span class="n">x</span><span class="p">])</span>

                    <span class="c1"># read atoms_frac or atoms_cart</span>
                    <span class="k">elif</span> <span class="n">words</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;atoms_&#39;</span><span class="p">):</span>
                        <span class="n">struct</span><span class="p">[</span><span class="s1">&#39;atoms_coords&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">words</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">6</span><span class="p">:</span><span class="nb">len</span><span class="p">(</span><span class="n">words</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span>
                        <span class="n">words</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
                        <span class="c1"># get nat from lines</span>
                        <span class="n">tmp</span> <span class="o">=</span> <span class="p">[]</span>
                        <span class="k">while</span> <span class="s1">&#39;end&#39;</span> <span class="o">!=</span> <span class="n">words</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                            <span class="n">tmp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">words</span><span class="p">)</span>
                            <span class="n">words</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
                        <span class="n">nat</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span>

                        <span class="n">struct</span><span class="p">[</span><span class="s1">&#39;at&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                        <span class="n">struct</span><span class="p">[</span><span class="s1">&#39;atoms&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">nat</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>

                        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nat</span><span class="p">):</span>
                            <span class="n">struct</span><span class="p">[</span><span class="s1">&#39;at&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tmp</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
                            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
                                <span class="n">struct</span><span class="p">[</span><span class="s1">&#39;atoms&#39;</span><span class="p">][</span><span class="n">n</span><span class="p">,</span> <span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">tmp</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span><span class="p">])</span>

                    <span class="k">elif</span> <span class="n">words</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;kpoints&#39;</span><span class="p">:</span>
                        <span class="n">nk</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">mp_grid</span><span class="p">))</span>
                        <span class="n">struct</span><span class="p">[</span><span class="s1">&#39;kpoints&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nk</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>

                        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nk</span><span class="p">):</span>
                            <span class="n">words</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>

                            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">words</span><span class="p">)):</span>
                                <span class="n">struct</span><span class="p">[</span><span class="s1">&#39;kpoints&#39;</span><span class="p">][</span><span class="n">n</span><span class="p">,</span> <span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">words</span><span class="p">[</span><span class="n">x</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">struct</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="n">struct</span> <span class="o">=</span> <span class="n">comm</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">struct</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">struct</span></div>


<div class="viewcode-block" id="write_win">
<a class="viewcode-back" href="../../modules/bravais.html#elphmod.bravais.write_win">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">write_win</span><span class="p">(</span><span class="n">win</span><span class="p">,</span> <span class="n">struct</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Write input data to .win file (Wannier90).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    win : str</span>
<span class="sd">        Filename.</span>
<span class="sd">    struct : dict</span>
<span class="sd">        Input data.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">comm</span><span class="o">.</span><span class="n">rank</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span>

    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">win</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">data</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;num_bands&#39;</span><span class="p">,</span> <span class="s1">&#39;num_wann&#39;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">struct</span><span class="p">:</span>
                <span class="n">data</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> = </span><span class="si">%r</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">struct</span><span class="p">[</span><span class="n">key</span><span class="p">]))</span>

        <span class="n">data</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;dis_win_min&#39;</span><span class="p">,</span> <span class="s1">&#39;dis_win_max&#39;</span><span class="p">,</span>
                <span class="s1">&#39;dis_froz_min&#39;</span><span class="p">,</span> <span class="s1">&#39;dis_froz_max&#39;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">struct</span><span class="p">:</span>
                <span class="n">data</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> = </span><span class="si">%r</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">struct</span><span class="p">[</span><span class="n">key</span><span class="p">]))</span>

        <span class="n">data</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">struct</span><span class="p">[</span><span class="s1">&#39;proj&#39;</span><span class="p">]:</span>
            <span class="n">data</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;begin projections</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">struct</span><span class="p">[</span><span class="s1">&#39;proj&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">data</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">: </span><span class="si">%s</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">))</span>
            <span class="n">data</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;end projections</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="n">data</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;write_hr&#39;</span><span class="p">,</span> <span class="s1">&#39;bands_plot&#39;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">struct</span><span class="p">:</span>
                <span class="n">data</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> = </span><span class="si">%r</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">struct</span><span class="p">[</span><span class="n">key</span><span class="p">]))</span>

        <span class="n">data</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;dis_num_iter&#39;</span><span class="p">,</span> <span class="s1">&#39;num_iter&#39;</span><span class="p">,</span> <span class="s1">&#39;search_shells&#39;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">struct</span><span class="p">:</span>
                <span class="n">data</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> = </span><span class="si">%r</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">struct</span><span class="p">[</span><span class="n">key</span><span class="p">]))</span>

        <span class="n">data</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">struct</span><span class="p">[</span><span class="s1">&#39;kpoint_path&#39;</span><span class="p">]:</span>
            <span class="n">data</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;begin kpoint_path</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">struct</span><span class="p">[</span><span class="s1">&#39;kpoint_path&#39;</span><span class="p">]:</span>
                <span class="n">data</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">line</span><span class="p">)</span>
            <span class="n">data</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;end kpoint_path</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="n">data</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="n">data</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;begin unit_cell_cart</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">r1</span><span class="p">,</span> <span class="n">r2</span><span class="p">,</span> <span class="n">r3</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">struct</span><span class="p">[</span><span class="s1">&#39;unit_cell&#39;</span><span class="p">]):</span>
            <span class="n">data</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%12.9f</span><span class="s1"> </span><span class="si">%12.9f</span><span class="s1"> </span><span class="si">%12.9f</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">r1</span><span class="p">,</span> <span class="n">r2</span><span class="p">,</span> <span class="n">r3</span><span class="p">))</span>
        <span class="n">data</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;end unit_cell_cart</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="n">data</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="n">data</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;begin atoms_</span><span class="si">%s</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">struct</span><span class="p">[</span><span class="s1">&#39;atoms_coords&#39;</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">X</span><span class="p">,</span> <span class="p">(</span><span class="n">r1</span><span class="p">,</span> <span class="n">r2</span><span class="p">,</span> <span class="n">r3</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">struct</span><span class="p">[</span><span class="s1">&#39;at&#39;</span><span class="p">],</span> <span class="n">struct</span><span class="p">[</span><span class="s1">&#39;atoms&#39;</span><span class="p">]):</span>
            <span class="n">data</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%2s</span><span class="s1"> </span><span class="si">%12.9f</span><span class="s1"> </span><span class="si">%12.9f</span><span class="s1"> </span><span class="si">%12.9f</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">r1</span><span class="p">,</span> <span class="n">r2</span><span class="p">,</span> <span class="n">r3</span><span class="p">))</span>
        <span class="n">data</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;end atoms_</span><span class="si">%s</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">struct</span><span class="p">[</span><span class="s1">&#39;atoms_coords&#39;</span><span class="p">])</span>

        <span class="n">data</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="s1">&#39;mp_grid&#39;</span> <span class="ow">in</span> <span class="n">struct</span><span class="p">:</span>
            <span class="n">data</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;mp_grid: </span><span class="si">%d</span><span class="s1"> </span><span class="si">%d</span><span class="s1"> </span><span class="si">%d</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">struct</span><span class="p">[</span><span class="s1">&#39;mp_grid&#39;</span><span class="p">]))</span>

        <span class="n">data</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="n">data</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;begin kpoints</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">kx</span><span class="p">,</span> <span class="n">ky</span><span class="p">,</span> <span class="n">kz</span><span class="p">,</span> <span class="n">wk</span><span class="p">)</span> <span class="ow">in</span> <span class="n">struct</span><span class="p">[</span><span class="s1">&#39;kpoints&#39;</span><span class="p">]:</span>
            <span class="n">data</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%12.9f</span><span class="s1"> </span><span class="si">%12.9f</span><span class="s1"> </span><span class="si">%12.9f</span><span class="s1"> </span><span class="si">%12.9f</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">kx</span><span class="p">,</span> <span class="n">ky</span><span class="p">,</span> <span class="n">kz</span><span class="p">,</span> <span class="n">wk</span><span class="p">))</span>
        <span class="n">data</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;end kpoints</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="read_ph">
<a class="viewcode-back" href="../../modules/bravais.html#elphmod.bravais.read_ph">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">read_ph</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Read input parameters from Quantum ESPRESSO&#39;s ``ph.x`` input file.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    filename : str</span>
<span class="sd">        Filename.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dict</span>
<span class="sd">        Input parameters.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">elphmod</span><span class="o">.</span><span class="n">misc</span><span class="o">.</span><span class="n">read_input_data</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span></div>


<div class="viewcode-block" id="write_ph">
<a class="viewcode-back" href="../../modules/bravais.html#elphmod.bravais.write_ph">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">write_ph</span><span class="p">(</span><span class="n">ph</span><span class="p">,</span> <span class="n">struct</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Write input data to ph file (Quantum ESPRESSO).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ph : str</span>
<span class="sd">        Filename.</span>
<span class="sd">    struct : dict</span>
<span class="sd">        Input data.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">comm</span><span class="o">.</span><span class="n">rank</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span>

    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">ph</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">data</span><span class="p">:</span>
        <span class="n">data</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;&amp;INPUTPH</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;prefix&#39;</span><span class="p">,</span> <span class="s1">&#39;outdir&#39;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">struct</span><span class="p">:</span>
                <span class="n">data</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> = </span><span class="si">%r</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">struct</span><span class="p">[</span><span class="n">key</span><span class="p">]))</span>

        <span class="n">data</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;fildyn&#39;</span><span class="p">,</span> <span class="s1">&#39;fildvscf&#39;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">struct</span><span class="p">:</span>
                <span class="n">data</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> = </span><span class="si">%r</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">struct</span><span class="p">[</span><span class="n">key</span><span class="p">]))</span>

        <span class="n">data</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;ldisp&#39;</span><span class="p">,</span> <span class="s1">&#39;nq1&#39;</span><span class="p">,</span> <span class="s1">&#39;nq2&#39;</span><span class="p">,</span> <span class="s1">&#39;nq3&#39;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">struct</span><span class="p">:</span>
                <span class="n">data</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> = </span><span class="si">%r</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">struct</span><span class="p">[</span><span class="n">key</span><span class="p">]))</span>

        <span class="n">data</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;tr2_ph&#39;</span><span class="p">,</span> <span class="s1">&#39;alpha_mix&#39;</span><span class="p">,</span> <span class="s1">&#39;cdfpt&#39;</span><span class="p">,</span> <span class="s1">&#39;subspace&#39;</span><span class="p">,</span>
                <span class="s1">&#39;cdfpt_bnd&#39;</span><span class="p">,</span> <span class="s1">&#39;cdfpt_orb&#39;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">struct</span><span class="p">:</span>
                <span class="n">data</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> = </span><span class="si">%r</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">struct</span><span class="p">[</span><span class="n">key</span><span class="p">]))</span>

        <span class="n">data</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;/</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="read_q2r">
<a class="viewcode-back" href="../../modules/bravais.html#elphmod.bravais.read_q2r">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">read_q2r</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Read input parameters from Quantum ESPRESSO&#39;s ``q2r.x`` input file.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    filename : str</span>
<span class="sd">        Filename.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dict</span>
<span class="sd">        Input parameters.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">elphmod</span><span class="o">.</span><span class="n">misc</span><span class="o">.</span><span class="n">read_input_data</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span></div>


<div class="viewcode-block" id="write_q2r">
<a class="viewcode-back" href="../../modules/bravais.html#elphmod.bravais.write_q2r">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">write_q2r</span><span class="p">(</span><span class="n">q2r</span><span class="p">,</span> <span class="n">struct</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Write input data to q2r file (Quantum ESPRRESO).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    q2r : str</span>
<span class="sd">        Filename.</span>
<span class="sd">    struct : dict</span>
<span class="sd">        Input data.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">comm</span><span class="o">.</span><span class="n">rank</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span>

    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">q2r</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">data</span><span class="p">:</span>
        <span class="n">data</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;&amp;INPUT</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;fildyn&#39;</span><span class="p">,</span> <span class="s1">&#39;flfrc&#39;</span><span class="p">,</span> <span class="s1">&#39;zasr&#39;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">struct</span><span class="p">:</span>
                <span class="n">data</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> = </span><span class="si">%r</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">struct</span><span class="p">[</span><span class="n">key</span><span class="p">]))</span>

        <span class="n">data</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;/</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="read_matdyn">
<a class="viewcode-back" href="../../modules/bravais.html#elphmod.bravais.read_matdyn">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">read_matdyn</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Read input parameters from Quantum ESPRESSO&#39;s ``matdyn.x`` input file.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    filename : str</span>
<span class="sd">        Filename.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dict</span>
<span class="sd">        Input parameters.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">struct</span> <span class="o">=</span> <span class="n">elphmod</span><span class="o">.</span><span class="n">misc</span><span class="o">.</span><span class="n">read_input_data</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">broadcast</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">comm</span><span class="o">.</span><span class="n">rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span> <span class="k">as</span> <span class="n">lines</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">lines</span><span class="p">:</span>
                <span class="k">if</span> <span class="s1">&#39;/&#39;</span> <span class="ow">in</span> <span class="n">line</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">lines</span><span class="p">:</span>
                        <span class="n">words</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
                        <span class="k">if</span> <span class="n">words</span><span class="p">:</span>
                            <span class="k">break</span>

                    <span class="n">struct</span><span class="p">[</span><span class="s1">&#39;nq&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">words</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                    <span class="n">struct</span><span class="p">[</span><span class="s1">&#39;q&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">struct</span><span class="p">[</span><span class="s1">&#39;nq&#39;</span><span class="p">],</span> <span class="mi">4</span><span class="p">))</span>

                    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">struct</span><span class="p">[</span><span class="s1">&#39;nq&#39;</span><span class="p">]):</span>
                        <span class="n">words</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>

                        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
                            <span class="n">struct</span><span class="p">[</span><span class="s1">&#39;q&#39;</span><span class="p">][</span><span class="n">n</span><span class="p">,</span> <span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">words</span><span class="p">[</span><span class="n">x</span><span class="p">])</span>

    <span class="n">struct</span> <span class="o">=</span> <span class="n">comm</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">struct</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">struct</span></div>


<div class="viewcode-block" id="write_matdyn">
<a class="viewcode-back" href="../../modules/bravais.html#elphmod.bravais.write_matdyn">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">write_matdyn</span><span class="p">(</span><span class="n">matdyn</span><span class="p">,</span> <span class="n">struct</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Write input data to matdyn file (Quantum ESPRRESO).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    matdyn : str</span>
<span class="sd">        Filename.</span>
<span class="sd">    struct : dict</span>
<span class="sd">        Input data.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">comm</span><span class="o">.</span><span class="n">rank</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span>

    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">matdyn</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">data</span><span class="p">:</span>
        <span class="n">data</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;&amp;INPUT</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;flfrc&#39;</span><span class="p">,</span> <span class="s1">&#39;flfrq&#39;</span><span class="p">,</span> <span class="s1">&#39;fldos&#39;</span><span class="p">,</span> <span class="s1">&#39;fleig&#39;</span><span class="p">,</span> <span class="s1">&#39;flvec&#39;</span><span class="p">,</span> <span class="s1">&#39;asr&#39;</span><span class="p">,</span>
                <span class="s1">&#39;loto_2d&#39;</span><span class="p">,</span> <span class="s1">&#39;q_in_band_form&#39;</span><span class="p">,</span> <span class="s1">&#39;q_in_cryst_coord&#39;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">struct</span><span class="p">:</span>
                <span class="n">data</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> = </span><span class="si">%r</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">struct</span><span class="p">[</span><span class="n">key</span><span class="p">]))</span>

        <span class="n">data</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;/</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">data</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%d</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">struct</span><span class="p">[</span><span class="s1">&#39;nq&#39;</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="n">struct</span><span class="p">[</span><span class="s1">&#39;q&#39;</span><span class="p">]:</span>
            <span class="n">data</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%12.9f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">q</span> <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="n">point</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="read_epw">
<a class="viewcode-back" href="../../modules/bravais.html#elphmod.bravais.read_epw">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">read_epw</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Read input parameters from Quantum ESPRESSO&#39;s ``epw.x`` input file.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    filename : str</span>
<span class="sd">        Filename.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dict</span>
<span class="sd">        Input parameters.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">struct</span> <span class="o">=</span> <span class="n">elphmod</span><span class="o">.</span><span class="n">misc</span><span class="o">.</span><span class="n">read_input_data</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">broadcast</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">comm</span><span class="o">.</span><span class="n">rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;proj&#39;</span><span class="p">,</span> <span class="s1">&#39;wdata&#39;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">struct</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">struct</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="nb">list</span><span class="p">):</span>
                <span class="n">struct</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">struct</span><span class="p">[</span><span class="n">key</span><span class="p">]]</span>

        <span class="c1">#with open(filename) as lines:</span>
        <span class="c1">#    for line in lines:</span>
        <span class="c1">#        if &#39;/&#39; in line:</span>
        <span class="c1">#             print(next(lines))</span>
        <span class="c1">#             if next(lines) == None:</span>
        <span class="c1">#                 continue</span>
        <span class="c1">#             words = next(lines).split()</span>
        <span class="c1">#             print(words)</span>

        <span class="c1">#             struct[&#39;nq&#39;] = int(words[0])</span>
        <span class="c1">#             struct[&#39;q_coords_type&#39;] = words[1]</span>

        <span class="c1">#             struct[&#39;q&#39;] = np.empty((struct[&#39;nq&#39;], 3))</span>

        <span class="c1">#             for n in range(struct[&#39;nq&#39;]):</span>
        <span class="c1">#                 words = next(lines).split()</span>

        <span class="c1">#                 for x in range(3):</span>
        <span class="c1">#                     struct[&#39;q&#39;][n, x] = float(words[x])</span>

    <span class="n">struct</span> <span class="o">=</span> <span class="n">comm</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">struct</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">struct</span></div>


<div class="viewcode-block" id="write_epw">
<a class="viewcode-back" href="../../modules/bravais.html#elphmod.bravais.write_epw">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">write_epw</span><span class="p">(</span><span class="n">epw</span><span class="p">,</span> <span class="n">struct</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Write input data to epw file (Quantum ESPRRESO).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    epw : str</span>
<span class="sd">        Filename.</span>
<span class="sd">    struct : dict</span>
<span class="sd">        Input data.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">comm</span><span class="o">.</span><span class="n">rank</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span>

    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">epw</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">data</span><span class="p">:</span>
        <span class="n">data</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;&amp;INPUTEPW</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;prefix&#39;</span><span class="p">,</span> <span class="s1">&#39;outdir&#39;</span><span class="p">,</span> <span class="s1">&#39;dvscf_dir&#39;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">struct</span><span class="p">:</span>
                <span class="n">data</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> = </span><span class="si">%r</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">struct</span><span class="p">[</span><span class="n">key</span><span class="p">]))</span>

        <span class="n">data</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;wannierize&#39;</span><span class="p">,</span> <span class="s1">&#39;elph&#39;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">struct</span><span class="p">:</span>
                <span class="n">data</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> = </span><span class="si">%r</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">struct</span><span class="p">[</span><span class="n">key</span><span class="p">]))</span>

        <span class="n">data</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;epbwrite&#39;</span><span class="p">,</span> <span class="s1">&#39;epwwrite&#39;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">struct</span><span class="p">:</span>
                <span class="n">data</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> = </span><span class="si">%r</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">struct</span><span class="p">[</span><span class="n">key</span><span class="p">]))</span>

        <span class="n">data</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;epbread&#39;</span><span class="p">,</span> <span class="s1">&#39;epwread&#39;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">struct</span><span class="p">:</span>
                <span class="n">data</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> = </span><span class="si">%r</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">struct</span><span class="p">[</span><span class="n">key</span><span class="p">]))</span>

        <span class="n">data</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;use_ws&#39;</span><span class="p">,</span> <span class="s1">&#39;nbndsub&#39;</span><span class="p">,</span> <span class="s1">&#39;bands_skipped&#39;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">struct</span><span class="p">:</span>
                <span class="n">data</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> = </span><span class="si">%r</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">struct</span><span class="p">[</span><span class="n">key</span><span class="p">]))</span>

        <span class="n">data</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;dis_win_min&#39;</span><span class="p">,</span> <span class="s1">&#39;dis_win_max&#39;</span><span class="p">,</span>
                <span class="s1">&#39;dis_froz_min&#39;</span><span class="p">,</span> <span class="s1">&#39;dis_froz_max&#39;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">struct</span><span class="p">:</span>
                <span class="n">data</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> = </span><span class="si">%r</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">struct</span><span class="p">[</span><span class="n">key</span><span class="p">]))</span>

        <span class="n">data</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="s1">&#39;proj&#39;</span> <span class="ow">in</span> <span class="n">struct</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">struct</span><span class="p">[</span><span class="s1">&#39;proj&#39;</span><span class="p">],</span> <span class="mi">1</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">value</span><span class="p">:</span>
                    <span class="n">data</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;proj(</span><span class="si">%d</span><span class="s1">) = </span><span class="si">%r</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">value</span><span class="p">))</span>

        <span class="n">data</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;num_iter&#39;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">struct</span><span class="p">:</span>
                <span class="n">data</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> = </span><span class="si">%r</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">struct</span><span class="p">[</span><span class="n">key</span><span class="p">]))</span>

        <span class="k">if</span> <span class="s1">&#39;wdata&#39;</span> <span class="ow">in</span> <span class="n">struct</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">struct</span><span class="p">[</span><span class="s1">&#39;wdata&#39;</span><span class="p">],</span> <span class="mi">1</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">value</span><span class="p">:</span>
                    <span class="n">data</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;wdata(</span><span class="si">%d</span><span class="s1">) = </span><span class="si">%r</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">value</span><span class="p">))</span>

        <span class="n">data</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;nk1&#39;</span><span class="p">,</span> <span class="s1">&#39;nk2&#39;</span><span class="p">,</span> <span class="s1">&#39;nk3&#39;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">struct</span><span class="p">:</span>
                <span class="n">data</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> = </span><span class="si">%r</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">struct</span><span class="p">[</span><span class="n">key</span><span class="p">]))</span>

        <span class="n">data</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;nq1&#39;</span><span class="p">,</span> <span class="s1">&#39;nq2&#39;</span><span class="p">,</span> <span class="s1">&#39;nq3&#39;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">struct</span><span class="p">:</span>
                <span class="n">data</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> = </span><span class="si">%r</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">struct</span><span class="p">[</span><span class="n">key</span><span class="p">]))</span>

        <span class="n">data</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;nkf1&#39;</span><span class="p">,</span> <span class="s1">&#39;nkf2&#39;</span><span class="p">,</span> <span class="s1">&#39;nkf3&#39;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">struct</span><span class="p">:</span>
                <span class="n">data</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> = </span><span class="si">%r</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">struct</span><span class="p">[</span><span class="n">key</span><span class="p">]))</span>

        <span class="n">data</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;nqf1&#39;</span><span class="p">,</span> <span class="s1">&#39;nqf2&#39;</span><span class="p">,</span> <span class="s1">&#39;nqf3&#39;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">struct</span><span class="p">:</span>
                <span class="n">data</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> = </span><span class="si">%r</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">struct</span><span class="p">[</span><span class="n">key</span><span class="p">]))</span>

        <span class="n">data</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)</span>
        <span class="n">data</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span></div>

<span class="c1"># =============================================================================</span>
<span class="c1">#         data.write(&#39;%d %s\n&#39; % (struct[&#39;nq&#39;], struct[&#39;q_coords_type&#39;]))</span>
<span class="c1">#         for (qx, qy, qz) in struct[&#39;q&#39;]:</span>
<span class="c1">#             data.write(&#39;%12.9f %12.9f %12.9f\n&#39; % (qx, qy, qz))</span>
<span class="c1"># =============================================================================</span>

<div class="viewcode-block" id="readPOSCAR">
<a class="viewcode-back" href="../../modules/bravais.html#elphmod.bravais.readPOSCAR">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">readPOSCAR</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Read crystal structure from VASP input file.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    filename : str</span>
<span class="sd">        Filename.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dict</span>
<span class="sd">        Crystal structure.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span> <span class="k">as</span> <span class="n">POSCAR</span><span class="p">:</span>
        <span class="n">title</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">POSCAR</span><span class="p">)</span>

        <span class="n">a</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">POSCAR</span><span class="p">))</span>

        <span class="n">t1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">next</span><span class="p">(</span><span class="n">POSCAR</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">())))</span>
        <span class="n">t2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">next</span><span class="p">(</span><span class="n">POSCAR</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">())))</span>
        <span class="n">t3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">next</span><span class="p">(</span><span class="n">POSCAR</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">())))</span>

        <span class="n">elements</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">POSCAR</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>

        <span class="n">numbers</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">next</span><span class="p">(</span><span class="n">POSCAR</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">()))</span>

        <span class="nb">next</span><span class="p">(</span><span class="n">POSCAR</span><span class="p">)</span>
        <span class="nb">next</span><span class="p">(</span><span class="n">POSCAR</span><span class="p">)</span>

        <span class="n">atoms</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">element</span><span class="p">,</span> <span class="n">number</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">elements</span><span class="p">,</span> <span class="n">numbers</span><span class="p">):</span>
            <span class="n">atoms</span><span class="p">[</span><span class="n">element</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">number</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>

            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">number</span><span class="p">):</span>
                <span class="n">atoms</span><span class="p">[</span><span class="n">element</span><span class="p">][</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">next</span><span class="p">(</span><span class="n">POSCAR</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">()[:</span><span class="mi">3</span><span class="p">]))</span>

    <span class="k">return</span> <span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">,</span> <span class="n">t3</span><span class="p">,</span> <span class="n">atoms</span></div>


<div class="viewcode-block" id="point_on_path">
<a class="viewcode-back" href="../../modules/bravais.html#elphmod.bravais.point_on_path">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">point_on_path</span><span class="p">(</span><span class="n">test_point</span><span class="p">,</span> <span class="n">point_A</span><span class="p">,</span> <span class="n">point_B</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="mf">1e-14</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Test whether a `test_point` is between the points A and B.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    eps : float</span>
<span class="sd">        Numerical parameter, in case the cross product is not exactly 0.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    bool</span>
<span class="sd">        Is the test_point on a straight line between point A and B?</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">cross</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">point_B</span> <span class="o">-</span> <span class="n">point_A</span><span class="p">,</span> <span class="n">test_point</span> <span class="o">-</span> <span class="n">point_A</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">eps</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">cross</span><span class="p">):</span>
        <span class="n">dot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">point_B</span> <span class="o">-</span> <span class="n">point_A</span><span class="p">,</span> <span class="n">test_point</span> <span class="o">-</span> <span class="n">point_A</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">dot</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">squared_distance</span> <span class="o">=</span> <span class="p">(</span>
                <span class="p">(</span><span class="n">point_B</span> <span class="o">-</span> <span class="n">point_A</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">point_B</span> <span class="o">-</span> <span class="n">point_A</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">dot</span> <span class="o">&lt;=</span> <span class="n">squared_distance</span><span class="p">:</span>
                <span class="c1">#&#39;The test point is between A and B&#39;</span>
                <span class="k">return</span> <span class="kc">True</span></div>


<div class="viewcode-block" id="crystal_to_cartesian">
<a class="viewcode-back" href="../../modules/bravais.html#elphmod.bravais.crystal_to_cartesian">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">crystal_to_cartesian</span><span class="p">(</span><span class="n">R_CRYSTAL</span><span class="p">,</span> <span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">,</span> <span class="n">a3</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Transform a lattice structure from crystal to Cartesian coordinates.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    R_CRYSTAL : ndarray</span>
<span class="sd">        Lattice structure in crystal coordinates.</span>
<span class="sd">    a1, a2, a3 : ndarray</span>
<span class="sd">        Lattice vectors.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    R_CARTESIAN : ndarray</span>
<span class="sd">        Lattice structure in Cartesian coordinates.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">R_CARTESIAN</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">R_CRYSTAL</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">a3</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">R_CARTESIAN</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">R_CARTESIAN</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">R_CRYSTAL</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">a1</span> <span class="o">+</span> <span class="n">R_CRYSTAL</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">a2</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">R_CARTESIAN</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">R_CARTESIAN</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="p">(</span><span class="n">R_CRYSTAL</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">a1</span> <span class="o">+</span> <span class="n">R_CRYSTAL</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">a2</span>
                <span class="o">+</span> <span class="n">R_CRYSTAL</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">a3</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">R_CARTESIAN</span></div>


<div class="viewcode-block" id="cartesian_to_crystal">
<a class="viewcode-back" href="../../modules/bravais.html#elphmod.bravais.cartesian_to_crystal">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">cartesian_to_crystal</span><span class="p">(</span><span class="n">R_CARTESIAN</span><span class="p">,</span> <span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">,</span> <span class="n">a3</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Transform a lattice structure from crystal to Cartesian coordinates.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    R_CARTESIAN : ndarray</span>
<span class="sd">        Lattice structure in Cartesian coordinates.</span>
<span class="sd">    a1, a2, a3 : ndarray</span>
<span class="sd">        Lattice vectors.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    R_CRYSTAL: ndarray</span>
<span class="sd">        Lattice structure in crystal coordinates.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">R_CRYSTAL</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">R_CARTESIAN</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="n">A_Matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>

    <span class="n">A_Matrix</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">a1</span>
    <span class="n">A_Matrix</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">a2</span>
    <span class="n">A_Matrix</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">a3</span>

    <span class="n">A_Matrix_Inverse</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">A_Matrix</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">R_CARTESIAN</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="n">R_CRYSTAL</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">A_Matrix_Inverse</span><span class="p">,</span> <span class="n">R_CARTESIAN</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="p">:])</span>

    <span class="k">return</span> <span class="n">R_CRYSTAL</span></div>


<div class="viewcode-block" id="mesh">
<a class="viewcode-back" href="../../modules/bravais.html#elphmod.bravais.mesh">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">mesh</span><span class="p">(</span><span class="o">*</span><span class="n">n</span><span class="p">,</span> <span class="n">flat</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Generate uniform mesh.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    *n : int</span>
<span class="sd">        Mesh dimensions.</span>
<span class="sd">    flat : bool, default False</span>
<span class="sd">        Flatten mesh-point indices into single dimension?</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ndarray</span>
<span class="sd">        Mesh points with period :math:`2 \pi`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">points</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="o">*</span><span class="nb">map</span><span class="p">(</span><span class="nb">range</span><span class="p">,</span> <span class="n">n</span><span class="p">),</span>
        <span class="n">indexing</span><span class="o">=</span><span class="s1">&#39;ij&#39;</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">n</span>

    <span class="k">if</span> <span class="n">flat</span><span class="p">:</span>
        <span class="n">points</span> <span class="o">=</span> <span class="n">points</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">n</span><span class="p">)))</span>

    <span class="k">return</span> <span class="n">points</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span></div>


<div class="viewcode-block" id="kpoints">
<a class="viewcode-back" href="../../modules/bravais.html#elphmod.bravais.kpoints">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">kpoints</span><span class="p">(</span><span class="n">nk1</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nk2</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nk3</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generate and print uniform k-point mesh.</span>

<span class="sd">    Omitted arguments are read from standard input.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    nk1, nk2, nk3 : int</span>
<span class="sd">        Number of points along axis.</span>
<span class="sd">    weights : bool</span>
<span class="sd">        Print weights?</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">nk</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span> <span class="ow">or</span> <span class="nb">int</span><span class="p">(</span><span class="nb">input</span><span class="p">(</span><span class="s1">&#39;number of points along </span><span class="si">%s</span><span class="s1"> axis: &#39;</span> <span class="o">%</span> <span class="n">axis</span><span class="p">)</span> <span class="ow">or</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">axis</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="p">[(</span><span class="s1">&#39;1st&#39;</span><span class="p">,</span> <span class="n">nk1</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;2nd&#39;</span><span class="p">,</span> <span class="n">nk2</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;3rd&#39;</span><span class="p">,</span> <span class="n">nk3</span><span class="p">)]]</span>

    <span class="n">N</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">nk</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">weights</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="s1">&#39;y&#39;</span> <span class="ow">in</span> <span class="nb">input</span><span class="p">(</span><span class="s1">&#39;print weights (y/n): &#39;</span><span class="p">)</span>

    <span class="n">w</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">N</span><span class="p">,)</span> <span class="o">*</span> <span class="n">weights</span>

    <span class="nb">print</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">mesh</span><span class="p">(</span><span class="o">*</span><span class="n">nk</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%12.10f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="o">+</span> <span class="n">w</span><span class="p">))</span></div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2017-2025 elphmod Developers.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>