

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>elphmod.el &mdash; elphmod  documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../_static/style.css?v=6b874a89" />

  
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../_static/documentation_options.js?v=5929fcd5"></script>
      <script src="../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: #e7f2fa" >

          
          
          <a href="../../index.html">
            
              <img src="../../_static/elphmod.svg" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Modules</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../modules/el.html">Electron</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules/ph.html">Phonon</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules/elph.html">Electron–phonon</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules/elel.html">Electron–electron</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules/MPI.html">MPI</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules/bravais.html">Bravais</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules/dispersion.html">Dispersion</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules/dos.html">DOS</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules/diagrams.html">Diagrams</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules/occupations.html">Occupations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules/md.html">MD</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules/eliashberg.html">Eliashberg</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules/plot.html">Plot</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules/misc.html">Miscellaneous</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Models</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../modules/models/graphene.html">Graphene</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules/models/tas2.html">TaS₂</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules/models/chain.html">Chain</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Examples</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../examples/bare.html">Bare phonons</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples/coulomb.html">Coulomb interaction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples/decay.html">Decay</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples/defpot.html">Deformation potential</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples/dos.html">Density of states</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples/cdw_1d.html">Dimerization (carbon chain)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples/ssh.html">Dimerization (SSH model)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples/double_delta.html">Double delta (nesting function)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples/electrons.html">Electron dispersion</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples/a2f.html">Eliashberg spectral function</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples/fan_migdal.html">Fan-Migdal self-energy</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples/fermi_surface.html">Fermi surface</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples/fermi_velocity.html">Fermi velocity</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples/fluctuations.html">Fluctuation diagnostics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples/goldstone.html">Goldstone modes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples/intersections.html">Intersections</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples/isoline.html">Isolines</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples/kekule.html">Kekulé distortion</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples/lr.html">Long-range terms</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples/md.html">Molecular dynamics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples/occupations.html">Occupations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples/peierls.html">Peierls distortion</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples/phonons.html">Phonon dispersion</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples/modes.html">Phonon modes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples/phrenorm_graphene.html">Phonon renormalization (graphene)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples/phrenorm.html">Phonon renormalization (TaS₂)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples/phrenorm_3d.html">Phonon renormalization (α-Po)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples/specfun.html">Phonon spectral function</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples/projwfc_1d.html">Projected bands (carbon chain)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples/projwfc.html">Projected bands (graphene)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples/projwfc_3d.html">Projected bands (α-Po)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples/quadrupole.html">Quadrupole fitting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples/skiing.html">Skiing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples/smear_tetra.html">Smearing vs tetrahedron method</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples/simstm.html">STM simulation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples/simsts.html">STS simulation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples/supercell_el.html">Supercell (electron)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples/supercell_elel.html">Supercell (electron–electron)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples/supercell_elph.html">Supercell (electron–phonon)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples/supercell_ph.html">Supercell (phonon)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples/susceptibility.html">Susceptibility</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples/wannier.html">Wannier interpolation</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">More</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../pages/changelog.html">Changelog</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../pages/patches.html">Patches</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../genindex.html">Index</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu"  style="background: #e7f2fa" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">elphmod</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">elphmod.el</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for elphmod.el</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright (C) 2017-2025 elphmod Developers</span>
<span class="c1"># This program is free software under the terms of the GNU GPLv3 or later.</span>

<span class="sd">&quot;&quot;&quot;Tight-binding models from Wannier90.&quot;&quot;&quot;</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">elphmod.bravais</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">elphmod.dispersion</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">elphmod.misc</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">elphmod.MPI</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">elphmod.occupations</span>

<span class="n">comm</span> <span class="o">=</span> <span class="n">elphmod</span><span class="o">.</span><span class="n">MPI</span><span class="o">.</span><span class="n">comm</span>
<span class="n">info</span> <span class="o">=</span> <span class="n">elphmod</span><span class="o">.</span><span class="n">MPI</span><span class="o">.</span><span class="n">info</span>

<div class="viewcode-block" id="Model">
<a class="viewcode-back" href="../../modules/el.html#elphmod.el.Model">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Model</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Tight-binding model for the electrons.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    seedname : str</span>
<span class="sd">        Common prefix of Wannier90 output files: *seedname_hr.dat* with the</span>
<span class="sd">        Hamiltonian in the Wannier basis and, optionally, *seedname_wsvec.dat*</span>
<span class="sd">        with superlattice vectors used to symmetrize the long-range hopping.</span>
<span class="sd">        Alternatively, *dat.h_mat_r* from RESPACK can be used.</span>
<span class="sd">    N : tuple of int, optional</span>
<span class="sd">        Numbers of unit cells per direction on which RESPACK data is defined.</span>
<span class="sd">        This can be omitted if all numbers are even.</span>
<span class="sd">    a : ndarray, optional</span>
<span class="sd">        Bravais lattice vectors used to map RESPACK data to Wigner-Seitz cell.</span>
<span class="sd">        By default, a cubic cell is assumed.</span>
<span class="sd">    r : ndarray, optional</span>
<span class="sd">        Positions of orbital centers used to map RESPACK data to Wigner-Seitz</span>
<span class="sd">        cell. By default, all orbitals are assumed to be located at the origin</span>
<span class="sd">        of the unit cell.</span>
<span class="sd">    divide_ndegen : bool, default True</span>
<span class="sd">        Divide hopping by degeneracy of Wigner-Seitz point and apply the</span>
<span class="sd">        abovementioned correction? Only ``True`` yields correct bands.</span>
<span class="sd">        ``False`` is only used in combination with :func:`decayH`.</span>
<span class="sd">    read_xsf : bool, default False</span>
<span class="sd">        Read Wannier functions in position representation in the XCrySDen</span>
<span class="sd">        structure format (XSF)?</span>
<span class="sd">    normalize_wf : bool, default False</span>
<span class="sd">        Normalize Wannier functions? This is only recommended if a single and</span>
<span class="sd">        complete image of each Wannier function is contained in the supercell</span>
<span class="sd">        written to the XSF file. This may not be the case for a small number of</span>
<span class="sd">        k points along one direction (e.g., a single k point in the out-of-plane</span>
<span class="sd">        direction in the case of 2D materials), especially in combination with a</span>
<span class="sd">        large supercell.</span>
<span class="sd">    buffer_wf : bool, default False</span>
<span class="sd">        After reading XSF files, store Wannier functions and corresponding</span>
<span class="sd">        real-space mesh in binary files, which will be read next time? Since</span>
<span class="sd">        reading the XSF files is slow, this can save a lot of time for large</span>
<span class="sd">        systems. Make sure to delete the binary files *seedname_wf.npy* and</span>
<span class="sd">        *seedname_xyz.npy* whensoever the XSF files change.</span>
<span class="sd">    check_ortho : bool, default False</span>
<span class="sd">        Check if Wannier functions are orthogonal?</span>
<span class="sd">    rydberg : bool, default False</span>
<span class="sd">        Convert energies from eV to Ry?</span>
<span class="sd">    shared_memory : bool, default False</span>
<span class="sd">        Store Wannier functions in shared memory?</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    R : ndarray</span>
<span class="sd">        Lattice vectors :math:`\vec R` of Wigner-Seitz supercell.</span>
<span class="sd">    data : ndarray</span>
<span class="sd">        Corresponding on-site energies and hoppings in eV.</span>

<span class="sd">        .. math::</span>

<span class="sd">            H_{\vec R \alpha \beta} = \bra{0 \alpha} H \ket{\vec R \beta}</span>

<span class="sd">        If :attr:`rydberg` is ``True``, the units are Ry instead.</span>
<span class="sd">    size : int</span>
<span class="sd">        Number of Wannier functions/bands.</span>
<span class="sd">    nk : tuple of int</span>
<span class="sd">        Guessed shape of original k-point mesh.</span>
<span class="sd">    cells : list of tuple of int, optional</span>
<span class="sd">        Lattice vectors of unit cells if the model describes a supercell.</span>
<span class="sd">    N : list of tuple of int, optional</span>
<span class="sd">        Primitive vectors of supercell if the model describes a supercell.</span>
<span class="sd">    W : ndarray, optional</span>
<span class="sd">        Wannier functions in position representation if `read_xsf`.</span>
<span class="sd">    r : ndarray, optional</span>
<span class="sd">        Cartesian positions belonging to Wannier functions if `read_xsf`.</span>
<span class="sd">    tau : ndarray, optional</span>
<span class="sd">        Positions of basis atoms if `read_xsf`.</span>
<span class="sd">    atom_order : list of str, optional</span>
<span class="sd">        Ordered list of atoms if `read_xsf`.</span>
<span class="sd">    dV : float, optional</span>
<span class="sd">        Volume element/voxel volume belonging to `r` if `read_xsf`.</span>
<span class="sd">    divide_ndegen : bool</span>
<span class="sd">        Have hoppings been divided by degeneracy of Wigner-Seitz point?</span>
<span class="sd">    rydberg : bool</span>
<span class="sd">        Have energies been converted from eV to Ry?</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="Model.H">
<a class="viewcode-back" href="../../modules/el.html#elphmod.el.Model.H">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">H</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k1</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">k2</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">k3</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Set up Hamilton operator for arbitrary k point.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        k1, k2, k3 : float, default 0.0</span>
<span class="sd">            k point in crystal coordinates with period :math:`2 \pi`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ndarray</span>
<span class="sd">            Fourier transform of :attr:`data`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">k1</span><span class="p">,</span> <span class="n">k2</span><span class="p">,</span> <span class="n">k3</span><span class="p">])</span>

        <span class="c1"># Sign convention in hamiltonian.f90 of Wannier90:</span>
        <span class="c1"># 300  fac = exp(-cmplx_i*rdotk)/real(num_kpts, dp)</span>
        <span class="c1"># 301  ham_r(:, :, irpt) = ham_r(:, :, irpt) + fac*ham_k(:, :, loop_kpt)</span>

        <span class="c1"># Note that the data from Wannier90 can be interpreted like this:</span>
        <span class="c1"># self.data[self.R == R - R&#39;, a, b] = &lt;R&#39; a|H|R b&gt;</span>

        <span class="c1"># Compare this convention [doi:10.26092/elib/250, Eq. 2.35a]:</span>
        <span class="c1"># t(R - R&#39;, a, b) = &lt;R a|H|R&#39; b&gt;</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;Rab,R-&gt;ab&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">k</span><span class="p">)))</span></div>


<div class="viewcode-block" id="Model.v">
<a class="viewcode-back" href="../../modules/el.html#elphmod.el.Model.v">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">v</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k1</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">k2</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">k3</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Set up band-velocity operator for arbitrary k point.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        k1, k2, k3 : float, default 0.0</span>
<span class="sd">            k point in crystal coordinates with period :math:`2 \pi`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ndarray</span>
<span class="sd">            k derivative of Fourier transform of :attr:`data` in the basis of</span>
<span class="sd">            primitive lattice vectors and orbitals. It can be transformed into</span>
<span class="sd">            the Cartesian and band basis afterward (Hellmann-Feynman theorem).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">k1</span><span class="p">,</span> <span class="n">k2</span><span class="p">,</span> <span class="n">k3</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;Rx,Rab,R-&gt;xab&#39;</span><span class="p">,</span>
            <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">k</span><span class="p">)))</span></div>


<div class="viewcode-block" id="Model.t">
<a class="viewcode-back" href="../../modules/el.html#elphmod.el.Model.t">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">t</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">R1</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">R2</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">R3</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get on-site or hopping energy for arbitrary lattice vector.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        R1, R2, R3 : int, default 0</span>
<span class="sd">            Lattice vector in units of primitive vectors.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ndarray</span>
<span class="sd">            Element of :attr:`data` or zero.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">elphmod</span><span class="o">.</span><span class="n">misc</span><span class="o">.</span><span class="n">vector_index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="p">,</span> <span class="p">(</span><span class="n">R1</span><span class="p">,</span> <span class="n">R2</span><span class="p">,</span> <span class="n">R3</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">index</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">index</span><span class="p">]</span></div>


    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seedname</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">r</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">divide_ndegen</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">read_xsf</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">normalize_wf</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">buffer_wf</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">check_ortho</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">rydberg</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">shared_memory</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">divide_ndegen</span> <span class="o">=</span> <span class="n">divide_ndegen</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rydberg</span> <span class="o">=</span> <span class="n">rydberg</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">cells</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span>

        <span class="k">if</span> <span class="n">seedname</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="n">seedname</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;_hr.dat&#39;</span><span class="p">):</span>
            <span class="n">seedname</span> <span class="o">=</span> <span class="n">seedname</span><span class="p">[:</span><span class="o">-</span><span class="mi">7</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">seedname</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;dat.h_mat_r&#39;</span><span class="p">):</span>
            <span class="n">R</span><span class="p">,</span> <span class="n">data</span> <span class="o">=</span> <span class="n">elphmod</span><span class="o">.</span><span class="n">misc</span><span class="o">.</span><span class="n">read_dat_mat</span><span class="p">(</span><span class="n">seedname</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">N</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">N</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">R</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">a</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">info</span><span class="p">(</span><span class="s1">&#39;Warning: You should really define the Bravais lattice!&#39;</span><span class="p">)</span>
                <span class="n">a</span> <span class="o">=</span> <span class="n">elphmod</span><span class="o">.</span><span class="n">bravais</span><span class="o">.</span><span class="n">primitives</span><span class="p">(</span><span class="n">ibrav</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">r</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>

            <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">N</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">N</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">),</span>
                <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">iR</span><span class="p">,</span> <span class="p">(</span><span class="n">R1</span><span class="p">,</span> <span class="n">R2</span><span class="p">,</span> <span class="n">R3</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">R</span><span class="p">):</span>
                <span class="n">t</span><span class="p">[</span><span class="n">R1</span> <span class="o">%</span> <span class="n">N</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">R2</span> <span class="o">%</span> <span class="n">N</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">R3</span> <span class="o">%</span> <span class="n">N</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">iR</span><span class="p">]</span>

            <span class="n">k2r</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">fft</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

            <span class="n">supvecs</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">read_hrdat</span><span class="p">(</span><span class="n">seedname</span><span class="p">,</span> <span class="n">divide_ndegen</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">rydberg</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">/=</span> <span class="n">elphmod</span><span class="o">.</span><span class="n">misc</span><span class="o">.</span><span class="n">Ry</span>

            <span class="n">supvecs</span> <span class="o">=</span> <span class="n">read_wsvecdat</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">_wsvec.dat&#39;</span> <span class="o">%</span> <span class="n">seedname</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">nk</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="p">[:,</span> <span class="n">x</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span>
            <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)]</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">initial</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>

        <span class="k">if</span> <span class="n">supvecs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">divide_ndegen</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">comm</span><span class="o">.</span><span class="n">rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">const</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

                <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">):</span>
                        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">):</span>
                            <span class="n">key</span> <span class="o">=</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span>
                            <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">]</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">supvecs</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>

                            <span class="k">for</span> <span class="n">I</span><span class="p">,</span> <span class="n">J</span><span class="p">,</span> <span class="n">K</span> <span class="ow">in</span> <span class="n">supvecs</span><span class="p">[</span><span class="n">key</span><span class="p">]:</span>
                                <span class="n">R</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">I</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="n">J</span><span class="p">,</span> <span class="n">k</span> <span class="o">+</span> <span class="n">K</span>

                                <span class="k">if</span> <span class="n">R</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">const</span><span class="p">:</span>
                                    <span class="n">const</span><span class="p">[</span><span class="n">R</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">),</span>
                                        <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>

                                <span class="n">const</span><span class="p">[</span><span class="n">R</span><span class="p">][</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">]</span> <span class="o">+=</span> <span class="n">t</span>

                <span class="n">count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">const</span><span class="p">)</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">keys</span><span class="p">()),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">count</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="n">count</span> <span class="o">=</span> <span class="n">comm</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">count</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">comm</span><span class="o">.</span><span class="n">rank</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">count</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">count</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">),</span>
                    <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>

            <span class="n">comm</span><span class="o">.</span><span class="n">Bcast</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="p">)</span>
            <span class="n">comm</span><span class="o">.</span><span class="n">Bcast</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">read_xsf</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">buffer_wf</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">W</span> <span class="o">=</span> <span class="n">elphmod</span><span class="o">.</span><span class="n">MPI</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">_wf.npy&#39;</span> <span class="o">%</span> <span class="n">seedname</span><span class="p">,</span>
                    <span class="n">shared_memory</span><span class="p">)</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">r</span> <span class="o">=</span> <span class="n">elphmod</span><span class="o">.</span><span class="n">MPI</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">_xyz.npy&#39;</span> <span class="o">%</span> <span class="n">seedname</span><span class="p">,</span>
                    <span class="n">shared_memory</span><span class="p">)</span>

            <span class="n">read_buffer</span> <span class="o">=</span> <span class="n">buffer_wf</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">W</span><span class="o">.</span><span class="n">size</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="o">.</span><span class="n">size</span>

            <span class="n">r0</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">atom_order</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tau</span><span class="p">,</span> <span class="n">shape</span> <span class="o">=</span> <span class="n">elphmod</span><span class="o">.</span><span class="n">misc</span><span class="o">.</span><span class="n">read_xsf</span><span class="p">(</span>
                <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">_head.xsf&#39;</span> <span class="o">%</span> <span class="n">seedname</span> <span class="k">if</span> <span class="n">read_buffer</span> <span class="k">else</span>
                <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">_</span><span class="si">%05d</span><span class="s1">.xsf&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">seedname</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">only_header</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">dV</span> <span class="o">=</span> <span class="n">elphmod</span><span class="o">.</span><span class="n">bravais</span><span class="o">.</span><span class="n">volume</span><span class="p">(</span><span class="o">*</span><span class="n">a</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">read_buffer</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">r</span> <span class="o">=</span> <span class="n">elphmod</span><span class="o">.</span><span class="n">misc</span><span class="o">.</span><span class="n">real_space_grid</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">r0</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span>
                    <span class="n">shared_memory</span><span class="p">)</span>

                <span class="n">sizes</span><span class="p">,</span> <span class="n">bounds</span> <span class="o">=</span> <span class="n">elphmod</span><span class="o">.</span><span class="n">MPI</span><span class="o">.</span><span class="n">distribute</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

                <span class="n">my_W</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">sizes</span><span class="p">[</span><span class="n">comm</span><span class="o">.</span><span class="n">rank</span><span class="p">],</span> <span class="o">*</span><span class="n">shape</span><span class="p">))</span>
                <span class="n">node</span><span class="p">,</span> <span class="n">images</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">W</span> <span class="o">=</span> <span class="n">elphmod</span><span class="o">.</span><span class="n">MPI</span><span class="o">.</span><span class="n">shared_array</span><span class="p">(</span>
                    <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="o">*</span><span class="n">shape</span><span class="p">),</span> <span class="n">shared_memory</span><span class="o">=</span><span class="n">shared_memory</span><span class="p">)</span>

                <span class="k">for</span> <span class="n">my_n</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span>
                        <span class="o">*</span><span class="n">bounds</span><span class="p">[</span><span class="n">comm</span><span class="o">.</span><span class="n">rank</span><span class="p">:</span><span class="n">comm</span><span class="o">.</span><span class="n">rank</span> <span class="o">+</span> <span class="mi">2</span><span class="p">])):</span>

                    <span class="n">my_W</span><span class="p">[</span><span class="n">my_n</span><span class="p">]</span> <span class="o">=</span> <span class="n">elphmod</span><span class="o">.</span><span class="n">misc</span><span class="o">.</span><span class="n">read_xsf</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">_</span><span class="si">%05d</span><span class="s1">.xsf&#39;</span>
                        <span class="o">%</span> <span class="p">(</span><span class="n">seedname</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">comm</span><span class="o">=</span><span class="n">elphmod</span><span class="o">.</span><span class="n">MPI</span><span class="o">.</span><span class="n">I</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

                    <span class="k">if</span> <span class="n">normalize_wf</span><span class="p">:</span>
                        <span class="n">my_W</span><span class="p">[</span><span class="n">my_n</span><span class="p">]</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">my_W</span><span class="p">[</span><span class="n">my_n</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dV</span><span class="p">)</span>

                <span class="n">comm</span><span class="o">.</span><span class="n">Gatherv</span><span class="p">(</span><span class="n">my_W</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">W</span><span class="p">,</span> <span class="n">sizes</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">shape</span><span class="p">)))</span>

                <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">images</span><span class="o">.</span><span class="n">Bcast</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">W</span><span class="p">)</span>

                <span class="n">comm</span><span class="o">.</span><span class="n">Barrier</span><span class="p">()</span>

                <span class="k">if</span> <span class="n">buffer_wf</span> <span class="ow">and</span> <span class="n">comm</span><span class="o">.</span><span class="n">rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">elphmod</span><span class="o">.</span><span class="n">misc</span><span class="o">.</span><span class="n">write_xsf</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">_head.xsf&#39;</span> <span class="o">%</span> <span class="n">seedname</span><span class="p">,</span> <span class="n">r0</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">atom_order</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tau</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">only_header</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

                    <span class="n">np</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">_wf.npy&#39;</span> <span class="o">%</span> <span class="n">seedname</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">W</span><span class="p">)</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">_xyz.npy&#39;</span> <span class="o">%</span> <span class="n">seedname</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">check_ortho</span><span class="p">:</span>
                <span class="n">info</span><span class="p">(</span><span class="s1">&#39;Check if Wannier functions are orthogonal:&#39;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">):</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">m</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">+</span> <span class="n">n</span><span class="p">)</span> <span class="o">%</span> <span class="n">comm</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="n">comm</span><span class="o">.</span><span class="n">rank</span><span class="p">:</span>
                            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%3d</span><span class="s1"> </span><span class="si">%3d</span><span class="s1"> </span><span class="si">%12.4f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span>
                                <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">W</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">W</span><span class="p">[</span><span class="n">n</span><span class="p">])</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dV</span><span class="p">))</span>

<div class="viewcode-block" id="Model.supercell">
<a class="viewcode-back" href="../../modules/el.html#elphmod.el.Model.supercell">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">supercell</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">N1</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">N2</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">N3</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Map tight-binding model onto supercell.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        N1, N2, N3 : tuple of int or int, default 1</span>
<span class="sd">            Supercell lattice vectors in units of primitive lattice vectors.</span>
<span class="sd">        sparse : bool, default False</span>
<span class="sd">            Only calculate k = 0 Hamiltonian as a sparse matrix to save memory?</span>
<span class="sd">            The result, which is assumed to be real, is stored in the attribute</span>
<span class="sd">            :attr:`Hs`. Consider using :meth:`standardize` with nonzero `eps`</span>
<span class="sd">            and `symmetrize` before.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        object</span>
<span class="sd">            Tight-binding model for supercell.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        elphmod.bravais.supercell</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">el</span> <span class="o">=</span> <span class="n">Model</span><span class="p">()</span>

        <span class="n">supercell</span> <span class="o">=</span> <span class="n">elphmod</span><span class="o">.</span><span class="n">bravais</span><span class="o">.</span><span class="n">supercell</span><span class="p">(</span><span class="n">N1</span><span class="p">,</span> <span class="n">N2</span><span class="p">,</span> <span class="n">N3</span><span class="p">)</span>
        <span class="n">el</span><span class="o">.</span><span class="n">N</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="n">supercell</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="n">el</span><span class="o">.</span><span class="n">cells</span> <span class="o">=</span> <span class="n">supercell</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">el</span><span class="o">.</span><span class="n">size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">el</span><span class="o">.</span><span class="n">cells</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span>

        <span class="n">el</span><span class="o">.</span><span class="n">divide_ndegen</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">divide_ndegen</span>
        <span class="n">el</span><span class="o">.</span><span class="n">rydberg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rydberg</span>

        <span class="k">if</span> <span class="n">sparse</span><span class="p">:</span>
            <span class="n">sparse_array</span> <span class="o">=</span> <span class="n">elphmod</span><span class="o">.</span><span class="n">misc</span><span class="o">.</span><span class="n">get_sparse_array</span><span class="p">()</span>

            <span class="n">el</span><span class="o">.</span><span class="n">Hs</span> <span class="o">=</span> <span class="n">sparse_array</span><span class="p">((</span><span class="n">el</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">el</span><span class="o">.</span><span class="n">size</span><span class="p">))</span>

            <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">imag</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mf">1e-6</span> <span class="o">*</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">real</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">():</span>
                <span class="n">info</span><span class="p">(</span><span class="s1">&#39;Warning: Significant imaginary part of hopping ignored!&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">comm</span><span class="o">.</span><span class="n">rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">const</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

            <span class="n">status</span> <span class="o">=</span> <span class="n">elphmod</span><span class="o">.</span><span class="n">misc</span><span class="o">.</span><span class="n">StatusBar</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">el</span><span class="o">.</span><span class="n">cells</span><span class="p">),</span>
                <span class="n">title</span><span class="o">=</span><span class="s1">&#39;map hoppings onto supercell&#39;</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">el</span><span class="o">.</span><span class="n">cells</span><span class="p">)):</span>
                <span class="n">A</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span>

                <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="p">)):</span>
                    <span class="n">R</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="n">elphmod</span><span class="o">.</span><span class="n">bravais</span><span class="o">.</span><span class="n">to_supercell</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> <span class="n">el</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                        <span class="n">supercell</span><span class="p">)</span>

                    <span class="n">B</span> <span class="o">=</span> <span class="n">r</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span>

                    <span class="k">if</span> <span class="n">sparse</span><span class="p">:</span>
                        <span class="n">el</span><span class="o">.</span><span class="n">Hs</span><span class="p">[</span>
                            <span class="n">A</span><span class="p">:</span><span class="n">A</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">,</span>
                            <span class="n">B</span><span class="p">:</span><span class="n">B</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">real</span>
                        <span class="k">continue</span>

                    <span class="k">if</span> <span class="n">R</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">const</span><span class="p">:</span>
                        <span class="n">const</span><span class="p">[</span><span class="n">R</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">el</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">el</span><span class="o">.</span><span class="n">size</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>

                    <span class="n">const</span><span class="p">[</span><span class="n">R</span><span class="p">][</span><span class="n">A</span><span class="p">:</span><span class="n">A</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">B</span><span class="p">:</span><span class="n">B</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>

                <span class="n">status</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>

            <span class="n">el</span><span class="o">.</span><span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">keys</span><span class="p">()),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
            <span class="n">el</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span>
                <span class="n">el</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">el</span><span class="o">.</span><span class="n">size</span><span class="p">))</span>

            <span class="n">count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">const</span><span class="p">)</span>
            <span class="n">const</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">count</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">sparse</span><span class="p">:</span>
            <span class="n">el</span><span class="o">.</span><span class="n">Hs</span> <span class="o">=</span> <span class="n">comm</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">el</span><span class="o">.</span><span class="n">Hs</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">el</span>

        <span class="n">count</span> <span class="o">=</span> <span class="n">comm</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">count</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">comm</span><span class="o">.</span><span class="n">rank</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">el</span><span class="o">.</span><span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">count</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
            <span class="n">el</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">count</span><span class="p">,</span> <span class="n">el</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">el</span><span class="o">.</span><span class="n">size</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>

        <span class="n">comm</span><span class="o">.</span><span class="n">Bcast</span><span class="p">(</span><span class="n">el</span><span class="o">.</span><span class="n">R</span><span class="p">)</span>
        <span class="n">comm</span><span class="o">.</span><span class="n">Bcast</span><span class="p">(</span><span class="n">el</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>

        <span class="n">el</span><span class="o">.</span><span class="n">cells</span> <span class="o">=</span> <span class="n">comm</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">el</span><span class="o">.</span><span class="n">cells</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">el</span></div>


<div class="viewcode-block" id="Model.unit_cell">
<a class="viewcode-back" href="../../modules/el.html#elphmod.el.Model.unit_cell">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">unit_cell</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Map tight-binding model back to unit cell.</span>

<span class="sd">        Original idea by Bin Shao.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        supercell</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">el</span> <span class="o">=</span> <span class="n">Model</span><span class="p">()</span>
        <span class="n">el</span><span class="o">.</span><span class="n">size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">//</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">comm</span><span class="o">.</span><span class="n">rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">const</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

            <span class="n">status</span> <span class="o">=</span> <span class="n">elphmod</span><span class="o">.</span><span class="n">misc</span><span class="o">.</span><span class="n">StatusBar</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="p">),</span>
                <span class="n">title</span><span class="o">=</span><span class="s1">&#39;map hoppings back to unit cell&#39;</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="p">)):</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">cell</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">):</span>
                    <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="p">:</span><span class="n">el</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">i</span> <span class="o">*</span> <span class="n">el</span><span class="o">.</span><span class="n">size</span><span class="p">:(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">el</span><span class="o">.</span><span class="n">size</span><span class="p">]</span>

                    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">t</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">):</span>
                        <span class="n">R</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cell</span><span class="p">))</span>
                        <span class="n">const</span><span class="p">[</span><span class="n">R</span><span class="p">]</span> <span class="o">=</span> <span class="n">t</span>

                <span class="n">status</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>

            <span class="n">el</span><span class="o">.</span><span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">keys</span><span class="p">()),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
            <span class="n">el</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>

            <span class="n">count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">const</span><span class="p">)</span>
            <span class="n">const</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">count</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">count</span> <span class="o">=</span> <span class="n">comm</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">count</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">comm</span><span class="o">.</span><span class="n">rank</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">el</span><span class="o">.</span><span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">count</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
            <span class="n">el</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">count</span><span class="p">,</span> <span class="n">el</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">el</span><span class="o">.</span><span class="n">size</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>

        <span class="n">comm</span><span class="o">.</span><span class="n">Bcast</span><span class="p">(</span><span class="n">el</span><span class="o">.</span><span class="n">R</span><span class="p">)</span>
        <span class="n">comm</span><span class="o">.</span><span class="n">Bcast</span><span class="p">(</span><span class="n">el</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">el</span></div>


<div class="viewcode-block" id="Model.order_orbitals">
<a class="viewcode-back" href="../../modules/el.html#elphmod.el.Model.order_orbitals">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">order_orbitals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">order</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Reorder Wannier functions.</span>

<span class="sd">        Warning: Wannier functions in position representation and related</span>
<span class="sd">        attributes remain unchanged!</span>

<span class="sd">        Together with :func:`shift_orbitals`, this function helps reconcile</span>
<span class="sd">        inconsistent definitions of the basis/motif of the Bravais lattice.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        *order : int</span>
<span class="sd">            New order of Wannier functions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[:,</span> <span class="n">order</span><span class="p">,</span> <span class="p">:]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">order</span><span class="p">]</span></div>


<div class="viewcode-block" id="Model.shift_orbitals">
<a class="viewcode-back" href="../../modules/el.html#elphmod.el.Model.shift_orbitals">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">shift_orbitals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">S</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Move selected Wannier functions across unit-cell boundary.</span>

<span class="sd">        Warning: Wannier functions in position representation and related</span>
<span class="sd">        attributes remain unchanged!</span>

<span class="sd">        Together with :func:`order_orbitals`, this function helps reconcile</span>
<span class="sd">        inconsistent definitions of the basis/motif of the Bravais lattice.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        s : slice</span>
<span class="sd">            Slice of orbital indices corresponding to selected basis atom(s).</span>
<span class="sd">        S : tuple of int</span>
<span class="sd">            Shift of as multiple of primitive lattice vectors.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="p">)</span>
        <span class="n">m</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">n</span>

        <span class="n">R</span><span class="p">[:</span><span class="n">n</span><span class="p">]</span> <span class="o">-=</span> <span class="n">S</span>
        <span class="n">data</span><span class="p">[:</span><span class="n">n</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">data</span><span class="p">[:</span><span class="n">n</span><span class="p">,</span> <span class="p">:,</span> <span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">s</span><span class="p">]</span>
        <span class="n">data</span><span class="p">[:</span><span class="n">n</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>

        <span class="n">data</span><span class="p">[</span><span class="n">n</span><span class="p">:</span><span class="n">m</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">data</span><span class="p">[</span><span class="n">n</span><span class="p">:</span><span class="n">m</span><span class="p">,</span> <span class="p">:,</span> <span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">data</span><span class="p">[</span><span class="n">n</span><span class="p">:</span><span class="n">m</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[:,</span> <span class="n">s</span><span class="p">,</span> <span class="n">s</span><span class="p">]</span>

        <span class="n">R</span><span class="p">[</span><span class="n">m</span><span class="p">:]</span> <span class="o">+=</span> <span class="n">S</span>
        <span class="n">data</span><span class="p">[</span><span class="n">m</span><span class="p">:,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">data</span><span class="p">[</span><span class="n">m</span><span class="p">:,</span> <span class="n">s</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[:,</span> <span class="n">s</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">data</span><span class="p">[</span><span class="n">m</span><span class="p">:,</span> <span class="n">s</span><span class="p">,</span> <span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">R</span> <span class="o">=</span> <span class="n">R</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">standardize</span><span class="p">()</span></div>


<div class="viewcode-block" id="Model.standardize">
<a class="viewcode-back" href="../../modules/el.html#elphmod.el.Model.standardize">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">standardize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">symmetrize</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Standardize tight-binding data.</span>

<span class="sd">        - Keep only nonzero hopping matrices.</span>
<span class="sd">        - Sum over repeated lattice vectors.</span>
<span class="sd">        - Sort lattice vectors.</span>
<span class="sd">        - Optionally symmetrize hopping:</span>

<span class="sd">        .. math::</span>

<span class="sd">            H_{\vec k} = H_{\vec k}^\dagger,</span>
<span class="sd">            H_{\vec R} = H_{-\vec R}^\dagger</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        eps : float</span>
<span class="sd">            Threshold for &quot;nonzero&quot; matrix elements in units of the maximum</span>
<span class="sd">            matrix element.</span>
<span class="sd">        symmetrize : bool</span>
<span class="sd">            Symmetrize hopping?</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">comm</span><span class="o">.</span><span class="n">rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">eps</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">eps</span> <span class="o">*</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()]</span> <span class="o">=</span> <span class="mf">0.0</span>

            <span class="n">const</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

            <span class="n">status</span> <span class="o">=</span> <span class="n">elphmod</span><span class="o">.</span><span class="n">misc</span><span class="o">.</span><span class="n">StatusBar</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="p">),</span>
                <span class="n">title</span><span class="o">=</span><span class="s1">&#39;standardize tight-binding data&#39;</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">!=</span> <span class="mf">0.0</span><span class="p">):</span>
                    <span class="n">R</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>

                    <span class="k">if</span> <span class="n">R</span> <span class="ow">in</span> <span class="n">const</span><span class="p">:</span>
                        <span class="n">const</span><span class="p">[</span><span class="n">R</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">const</span><span class="p">[</span><span class="n">R</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

                    <span class="k">if</span> <span class="n">symmetrize</span><span class="p">:</span>
                        <span class="n">R</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>

                        <span class="k">if</span> <span class="n">R</span> <span class="ow">in</span> <span class="n">const</span><span class="p">:</span>
                            <span class="n">const</span><span class="p">[</span><span class="n">R</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">const</span><span class="p">[</span><span class="n">R</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span>

                <span class="n">status</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>

            <span class="n">cells</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
            <span class="n">count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">cells</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cells</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">const</span><span class="p">[</span><span class="n">R</span><span class="p">]</span> <span class="k">for</span> <span class="n">R</span> <span class="ow">in</span> <span class="n">cells</span><span class="p">])</span>

            <span class="k">if</span> <span class="n">symmetrize</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">/=</span> <span class="mi">2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">count</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">count</span> <span class="o">=</span> <span class="n">comm</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">count</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">comm</span><span class="o">.</span><span class="n">rank</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">count</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">count</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>

        <span class="n">comm</span><span class="o">.</span><span class="n">Bcast</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="p">)</span>
        <span class="n">comm</span><span class="o">.</span><span class="n">Bcast</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span></div>


<div class="viewcode-block" id="Model.symmetrize">
<a class="viewcode-back" href="../../modules/el.html#elphmod.el.Model.symmetrize">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">symmetrize</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Symmetrize Hamiltonian.&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">standardize</span><span class="p">(</span><span class="n">symmetrize</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>


<div class="viewcode-block" id="Model.clear">
<a class="viewcode-back" href="../../modules/el.html#elphmod.el.Model.clear">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">clear</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Delete all lattice vectors and associated matrix elements.&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="p">[:</span><span class="mi">0</span><span class="p">,</span> <span class="p">:])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[:</span><span class="mi">0</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:])</span></div>


<div class="viewcode-block" id="Model.to_hrdat">
<a class="viewcode-back" href="../../modules/el.html#elphmod.el.Model.to_hrdat">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">to_hrdat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seedname</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Save tight-binding model to *_hr.dat* file.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        seedname : str</span>
<span class="sd">            Common prefix of Wannier90 input and output files.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">comm</span><span class="o">.</span><span class="n">rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">write_hrdat</span><span class="p">(</span><span class="n">seedname</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">*</span> <span class="n">elphmod</span><span class="o">.</span><span class="n">misc</span><span class="o">.</span><span class="n">Ry</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rydberg</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span></div>
</div>


<div class="viewcode-block" id="read_hrdat">
<a class="viewcode-back" href="../../modules/el.html#elphmod.el.read_hrdat">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">read_hrdat</span><span class="p">(</span><span class="n">seedname</span><span class="p">,</span> <span class="n">divide_ndegen</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Read *_hr.dat* (or *_tb.dat*) file from Wannier90.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    seedname : str</span>
<span class="sd">        Common prefix of Wannier90 input and output files.</span>
<span class="sd">    divide_ndegen : bool</span>
<span class="sd">        Divide hopping by degeneracy of Wigner-Seitz point?</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ndarray</span>
<span class="sd">        Lattice vectors.</span>
<span class="sd">    ndarray</span>
<span class="sd">        On-site and hopping parameters.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">comm</span><span class="o">.</span><span class="n">rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">_hr.dat&#39;</span> <span class="o">%</span> <span class="n">seedname</span><span class="p">)</span>
            <span class="n">tb</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">except</span> <span class="ne">FileNotFoundError</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Warning: Hamiltonian read from &quot;</span><span class="si">%s</span><span class="s1">_tb.dat&quot;!&#39;</span> <span class="o">%</span> <span class="n">seedname</span><span class="p">)</span>

            <span class="n">data</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">_tb.dat&#39;</span> <span class="o">%</span> <span class="n">seedname</span><span class="p">)</span>
            <span class="n">tb</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># read all words of current line:</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">cols</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
                <span class="n">words</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>

                <span class="k">if</span> <span class="n">words</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">words</span>

        <span class="c1"># skip header:</span>

        <span class="n">date</span> <span class="o">=</span> <span class="n">cols</span><span class="p">()[</span><span class="mi">2</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">tb</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
                <span class="n">a</span> <span class="o">=</span> <span class="n">cols</span><span class="p">()</span>

        <span class="c1"># get dimensions:</span>

        <span class="n">num_wann</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">cols</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">nrpts</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">cols</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span>

        <span class="c1"># read degeneracies of Wigner-Seitz grid points:</span>

        <span class="n">ndegen</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">ndegen</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">nrpts</span><span class="p">:</span>
            <span class="n">ndegen</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="n">cols</span><span class="p">()))</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">divide_ndegen</span><span class="p">:</span>
            <span class="n">ndegen</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">ndegen</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">num_wann</span> <span class="o">=</span> <span class="n">nrpts</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="n">num_wann</span> <span class="o">=</span> <span class="n">comm</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">num_wann</span><span class="p">)</span>
    <span class="n">nrpts</span> <span class="o">=</span> <span class="n">comm</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">nrpts</span><span class="p">)</span>

    <span class="n">cells</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">nrpts</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">const</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">nrpts</span><span class="p">,</span> <span class="n">num_wann</span><span class="p">,</span> <span class="n">num_wann</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">comm</span><span class="o">.</span><span class="n">rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># read lattice vectors and hopping constants:</span>

        <span class="n">size</span> <span class="o">=</span> <span class="n">num_wann</span> <span class="o">**</span> <span class="mi">2</span>

        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nrpts</span><span class="p">):</span>

            <span class="k">if</span> <span class="n">tb</span><span class="p">:</span>
                <span class="n">cells</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">cols</span><span class="p">()))</span>

            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">size</span><span class="p">):</span>
                <span class="n">tmp</span> <span class="o">=</span> <span class="n">cols</span><span class="p">()</span>

                <span class="n">const</span><span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">tmp</span><span class="p">[</span><span class="o">-</span><span class="mi">4</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">tmp</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="nb">float</span><span class="p">(</span><span class="n">tmp</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="nb">float</span><span class="p">(</span><span class="n">tmp</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span> <span class="o">/</span> <span class="n">ndegen</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">tb</span><span class="p">:</span>
                <span class="n">cells</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">tmp</span><span class="p">[:</span><span class="mi">3</span><span class="p">]))</span>

        <span class="n">data</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="n">comm</span><span class="o">.</span><span class="n">Bcast</span><span class="p">(</span><span class="n">cells</span><span class="p">)</span>
    <span class="n">comm</span><span class="o">.</span><span class="n">Bcast</span><span class="p">(</span><span class="n">const</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">cells</span><span class="p">,</span> <span class="n">const</span></div>


<div class="viewcode-block" id="write_hrdat">
<a class="viewcode-back" href="../../modules/el.html#elphmod.el.write_hrdat">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">write_hrdat</span><span class="p">(</span><span class="n">seedname</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">ndegen</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Write *_hr.dat* file as generated by Wannier90.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    seedname : str</span>
<span class="sd">        Common prefix of Wannier90 input and output files.</span>
<span class="sd">    R : ndarray</span>
<span class="sd">        Lattice vectors of Wigner-Seitz supercell.</span>
<span class="sd">    H : ndarray</span>
<span class="sd">        Corresponding on-site energies and hoppings.</span>
<span class="sd">    ndegen : list of int</span>
<span class="sd">        Degeneracies of Wigner-Seitz lattice vectors. This is just what is</span>
<span class="sd">        written to the file header, and it is not used to further modify `H`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">time</span>

    <span class="n">R_orig</span> <span class="o">=</span> <span class="n">R</span>
    <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">R</span><span class="p">),</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">R</span><span class="p">[:,</span> <span class="p">:</span><span class="n">R_orig</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">R_orig</span>

    <span class="n">size</span> <span class="o">=</span> <span class="n">H</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">H</span> <span class="o">=</span> <span class="n">H</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">R</span><span class="p">),</span> <span class="n">size</span><span class="p">,</span> <span class="n">size</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">ndegen</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">ndegen</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">R</span><span class="p">))</span>

    <span class="n">order</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">lexsort</span><span class="p">(</span><span class="n">R</span><span class="o">.</span><span class="n">T</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">_hr.dat&#39;</span> <span class="o">%</span> <span class="n">seedname</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">hr</span><span class="p">:</span>
        <span class="n">hr</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s1">&#39; written on </span><span class="si">%d</span><span class="s1">%b%Y at %H:%M:%S</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">))</span>

        <span class="n">hr</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%12d</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">size</span><span class="p">)</span>
        <span class="n">hr</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%12d</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">R</span><span class="p">))</span>

        <span class="n">columns</span> <span class="o">=</span> <span class="mi">15</span>

        <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">order</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">hr</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%5d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">ndegen</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">n</span> <span class="o">%</span> <span class="n">columns</span> <span class="ow">or</span> <span class="n">n</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">R</span><span class="p">):</span>
                <span class="n">hr</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="n">form</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">%5d</span><span class="s1">&#39;</span> <span class="o">*</span> <span class="mi">5</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="si">%12.6f</span><span class="s1">&#39;</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">order</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">size</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">size</span><span class="p">):</span>
                    <span class="n">hr</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">form</span> <span class="o">%</span> <span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">R</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">R</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
                        <span class="n">a</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">b</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">H</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">]</span><span class="o">.</span><span class="n">real</span><span class="p">,</span> <span class="n">H</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">]</span><span class="o">.</span><span class="n">imag</span><span class="p">))</span></div>


<div class="viewcode-block" id="read_wsvecdat">
<a class="viewcode-back" href="../../modules/el.html#elphmod.el.read_wsvecdat">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">read_wsvecdat</span><span class="p">(</span><span class="n">wsvecdat</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Read *_wsvec.dat* file from Wannier90.&quot;&quot;&quot;</span>

    <span class="n">supvecs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">comm</span><span class="o">.</span><span class="n">rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">wsvecdat</span><span class="p">)</span> <span class="k">as</span> <span class="n">data</span><span class="p">:</span>
                <span class="nb">next</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

                <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
                    <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()))</span>

                    <span class="n">supvecs</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">a</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">b</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span>
                        <span class="nb">next</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">()))</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">data</span><span class="p">)))]</span>

        <span class="k">except</span> <span class="ne">FileNotFoundError</span><span class="p">:</span>
            <span class="n">supvecs</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Warning: File &quot;</span><span class="si">%s</span><span class="s1">&quot; not found!&#39;</span> <span class="o">%</span> <span class="n">wsvecdat</span><span class="p">)</span>

    <span class="n">supvecs</span> <span class="o">=</span> <span class="n">comm</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">supvecs</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">supvecs</span></div>


<div class="viewcode-block" id="k2r">
<a class="viewcode-back" href="../../modules/el.html#elphmod.el.k2r">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">k2r</span><span class="p">(</span><span class="n">el</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">fft</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">rydberg</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Interpolate Hamilontian matrices on uniform k-point mesh.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    el : :class:`Model`</span>
<span class="sd">        Tight-binding model.</span>
<span class="sd">    H : ndarray</span>
<span class="sd">        Hamiltonian matrices on complete uniform k-point mesh.</span>
<span class="sd">    a : ndarray</span>
<span class="sd">        Bravais lattice vectors.</span>
<span class="sd">    r : ndarray</span>
<span class="sd">        Positions of orbital centers.</span>
<span class="sd">    fft : bool</span>
<span class="sd">        Perform Fourier transform? If ``False``, only the mapping to the</span>
<span class="sd">        Wigner-Seitz cell is performed.</span>
<span class="sd">    rydberg : bool, default False</span>
<span class="sd">        Is input Hamiltonian given in Ry rather than eV units? This is</span>
<span class="sd">        independent of ``el.rydberg``, which is always respected.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">nk</span> <span class="o">=</span> <span class="n">H</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">el</span><span class="o">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">H</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>

    <span class="n">nk_orig</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">nk</span><span class="p">)</span>
    <span class="n">nk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">nk</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">nk_orig</span><span class="p">)]</span> <span class="o">=</span> <span class="n">nk_orig</span>

    <span class="k">if</span> <span class="n">fft</span><span class="p">:</span>
        <span class="n">H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="p">(</span><span class="o">*</span><span class="n">nk</span><span class="p">,</span> <span class="n">el</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">el</span><span class="o">.</span><span class="n">size</span><span class="p">))</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifftn</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">conj</span><span class="p">(),</span> <span class="n">axes</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">H</span>

    <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="p">(</span><span class="o">*</span><span class="n">nk</span><span class="p">,</span> <span class="n">el</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">el</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>

    <span class="n">el</span><span class="o">.</span><span class="n">R</span><span class="p">,</span> <span class="n">el</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">l</span> <span class="o">=</span> <span class="n">elphmod</span><span class="o">.</span><span class="n">bravais</span><span class="o">.</span><span class="n">short_range_model</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span>
        <span class="n">sgn</span><span class="o">=+</span><span class="mi">1</span><span class="p">,</span> <span class="n">divide_ndegen</span><span class="o">=</span><span class="n">el</span><span class="o">.</span><span class="n">divide_ndegen</span><span class="p">)</span>

    <span class="n">el</span><span class="o">.</span><span class="n">nk</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">nk</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">rydberg</span> <span class="o">!=</span> <span class="n">el</span><span class="o">.</span><span class="n">rydberg</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">rydberg</span><span class="p">:</span>
            <span class="n">el</span><span class="o">.</span><span class="n">data</span> <span class="o">*=</span> <span class="n">elphmod</span><span class="o">.</span><span class="n">misc</span><span class="o">.</span><span class="n">Ry</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">el</span><span class="o">.</span><span class="n">data</span> <span class="o">/=</span> <span class="n">elphmod</span><span class="o">.</span><span class="n">misc</span><span class="o">.</span><span class="n">Ry</span></div>


<div class="viewcode-block" id="read_bands">
<a class="viewcode-back" href="../../modules/el.html#elphmod.el.read_bands">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">read_bands</span><span class="p">(</span><span class="n">filband</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Read bands from *filband* just like Quantum ESRESSO&#39;s ``plotband.x``.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    filband : str</span>
<span class="sd">        Filename.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    k : ndarray</span>
<span class="sd">        k points in Cartesian coordiantes.</span>
<span class="sd">    bands : ndarray</span>
<span class="sd">        Band energies.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">comm</span><span class="o">.</span><span class="n">rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">filband</span><span class="p">)</span>

        <span class="n">header</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

        <span class="c1"># &amp;plot nbnd=  13, nks=  1296 /</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">nbnd</span><span class="p">,</span> <span class="n">nks</span> <span class="o">=</span> <span class="n">header</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;=&#39;</span><span class="p">)</span>
        <span class="n">nbnd</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">nbnd</span><span class="p">[:</span><span class="n">nbnd</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)])</span>
        <span class="n">nks</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">nks</span><span class="p">[:</span><span class="n">nks</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">nbnd</span> <span class="o">=</span> <span class="n">nks</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="n">nbnd</span> <span class="o">=</span> <span class="n">comm</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">nbnd</span><span class="p">)</span>
    <span class="n">nks</span> <span class="o">=</span> <span class="n">comm</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">nks</span><span class="p">)</span>

    <span class="n">k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">nks</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">nks</span><span class="p">))</span>
    <span class="n">bands</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">nbnd</span><span class="p">,</span> <span class="n">nks</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">comm</span><span class="o">.</span><span class="n">rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">ik</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nks</span><span class="p">):</span>
            <span class="n">k</span><span class="p">[</span><span class="n">ik</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span>
                <span class="nb">next</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">rstrip</span><span class="p">(</span><span class="s1">&#39;*&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">()[:</span><span class="mi">3</span><span class="p">]))</span>

            <span class="n">energies</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">energies</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">nbnd</span><span class="p">:</span>
                <span class="n">energies</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">next</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">())))</span>

            <span class="n">bands</span><span class="p">[:,</span> <span class="n">ik</span><span class="p">]</span> <span class="o">=</span> <span class="n">energies</span>

        <span class="n">data</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

        <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>

        <span class="k">for</span> <span class="n">ik</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nks</span><span class="p">):</span>
            <span class="n">dk</span> <span class="o">=</span> <span class="n">k</span><span class="p">[</span><span class="n">ik</span><span class="p">]</span> <span class="o">-</span> <span class="n">k</span><span class="p">[</span><span class="n">ik</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">x</span><span class="p">[</span><span class="n">ik</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">ik</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">dk</span><span class="p">,</span> <span class="n">dk</span><span class="p">))</span>

    <span class="n">comm</span><span class="o">.</span><span class="n">Bcast</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
    <span class="n">comm</span><span class="o">.</span><span class="n">Bcast</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">comm</span><span class="o">.</span><span class="n">Bcast</span><span class="p">(</span><span class="n">bands</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">k</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">bands</span></div>


<div class="viewcode-block" id="write_bands">
<a class="viewcode-back" href="../../modules/el.html#elphmod.el.write_bands">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">write_bands</span><span class="p">(</span><span class="n">filband</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">bands</span><span class="p">,</span> <span class="n">fmt</span><span class="o">=</span><span class="s1">&#39;</span><span class="si">%8.3f</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">cols</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Write bands to *filband* just like Quantum ESPRESSO&#39;s ``plotband.x``.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    filband : str</span>
<span class="sd">        Filename.</span>
<span class="sd">    k : ndarray</span>
<span class="sd">        k points in Cartesian coordiantes.</span>
<span class="sd">    bands : ndarray</span>
<span class="sd">        Band energies.</span>
<span class="sd">    fmt : str</span>
<span class="sd">        Format string for band energies.</span>
<span class="sd">    cols : int</span>
<span class="sd">        Number of band energies per line.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">comm</span><span class="o">.</span><span class="n">rank</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span>

    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filband</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">data</span><span class="p">:</span>
        <span class="n">data</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39; &amp;plot nbnd=</span><span class="si">%4d</span><span class="s1">, nks=</span><span class="si">%6d</span><span class="s1"> /</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bands</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">k</span><span class="p">)))</span>

        <span class="k">for</span> <span class="n">ik</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">k</span><span class="p">)):</span>
            <span class="n">data</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%20.6f</span><span class="s1"> </span><span class="si">%9.6f</span><span class="s1"> </span><span class="si">%9.6f</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">k</span><span class="p">[</span><span class="n">ik</span><span class="p">]))</span>

            <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">bands</span><span class="p">[:,</span> <span class="n">ik</span><span class="p">],</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">data</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39; &#39;</span> <span class="o">+</span> <span class="n">fmt</span> <span class="o">%</span> <span class="n">e</span><span class="p">)</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="n">n</span> <span class="o">%</span> <span class="n">cols</span> <span class="ow">or</span> <span class="n">n</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">bands</span><span class="p">):</span>
                    <span class="n">data</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="read_bands_plot">
<a class="viewcode-back" href="../../modules/el.html#elphmod.el.read_bands_plot">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">read_bands_plot</span><span class="p">(</span><span class="n">filbandgnu</span><span class="p">,</span> <span class="n">bands</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Read bands from *filband.gnu* produced by Quantum ESPRESSO&#39;s ``bands.x``.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    filbandgnu : str</span>
<span class="sd">        Name of file with plotted bands.</span>
<span class="sd">    bands : int</span>
<span class="sd">        Number of bands.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ndarray</span>
<span class="sd">        Cumulative reciprocal distance.</span>
<span class="sd">    ndarray</span>
<span class="sd">        Band energies.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">k</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="n">filbandgnu</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

    <span class="n">points</span> <span class="o">=</span> <span class="n">k</span><span class="o">.</span><span class="n">size</span> <span class="o">//</span> <span class="n">bands</span>

    <span class="n">k</span> <span class="o">=</span> <span class="n">k</span><span class="p">[:</span><span class="n">points</span><span class="p">]</span>
    <span class="n">e</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="p">(</span><span class="n">bands</span><span class="p">,</span> <span class="n">points</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>

    <span class="k">return</span> <span class="n">k</span><span class="p">,</span> <span class="n">e</span></div>


<div class="viewcode-block" id="read_symmetry_points">
<a class="viewcode-back" href="../../modules/el.html#elphmod.el.read_symmetry_points">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">read_symmetry_points</span><span class="p">(</span><span class="n">bandsout</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Read positions of symmetry points along path.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    bandsout : str</span>
<span class="sd">        File with standard output from Quantum ESPRESSO&#39;s ``bands.x``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    list</span>
<span class="sd">        Positions of symmetry points.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">points</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">bandsout</span><span class="p">)</span> <span class="k">as</span> <span class="n">data</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
            <span class="k">if</span> <span class="s1">&#39;x coordinate&#39;</span> <span class="ow">in</span> <span class="n">line</span><span class="p">:</span>
                <span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>

    <span class="k">return</span> <span class="n">points</span></div>


<div class="viewcode-block" id="read_atomic_projections">
<a class="viewcode-back" href="../../modules/el.html#elphmod.el.read_atomic_projections">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">read_atomic_projections</span><span class="p">(</span><span class="n">atomic_proj_xml</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">from_fermi</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">squared</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">other</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">order_kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Read projected bands from *outdir/prefix.save/atomic_proj.xml*.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    atomic_proj_xml : str</span>
<span class="sd">        XML file with atomic projections generated by ``projwfc.x``.</span>
<span class="sd">    order : bool</span>
<span class="sd">        Order/disentangle bands via their k-local character?</span>
<span class="sd">    from_fermi : bool</span>
<span class="sd">        Subtract Fermi level from electronic energies?</span>
<span class="sd">    squared : bool</span>
<span class="sd">        Return squared complex modulus of projection?</span>
<span class="sd">    other : bool</span>
<span class="sd">        Estimate projection onto &quot;other&quot; orbitals not defined in pseudopotential</span>
<span class="sd">        files as difference of band weights to one? This requires `squared`.</span>
<span class="sd">    **order_kwargs</span>
<span class="sd">        Keyword arguments passed to :func:`band_order`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ndarray</span>
<span class="sd">        k points.</span>
<span class="sd">    ndarray</span>
<span class="sd">        Cumulative path distance.</span>
<span class="sd">    ndarray</span>
<span class="sd">        Electronic energies.</span>
<span class="sd">    ndarray</span>
<span class="sd">        Projections onto (pseudo) atomic orbitals.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">comm</span><span class="o">.</span><span class="n">rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">atomic_proj_xml</span><span class="p">)</span>
        <span class="nb">next</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

        <span class="n">header</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s1">&#39;&lt;HEADER /&gt;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">header</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">item</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;=&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">header</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">))</span>
        <span class="n">header</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">((</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s1">&#39;&quot;&#39;</span><span class="p">))</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">header</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>

        <span class="n">bands</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;NUMBER_OF_BANDS&#39;</span><span class="p">])</span>
        <span class="n">nk</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;NUMBER_OF_K-POINTS&#39;</span><span class="p">])</span>
        <span class="n">no</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;NUMBER_OF_ATOMIC_WFC&#39;</span><span class="p">])</span>
        <span class="n">mu</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;FERMI_ENERGY&#39;</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">bands</span> <span class="o">=</span> <span class="n">nk</span> <span class="o">=</span> <span class="n">no</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="n">bands</span> <span class="o">=</span> <span class="n">comm</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">bands</span><span class="p">)</span>
    <span class="n">nk</span> <span class="o">=</span> <span class="n">comm</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">nk</span><span class="p">)</span>
    <span class="n">no</span> <span class="o">=</span> <span class="n">comm</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">no</span><span class="p">)</span>

    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">nk</span><span class="p">)</span>
    <span class="n">k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">nk</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
    <span class="n">eps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">nk</span><span class="p">,</span> <span class="n">bands</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">squared</span><span class="p">:</span>
        <span class="n">proj2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">nk</span><span class="p">,</span> <span class="n">bands</span><span class="p">,</span> <span class="n">no</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">other</span> <span class="k">else</span> <span class="n">no</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">comm</span><span class="o">.</span><span class="n">rank</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">squared</span><span class="p">:</span>
        <span class="n">proj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">nk</span><span class="p">,</span> <span class="n">bands</span><span class="p">,</span> <span class="n">no</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">comm</span><span class="o">.</span><span class="n">rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="nb">next</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">ik</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nk</span><span class="p">):</span>
            <span class="nb">next</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="c1"># &lt;K-POINT&gt;</span>
            <span class="n">k</span><span class="p">[</span><span class="n">ik</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">next</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">()))</span>
            <span class="nb">next</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="c1"># &lt;/K-POINT&gt;</span>

            <span class="nb">next</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="c1"># &lt;E&gt;</span>
            <span class="n">levels</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">levels</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">bands</span><span class="p">:</span>
                <span class="n">levels</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">next</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">())))</span>
            <span class="n">eps</span><span class="p">[</span><span class="n">ik</span><span class="p">]</span> <span class="o">=</span> <span class="n">levels</span>
            <span class="nb">next</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="c1"># &lt;/E&gt;</span>

            <span class="nb">next</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="c1"># &lt;PROJS&gt;</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">no</span><span class="p">):</span>
                <span class="nb">next</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="c1"># &lt;ATOMIC_WFC&gt;</span>
                <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">bands</span><span class="p">):</span>
                    <span class="n">Re</span><span class="p">,</span> <span class="n">Im</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">next</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">()))</span>
                    <span class="n">proj</span><span class="p">[</span><span class="n">ik</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">a</span><span class="p">]</span> <span class="o">=</span> <span class="n">Re</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">Im</span>
                <span class="nb">next</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="c1"># &lt;/ATOMIC_WFC&gt;</span>
            <span class="nb">next</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="c1"># &lt;/PROJS&gt;</span>

        <span class="n">data</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

        <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nk</span><span class="p">):</span>
            <span class="n">dk</span> <span class="o">=</span> <span class="n">k</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">k</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">dk</span><span class="p">,</span> <span class="n">dk</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">from_fermi</span><span class="p">:</span>
            <span class="n">eps</span> <span class="o">-=</span> <span class="n">mu</span>

        <span class="k">if</span> <span class="n">order</span><span class="p">:</span>
            <span class="n">o</span> <span class="o">=</span> <span class="n">elphmod</span><span class="o">.</span><span class="n">dispersion</span><span class="o">.</span><span class="n">band_order</span><span class="p">(</span><span class="n">eps</span><span class="p">,</span>
                <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">proj</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="o">**</span><span class="n">order_kwargs</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">ik</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nk</span><span class="p">):</span>
                <span class="n">eps</span><span class="p">[</span><span class="n">ik</span><span class="p">]</span> <span class="o">=</span> <span class="n">eps</span><span class="p">[</span><span class="n">ik</span><span class="p">,</span> <span class="n">o</span><span class="p">[</span><span class="n">ik</span><span class="p">]]</span>

                <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">no</span><span class="p">):</span>
                    <span class="n">proj</span><span class="p">[</span><span class="n">ik</span><span class="p">,</span> <span class="p">:,</span> <span class="n">a</span><span class="p">]</span> <span class="o">=</span> <span class="n">proj</span><span class="p">[</span><span class="n">ik</span><span class="p">,</span> <span class="n">o</span><span class="p">[</span><span class="n">ik</span><span class="p">],</span> <span class="n">a</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">squared</span><span class="p">:</span>
            <span class="n">proj2</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:</span><span class="n">no</span><span class="p">]</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">proj</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>

            <span class="k">if</span> <span class="n">other</span><span class="p">:</span>
                <span class="n">proj2</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">no</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">proj2</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:</span><span class="n">no</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

    <span class="n">comm</span><span class="o">.</span><span class="n">Bcast</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">comm</span><span class="o">.</span><span class="n">Bcast</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
    <span class="n">comm</span><span class="o">.</span><span class="n">Bcast</span><span class="p">(</span><span class="n">eps</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">squared</span><span class="p">:</span>
        <span class="n">comm</span><span class="o">.</span><span class="n">Bcast</span><span class="p">(</span><span class="n">proj2</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">comm</span><span class="o">.</span><span class="n">Bcast</span><span class="p">(</span><span class="n">proj</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">eps</span><span class="p">,</span> <span class="n">proj2</span> <span class="k">if</span> <span class="n">squared</span> <span class="k">else</span> <span class="n">proj</span></div>


<div class="viewcode-block" id="read_atomic_projections_old">
<a class="viewcode-back" href="../../modules/el.html#elphmod.el.read_atomic_projections_old">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">read_atomic_projections_old</span><span class="p">(</span><span class="n">atomic_proj_xml</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">from_fermi</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="o">**</span><span class="n">order_kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Read projected bands from *outdir/prefix.save/atomic_proj.xml*.&quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">comm</span><span class="o">.</span><span class="n">rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">atomic_proj_xml</span><span class="p">)</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">goto</span><span class="p">(</span><span class="n">pattern</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">pattern</span> <span class="ow">in</span> <span class="n">line</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">line</span>

        <span class="n">goto</span><span class="p">(</span><span class="s1">&#39;&lt;NUMBER_OF_BANDS &#39;</span><span class="p">)</span>
        <span class="n">bands</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>

        <span class="n">goto</span><span class="p">(</span><span class="s1">&#39;&lt;NUMBER_OF_K-POINTS &#39;</span><span class="p">)</span>
        <span class="n">nk</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>

        <span class="n">goto</span><span class="p">(</span><span class="s1">&#39;&lt;NUMBER_OF_ATOMIC_WFC &#39;</span><span class="p">)</span>
        <span class="n">no</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>

        <span class="n">goto</span><span class="p">(</span><span class="s1">&#39;&lt;FERMI_ENERGY &#39;</span><span class="p">)</span>
        <span class="n">mu</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">bands</span> <span class="o">=</span> <span class="n">nk</span> <span class="o">=</span> <span class="n">no</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="n">bands</span> <span class="o">=</span> <span class="n">comm</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">bands</span><span class="p">)</span>
    <span class="n">nk</span> <span class="o">=</span> <span class="n">comm</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">nk</span><span class="p">)</span>
    <span class="n">no</span> <span class="o">=</span> <span class="n">comm</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">no</span><span class="p">)</span>

    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">nk</span><span class="p">)</span>
    <span class="n">k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">nk</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
    <span class="n">eps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">nk</span><span class="p">,</span> <span class="n">bands</span><span class="p">))</span>
    <span class="n">proj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">nk</span><span class="p">,</span> <span class="n">bands</span><span class="p">,</span> <span class="n">no</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">comm</span><span class="o">.</span><span class="n">rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">goto</span><span class="p">(</span><span class="s1">&#39;&lt;K-POINTS &#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nk</span><span class="p">):</span>
            <span class="n">k</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">next</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">()))</span>

        <span class="k">for</span> <span class="n">ik</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nk</span><span class="p">):</span>
            <span class="n">goto</span><span class="p">(</span><span class="s1">&#39;&lt;EIG &#39;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">bands</span><span class="p">):</span>
                <span class="n">eps</span><span class="p">[</span><span class="n">ik</span><span class="p">,</span> <span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">ik</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nk</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">no</span><span class="p">):</span>
                <span class="n">goto</span><span class="p">(</span><span class="s1">&#39;&lt;ATMWFC.&#39;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">bands</span><span class="p">):</span>
                    <span class="n">Re</span><span class="p">,</span> <span class="n">Im</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">next</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)))</span>
                    <span class="n">proj</span><span class="p">[</span><span class="n">ik</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">a</span><span class="p">]</span> <span class="o">=</span> <span class="n">Re</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">Im</span>

        <span class="n">data</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

        <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nk</span><span class="p">):</span>
            <span class="n">dk</span> <span class="o">=</span> <span class="n">k</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">k</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">dk</span><span class="p">,</span> <span class="n">dk</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">from_fermi</span><span class="p">:</span>
            <span class="n">eps</span> <span class="o">-=</span> <span class="n">mu</span>

        <span class="k">if</span> <span class="n">order</span><span class="p">:</span>
            <span class="n">o</span> <span class="o">=</span> <span class="n">elphmod</span><span class="o">.</span><span class="n">dispersion</span><span class="o">.</span><span class="n">band_order</span><span class="p">(</span><span class="n">eps</span><span class="p">,</span>
                <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">proj</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="o">**</span><span class="n">order_kwargs</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">ik</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nk</span><span class="p">):</span>
                <span class="n">eps</span><span class="p">[</span><span class="n">ik</span><span class="p">]</span> <span class="o">=</span> <span class="n">eps</span><span class="p">[</span><span class="n">ik</span><span class="p">,</span> <span class="n">o</span><span class="p">[</span><span class="n">ik</span><span class="p">]]</span>

                <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">no</span><span class="p">):</span>
                    <span class="n">proj</span><span class="p">[</span><span class="n">ik</span><span class="p">,</span> <span class="p">:,</span> <span class="n">a</span><span class="p">]</span> <span class="o">=</span> <span class="n">proj</span><span class="p">[</span><span class="n">ik</span><span class="p">,</span> <span class="n">o</span><span class="p">[</span><span class="n">ik</span><span class="p">],</span> <span class="n">a</span><span class="p">]</span>

    <span class="n">comm</span><span class="o">.</span><span class="n">Bcast</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">comm</span><span class="o">.</span><span class="n">Bcast</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
    <span class="n">comm</span><span class="o">.</span><span class="n">Bcast</span><span class="p">(</span><span class="n">eps</span><span class="p">)</span>
    <span class="n">comm</span><span class="o">.</span><span class="n">Bcast</span><span class="p">(</span><span class="n">proj</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">eps</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">proj</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span></div>


<div class="viewcode-block" id="read_projwfc_out">
<a class="viewcode-back" href="../../modules/el.html#elphmod.el.read_projwfc_out">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">read_projwfc_out</span><span class="p">(</span><span class="n">projwfc_out</span><span class="p">,</span> <span class="n">other</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Identify orbitals in *atomic_proj.xml* via output of ``projwfc.x``.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    projwfc_out : str</span>
<span class="sd">        Output file of ``projwfc.x``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    list of str</span>
<span class="sd">        Common names of (pseudo) atomic orbitals listed in `projwfc_out` (in</span>
<span class="sd">        that order). If spin-orbit coupling is considered, symmetry labels</span>
<span class="sd">        related to the magnetic quantum number are omitted.</span>
<span class="sd">    other : bool, default True</span>
<span class="sd">        Add name ``X-x`` to list of orbitals, which corresponds to &quot;other&quot;</span>
<span class="sd">        orbitals from :func:`read_atomic_projections`?</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">comm</span><span class="o">.</span><span class="n">rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">orbitals</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">labels</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">[</span><span class="s1">&#39;s&#39;</span><span class="p">],</span>
            <span class="p">[</span><span class="s1">&#39;pz&#39;</span><span class="p">,</span> <span class="s1">&#39;px&#39;</span><span class="p">,</span> <span class="s1">&#39;py&#39;</span><span class="p">],</span>
            <span class="p">[</span><span class="s1">&#39;dz2&#39;</span><span class="p">,</span> <span class="s1">&#39;dxz&#39;</span><span class="p">,</span> <span class="s1">&#39;dyz&#39;</span><span class="p">,</span> <span class="s1">&#39;dx2-y2&#39;</span><span class="p">,</span> <span class="s1">&#39;dxy&#39;</span><span class="p">],</span>
            <span class="p">[</span><span class="s1">&#39;fz3&#39;</span><span class="p">,</span> <span class="s1">&#39;fxz2&#39;</span><span class="p">,</span> <span class="s1">&#39;fyz2&#39;</span><span class="p">,</span> <span class="s1">&#39;fz(x2-y2)&#39;</span><span class="p">,</span> <span class="s1">&#39;fxyz&#39;</span><span class="p">,</span> <span class="s1">&#39;fx(x2-3y2)&#39;</span><span class="p">,</span>
                <span class="s1">&#39;fy(3x2-y2)&#39;</span><span class="p">],</span>
        <span class="p">]</span>

        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">projwfc_out</span><span class="p">)</span> <span class="k">as</span> <span class="n">data</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
                <span class="k">if</span> <span class="s1">&#39;Atomic states used for projection&#39;</span> <span class="ow">in</span> <span class="n">line</span><span class="p">:</span>
                    <span class="nb">next</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
                    <span class="nb">next</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

                    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
                        <span class="n">info</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">rstrip</span><span class="p">()</span>

                        <span class="k">if</span> <span class="n">info</span><span class="p">:</span>
                            <span class="n">X</span> <span class="o">=</span> <span class="n">info</span><span class="p">[</span><span class="mi">28</span><span class="p">:</span><span class="mi">31</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
                            <span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">info</span><span class="p">[</span><span class="mi">38</span><span class="p">:</span><span class="mi">40</span><span class="p">])</span>
                            <span class="n">l</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">info</span><span class="p">[</span><span class="mi">44</span><span class="p">])</span>

                            <span class="k">if</span> <span class="n">info</span><span class="p">[</span><span class="mi">46</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;m&#39;</span><span class="p">:</span>
                                <span class="n">m</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">info</span><span class="p">[</span><span class="mi">48</span><span class="p">:</span><span class="mi">50</span><span class="p">])</span>

                                <span class="n">orbitals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">-</span><span class="si">%d%s</span><span class="s1">&#39;</span>
                                    <span class="o">%</span> <span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">labels</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]))</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">orbitals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">-</span><span class="si">%d%s</span><span class="s1">&#39;</span>
                                    <span class="o">%</span> <span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">labels</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]))</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">break</span>

            <span class="k">for</span> <span class="n">orbital</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">orbitals</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">orbitals</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">orbital</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">duplicates</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">orbitals</span><span class="p">))</span>
                        <span class="k">if</span> <span class="n">orbital</span> <span class="o">==</span> <span class="n">orbitals</span><span class="p">[</span><span class="n">n</span><span class="p">]]</span>

                    <span class="k">for</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">duplicates</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
                        <span class="n">orbitals</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">orbitals</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="s1">&#39;</span><span class="si">%d</span><span class="s1">-&#39;</span> <span class="o">%</span> <span class="n">m</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">other</span><span class="p">:</span>
                <span class="n">orbitals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;X-x&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">orbitals</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="n">orbitals</span> <span class="o">=</span> <span class="n">comm</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">orbitals</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">orbitals</span></div>


<div class="viewcode-block" id="proj_sum">
<a class="viewcode-back" href="../../modules/el.html#elphmod.el.proj_sum">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">proj_sum</span><span class="p">(</span><span class="n">proj</span><span class="p">,</span> <span class="n">orbitals</span><span class="p">,</span> <span class="o">*</span><span class="n">groups</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Sum over selected atomic projections.</span>

<span class="sd">    Example:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        proj = read_atomic_projections(&#39;atomic_proj.xml&#39;)</span>
<span class="sd">        orbitals = read_projwf_out(&#39;projwfc.out&#39;)</span>
<span class="sd">        proj = proj_sum(proj, orbitals, &#39;S-p&#39;, &#39;Ta-d{z2, x2-y2, xy}&#39;)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    proj : ndarray</span>
<span class="sd">        Atomic projections from :func:`read_atomic_projections`.</span>
<span class="sd">    orbitals : list of str</span>
<span class="sd">        Names of all orbitals from :func:`read_projwfc_out`.</span>
<span class="sd">    *groups</span>
<span class="sd">        Comma-separated lists of names of selected orbitals. Omitted name</span>
<span class="sd">        components are summed over. Curly braces are expanded.</span>
<span class="sd">    other : bool, default False</span>
<span class="sd">        Return remaining orbital weight too? If you just want to select the</span>
<span class="sd">        &quot;other&quot; orbitals from :func:`read_atomic_projections`, add the name</span>
<span class="sd">        ``x`` to `orbitals` instead.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ndarray</span>
<span class="sd">        Summed-over atomic projections.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">re</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">info</span><span class="p">(</span><span class="n">orbital</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;(?:([A-Z][a-z]?)(\d*))?-?(\d*)(?:([spdfx])(\S*))?&#39;</span><span class="p">,</span>
            <span class="n">orbital</span><span class="o">.</span><span class="n">strip</span><span class="p">())</span><span class="o">.</span><span class="n">groups</span><span class="p">()</span>

    <span class="n">other</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;other&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

    <span class="n">summed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="o">*</span><span class="n">proj</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">],</span>
        <span class="nb">len</span><span class="p">(</span><span class="n">groups</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">other</span> <span class="k">else</span> <span class="nb">len</span><span class="p">(</span><span class="n">groups</span><span class="p">)))</span>

    <span class="k">if</span> <span class="n">comm</span><span class="o">.</span><span class="n">rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">orbitals</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">orbitals</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">group</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">groups</span><span class="p">):</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

            <span class="k">for</span> <span class="n">selection</span> <span class="ow">in</span> <span class="nb">map</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">elphmod</span><span class="o">.</span><span class="n">misc</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">group</span><span class="p">)):</span>
                <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">orbital</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">orbitals</span><span class="p">):</span>
                    <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">A</span> <span class="o">==</span> <span class="n">B</span> <span class="k">for</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">selection</span><span class="p">,</span> <span class="n">orbital</span><span class="p">)</span> <span class="k">if</span> <span class="n">A</span><span class="p">):</span>
                        <span class="n">indices</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">indices</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Warning: &quot;</span><span class="si">%s</span><span class="s1">&quot; does not match any orbital!&#39;</span> <span class="o">%</span> <span class="n">group</span><span class="p">)</span>

            <span class="n">summed</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">proj</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">indices</span><span class="p">)]</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">other</span><span class="p">:</span>
            <span class="n">summed</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">summed</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

    <span class="n">comm</span><span class="o">.</span><span class="n">Bcast</span><span class="p">(</span><span class="n">summed</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">summed</span></div>


<div class="viewcode-block" id="read_Fermi_level">
<a class="viewcode-back" href="../../modules/el.html#elphmod.el.read_Fermi_level">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">read_Fermi_level</span><span class="p">(</span><span class="n">pw_scf_out</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Read Fermi level from output of self-consistent PW run.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    pw_scf_out : str</span>
<span class="sd">        PWscf output file.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    float</span>
<span class="sd">        Fermi level if found, ``None`` otherwise.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">eF</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">if</span> <span class="n">comm</span><span class="o">.</span><span class="n">rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">pw_scf_out</span><span class="p">)</span> <span class="k">as</span> <span class="n">data</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
                <span class="k">if</span> <span class="s1">&#39;the Fermi energy is&#39;</span> <span class="ow">in</span> <span class="n">line</span><span class="p">:</span>
                    <span class="n">eF</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span>
                <span class="k">elif</span> <span class="s1">&#39;highest occupied level&#39;</span> <span class="ow">in</span> <span class="n">line</span><span class="p">:</span>
                    <span class="n">eF</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">comm</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">eF</span><span class="p">)</span></div>


<div class="viewcode-block" id="read_pwo">
<a class="viewcode-back" href="../../modules/el.html#elphmod.el.read_pwo">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">read_pwo</span><span class="p">(</span><span class="n">pw_scf_out</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Read energies from PW output file.&quot;&quot;&quot;</span>

    <span class="n">Ne</span> <span class="o">=</span> <span class="n">Ns</span> <span class="o">=</span> <span class="n">Nk</span> <span class="o">=</span> <span class="n">E</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">e_given</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">if</span> <span class="n">comm</span><span class="o">.</span><span class="n">rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">pw_scf_out</span><span class="p">)</span> <span class="k">as</span> <span class="n">lines</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">lines</span><span class="p">:</span>
                <span class="k">if</span> <span class="s1">&#39;number of electrons&#39;</span> <span class="ow">in</span> <span class="n">line</span><span class="p">:</span>
                    <span class="n">Ne</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

                <span class="k">elif</span> <span class="s1">&#39;number of Kohn-Sham states&#39;</span> <span class="ow">in</span> <span class="n">line</span><span class="p">:</span>
                    <span class="n">Ns</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

                <span class="k">elif</span> <span class="s1">&#39;number of k points&#39;</span> <span class="ow">in</span> <span class="n">line</span><span class="p">:</span>
                    <span class="n">Nk</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">4</span><span class="p">])</span>

                <span class="k">elif</span> <span class="s1">&#39;the Fermi energy is&#39;</span> <span class="ow">in</span> <span class="n">line</span><span class="p">:</span>
                    <span class="n">eF</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span>

                <span class="k">elif</span> <span class="s1">&#39;highest occupied, lowest unoccupied level&#39;</span> <span class="ow">in</span> <span class="n">line</span><span class="p">:</span>
                    <span class="n">eF</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="o">-</span><span class="mi">2</span><span class="p">:]))</span> <span class="o">/</span> <span class="mi">2</span>

                <span class="k">elif</span> <span class="n">line</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;!&#39;</span><span class="p">):</span>
                    <span class="n">E</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span> <span class="o">*</span> <span class="n">elphmod</span><span class="o">.</span><span class="n">misc</span><span class="o">.</span><span class="n">Ry</span>

                <span class="k">elif</span> <span class="s1">&#39;End of self-consistent calculation&#39;</span> <span class="ow">in</span> <span class="n">line</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">e</span> <span class="o">=</span> <span class="p">[]</span>

                        <span class="k">for</span> <span class="n">ik</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Nk</span><span class="p">):</span>
                            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
                                <span class="nb">next</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span>

                            <span class="n">e</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>

                            <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">Ns</span><span class="p">:</span>
                                <span class="n">e</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span>
                                    <span class="nb">next</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">())))</span>

                        <span class="n">e_given</span> <span class="o">=</span> <span class="kc">True</span>

                    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                        <span class="k">pass</span>

        <span class="k">if</span> <span class="n">e_given</span> <span class="ow">and</span> <span class="n">eF</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">e</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="o">-</span> <span class="n">eF</span>

    <span class="n">Ne</span> <span class="o">=</span> <span class="n">comm</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">Ne</span><span class="p">)</span>
    <span class="n">Ns</span> <span class="o">=</span> <span class="n">comm</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">Ns</span><span class="p">)</span>
    <span class="n">Nk</span> <span class="o">=</span> <span class="n">comm</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">Nk</span><span class="p">)</span>
    <span class="n">E</span> <span class="o">=</span> <span class="n">comm</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">comm</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">e_given</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">comm</span><span class="o">.</span><span class="n">rank</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">e</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">Nk</span><span class="p">,</span> <span class="n">Ns</span><span class="p">))</span>

        <span class="n">comm</span><span class="o">.</span><span class="n">Bcast</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">e</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">return</span> <span class="n">e</span><span class="p">,</span> <span class="n">Ne</span><span class="p">,</span> <span class="n">E</span></div>


<div class="viewcode-block" id="read_wannier90_eig_file">
<a class="viewcode-back" href="../../modules/el.html#elphmod.el.read_wannier90_eig_file">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">read_wannier90_eig_file</span><span class="p">(</span><span class="n">seedname</span><span class="p">,</span> <span class="n">num_bands</span><span class="p">,</span> <span class="n">nkpts</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Read Kohn-Sham energies (eV) from the Wannier90 output seedname.eig file.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    seedname : str</span>
<span class="sd">        For example &#39;tas2&#39;, if the file is named &#39;tas2.eig&#39;.</span>
<span class="sd">    num_bands : int</span>
<span class="sd">        Number of bands in your pseudopotential.</span>
<span class="sd">    nkpts : int</span>
<span class="sd">        Number of k points in your Wannier90 calculations.</span>
<span class="sd">        For example 1296 for 36x36x1.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ndarray</span>
<span class="sd">        Kohn-Sham energies: ``eig[num_bands, nkpts]``.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">eig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">num_bands</span><span class="p">,</span> <span class="n">nkpts</span><span class="p">))</span>

    <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">seedname</span> <span class="o">+</span> <span class="s1">&#39;.eig&#39;</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span>
    <span class="n">lines</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">readlines</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">lineI</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">lines</span><span class="p">)):</span>
        <span class="n">bandI</span><span class="p">,</span> <span class="n">kI</span><span class="p">,</span> <span class="n">eigI</span> <span class="o">=</span> <span class="n">lines</span><span class="p">[</span><span class="n">lineI</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>

        <span class="n">eig</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">bandI</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">kI</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">eigI</span><span class="p">)</span>

    <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">eig</span></div>


<div class="viewcode-block" id="read_eps_nk_from_qe_pwo">
<a class="viewcode-back" href="../../modules/el.html#elphmod.el.read_eps_nk_from_qe_pwo">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">read_eps_nk_from_qe_pwo</span><span class="p">(</span><span class="n">pw_scf_out</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Read electronic eigenenergies and k points and calculate the occupations.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    pw_scf_out : str</span>
<span class="sd">        Name of the output file (typically ``&#39;pw.out&#39;`` or ``&#39;scf.out&#39;``).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    energies : ndarray</span>
<span class="sd">        Electronic eigenenergies (``eps_nk``) from ``scf`` output, shape ``(nk,</span>
<span class="sd">        nbnd)``.</span>
<span class="sd">    kpoints : ndarray</span>
<span class="sd">        k points and weights from ``scf`` output, shape ``(nk, 4)``, where the</span>
<span class="sd">        4th column contains the weights.</span>
<span class="sd">    f_occ : ndarray</span>
<span class="sd">        Occupations of ``eps_nk`` (same shape as `energies`).</span>
<span class="sd">    smearing_type : str</span>
<span class="sd">        Type of smearing (for example ``&#39;Fermi-Dirac&#39;``).</span>
<span class="sd">    mu : float</span>
<span class="sd">        Chemical potential in eV.</span>
<span class="sd">    kT : float</span>
<span class="sd">        Value of smearing (``degauss``) in eV.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">scf_file</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">pw_scf_out</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span>
    <span class="n">lines</span> <span class="o">=</span> <span class="n">scf_file</span><span class="o">.</span><span class="n">readlines</span><span class="p">()</span>
    <span class="n">scf_file</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="c1"># read number of k points and smearing:</span>

    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">lines</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">lines</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;     number of k points=&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>

            <span class="n">line_index</span> <span class="o">=</span> <span class="n">ii</span>

    <span class="n">smearing_line</span> <span class="o">=</span> <span class="n">lines</span><span class="p">[</span><span class="n">line_index</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
    <span class="n">nk</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">smearing_line</span><span class="p">[</span><span class="mi">4</span><span class="p">])</span>
    <span class="n">smearing_type</span> <span class="o">=</span> <span class="n">smearing_line</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">elphmod</span><span class="o">.</span><span class="n">occupations</span><span class="o">.</span><span class="n">smearing</span><span class="p">(</span><span class="n">smearing_type</span><span class="p">)</span>
    <span class="n">kT</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">smearing_line</span><span class="p">[</span><span class="mi">9</span><span class="p">])</span>

    <span class="n">k_Points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="n">nk</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>

    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nk</span><span class="p">):</span>
        <span class="p">(</span><span class="n">kb</span><span class="p">,</span> <span class="n">einsb</span><span class="p">,</span> <span class="n">eq</span><span class="p">,</span> <span class="n">bra</span><span class="p">,</span> <span class="n">kx</span><span class="p">,</span> <span class="n">ky</span><span class="p">,</span> <span class="n">kz</span><span class="p">,</span> <span class="n">wk_s</span><span class="p">,</span> <span class="n">eq2</span><span class="p">,</span>
            <span class="n">wk</span><span class="p">)</span> <span class="o">=</span> <span class="n">lines</span><span class="p">[</span><span class="n">line_index</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>

        <span class="n">kx</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">kx</span><span class="p">)</span>
        <span class="n">ky</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">ky</span><span class="p">)</span>
        <span class="n">kz</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">kz</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span>

        <span class="n">wk</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">wk</span><span class="p">)</span>

        <span class="n">k_Points</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">kx</span>
        <span class="n">k_Points</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">ky</span>
        <span class="n">k_Points</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">kz</span>
        <span class="n">k_Points</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">wk</span>

    <span class="c1"># read number of Kohn-Sham states:</span>

    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">lines</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">lines</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;     number of Kohn-Sham&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">KS_index</span> <span class="o">=</span> <span class="n">ii</span>

    <span class="n">nbnd</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">lines</span><span class="p">[</span><span class="n">KS_index</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">4</span><span class="p">])</span>

    <span class="c1"># read all energies for all the different k points and Kohn-Sham States:</span>

    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">lines</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">lines</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;     End of&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">state_start_index</span> <span class="o">=</span> <span class="n">ii</span> <span class="o">+</span> <span class="mi">4</span>

    <span class="n">energies</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nk</span><span class="p">,</span> <span class="n">nbnd</span><span class="p">))</span>
    <span class="n">f_occ</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nk</span><span class="p">,</span> <span class="n">nbnd</span><span class="p">))</span>

    <span class="c1"># the states are written in columns of size 8</span>
    <span class="c1"># with divmod we check how many rows we have</span>
    <span class="n">state_lines</span> <span class="o">=</span> <span class="nb">divmod</span><span class="p">(</span><span class="n">nbnd</span><span class="p">,</span> <span class="mi">8</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">divmod</span><span class="p">(</span><span class="n">nbnd</span><span class="p">,</span> <span class="mi">8</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">state_lines</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">for</span> <span class="n">ik</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nk</span><span class="p">):</span>
        <span class="n">energies_per_k</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">istate</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">state_lines</span><span class="p">):</span>
            <span class="n">energies_per_k</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">lines</span><span class="p">[</span><span class="n">state_start_index</span>
                <span class="o">+</span> <span class="n">istate</span> <span class="o">+</span> <span class="p">(</span><span class="n">state_lines</span> <span class="o">+</span> <span class="mi">3</span><span class="p">)</span> <span class="o">*</span> <span class="n">ik</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">())</span>

        <span class="n">energies</span><span class="p">[</span><span class="n">ik</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">energies_per_k</span><span class="p">)</span>

    <span class="c1"># kT: from Ry to eV</span>
    <span class="n">kT</span> <span class="o">*=</span> <span class="n">elphmod</span><span class="o">.</span><span class="n">misc</span><span class="o">.</span><span class="n">Ry</span>
    <span class="c1"># read chemical potential</span>
    <span class="n">mu</span> <span class="o">=</span> <span class="n">read_Fermi_level</span><span class="p">(</span><span class="n">pw_scf_out</span><span class="p">)</span>
    <span class="c1"># calculate occupations for all energies (eps_nk)</span>
    <span class="n">f_occ</span> <span class="o">=</span> <span class="n">f</span><span class="p">((</span><span class="n">energies</span> <span class="o">-</span> <span class="n">mu</span><span class="p">)</span> <span class="o">/</span> <span class="n">kT</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">energies</span><span class="p">,</span> <span class="n">k_Points</span><span class="p">,</span> <span class="n">f_occ</span><span class="p">,</span> <span class="n">smearing_type</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">kT</span></div>


<div class="viewcode-block" id="eband">
<a class="viewcode-back" href="../../modules/el.html#elphmod.el.eband">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">eband</span><span class="p">(</span><span class="n">pw_scf_out</span><span class="p">,</span> <span class="n">subset</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate ``eband`` part of one-electron energy.</span>

<span class="sd">    The &#39;one-electron contribution&#39; energy in the Quantum ESPRESSO PWscf output</span>
<span class="sd">    is a sum ``eband + deband``. Here, we can calculate the ``eband`` part.</span>

<span class="sd">    To compare it with the Quantum ESPRESSO result, you need to modify</span>
<span class="sd">    the ``SUBROUTINE print_energies ( printout )`` from *electrons.f90*.</span>

<span class="sd">    Change::</span>

<span class="sd">        WRITE( stdout, 9062 ) (eband + deband), ehart, ( etxc - etxcc ), ewld</span>

<span class="sd">    to::</span>

<span class="sd">        WRITE( stdout, 9062 ) eband, &amp;</span>
<span class="sd">           (eband + deband), ehart, ( etxc - etxcc ), ewld</span>

<span class="sd">    and::</span>

<span class="sd">        9062 FORMAT( &#39;     one-electron contribution =&#39;,F17.8,&#39; Ry&#39; &amp;</span>

<span class="sd">    to::</span>

<span class="sd">        9062 FORMAT( &#39;     sum bands                 =&#39;,F17.8,&#39; Ry&#39; &amp;</span>
<span class="sd">                    /&#39;     one-electron contribution =&#39;,F17.8,&#39; Ry&#39; &amp;</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    pw_scf_out : str</span>
<span class="sd">        Name of the output file (typically ``&#39;pw.out&#39;`` or ``&#39;scf.out&#39;``).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    eband : float</span>
<span class="sd">        The band energy.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">energies</span><span class="p">,</span> <span class="n">kpoints</span><span class="p">,</span> <span class="n">f_occ</span><span class="p">,</span> <span class="n">smearing_type</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">kT</span> <span class="o">=</span> <span class="n">read_eps_nk_from_qe_pwo</span><span class="p">(</span>
        <span class="n">pw_scf_out</span><span class="p">)</span>
    <span class="n">nk</span><span class="p">,</span> <span class="n">nbnd</span> <span class="o">=</span> <span class="n">energies</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">eband</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">energies</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">subset</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">ik</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nk</span><span class="p">):</span>
            <span class="n">wk</span> <span class="o">=</span> <span class="n">kpoints</span><span class="p">[</span><span class="n">ik</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="c1"># weights</span>
            <span class="k">for</span> <span class="n">iband</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nbnd</span><span class="p">):</span>
                <span class="n">eband</span><span class="p">[</span><span class="n">ik</span><span class="p">,</span> <span class="n">iband</span><span class="p">]</span> <span class="o">=</span> <span class="n">energies</span><span class="p">[</span><span class="n">ik</span><span class="p">,</span> <span class="n">iband</span><span class="p">]</span> <span class="o">*</span> <span class="n">wk</span> <span class="o">*</span> <span class="n">f_occ</span><span class="p">[</span><span class="n">ik</span><span class="p">,</span> <span class="n">iband</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">ik</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nk</span><span class="p">):</span>
            <span class="n">wk</span> <span class="o">=</span> <span class="n">kpoints</span><span class="p">[</span><span class="n">ik</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">iband</span> <span class="ow">in</span> <span class="n">subset</span><span class="p">:</span>
                <span class="n">eband</span><span class="p">[</span><span class="n">ik</span><span class="p">,</span> <span class="n">iband</span><span class="p">]</span> <span class="o">=</span> <span class="n">energies</span><span class="p">[</span><span class="n">ik</span><span class="p">,</span> <span class="n">iband</span><span class="p">]</span> <span class="o">*</span> <span class="n">wk</span> <span class="o">*</span> <span class="n">f_occ</span><span class="p">[</span><span class="n">ik</span><span class="p">,</span> <span class="n">iband</span><span class="p">]</span>

    <span class="n">eband</span> <span class="o">=</span> <span class="n">eband</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">/</span> <span class="n">elphmod</span><span class="o">.</span><span class="n">misc</span><span class="o">.</span><span class="n">Ry</span>

    <span class="k">return</span> <span class="n">eband</span></div>


<div class="viewcode-block" id="demet_from_qe_pwo">
<a class="viewcode-back" href="../../modules/el.html#elphmod.el.demet_from_qe_pwo">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">demet_from_qe_pwo</span><span class="p">(</span><span class="n">pw_scf_out</span><span class="p">,</span> <span class="n">subset</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate the entropy contribution :math:`-TS` to the total free energy.</span>

<span class="sd">    In Quantum ESPRESSO ``demet`` is calculated in ``gweights.f90``.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    pw_scf_out : str</span>
<span class="sd">        The name of the output file (typically ``&#39;pw.out&#39;``).</span>
<span class="sd">    subset : list or array</span>
<span class="sd">        List of indices to pick only a subset of the bands for the integration.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    demet : float</span>
<span class="sd">        The :math:`-TS` contribution to the total free energy.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">energies</span><span class="p">,</span> <span class="n">kpoints</span><span class="p">,</span> <span class="n">f_occ</span><span class="p">,</span> <span class="n">smearing_type</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">kT</span> <span class="o">=</span> <span class="n">read_eps_nk_from_qe_pwo</span><span class="p">(</span>
        <span class="n">pw_scf_out</span><span class="p">)</span>
    <span class="n">nk</span><span class="p">,</span> <span class="n">nbnd</span> <span class="o">=</span> <span class="n">energies</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">demet</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">energies</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="n">f</span> <span class="o">=</span> <span class="n">elphmod</span><span class="o">.</span><span class="n">occupations</span><span class="o">.</span><span class="n">smearing</span><span class="p">(</span><span class="n">smearing_type</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">subset</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">ik</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nk</span><span class="p">):</span>
            <span class="n">wk</span> <span class="o">=</span> <span class="n">kpoints</span><span class="p">[</span><span class="n">ik</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">iband</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nbnd</span><span class="p">):</span>
                <span class="n">w1gauss</span> <span class="o">=</span> <span class="o">-</span><span class="n">f</span><span class="o">.</span><span class="n">entropy</span><span class="p">((</span><span class="n">energies</span><span class="p">[</span><span class="n">ik</span><span class="p">,</span> <span class="n">iband</span><span class="p">]</span> <span class="o">-</span> <span class="n">mu</span><span class="p">)</span> <span class="o">/</span> <span class="n">kT</span><span class="p">)</span>
                <span class="n">demet</span><span class="p">[</span><span class="n">ik</span><span class="p">,</span> <span class="n">iband</span><span class="p">]</span> <span class="o">=</span> <span class="n">wk</span> <span class="o">*</span> <span class="n">kT</span> <span class="o">*</span> <span class="n">w1gauss</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">ik</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nk</span><span class="p">):</span>
            <span class="n">wk</span> <span class="o">=</span> <span class="n">kpoints</span><span class="p">[</span><span class="n">ik</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">iband</span> <span class="ow">in</span> <span class="n">subset</span><span class="p">:</span>
                <span class="n">w1gauss</span> <span class="o">=</span> <span class="o">-</span><span class="n">f</span><span class="o">.</span><span class="n">entropy</span><span class="p">((</span><span class="n">energies</span><span class="p">[</span><span class="n">ik</span><span class="p">,</span> <span class="n">iband</span><span class="p">]</span> <span class="o">-</span> <span class="n">mu</span><span class="p">)</span> <span class="o">/</span> <span class="n">kT</span><span class="p">)</span>
                <span class="n">demet</span><span class="p">[</span><span class="n">ik</span><span class="p">,</span> <span class="n">iband</span><span class="p">]</span> <span class="o">=</span> <span class="n">wk</span> <span class="o">*</span> <span class="n">kT</span> <span class="o">*</span> <span class="n">w1gauss</span>

    <span class="n">demet</span> <span class="o">=</span> <span class="n">demet</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">/</span> <span class="n">elphmod</span><span class="o">.</span><span class="n">misc</span><span class="o">.</span><span class="n">Ry</span>

    <span class="k">return</span> <span class="n">demet</span></div>


<div class="viewcode-block" id="read_decayH">
<a class="viewcode-back" href="../../modules/el.html#elphmod.el.read_decayH">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">read_decayH</span><span class="p">(</span><span class="n">file</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Read *decay.H* output from EPW.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    file : str</span>
<span class="sd">        The name of the *decay.H* output from EPW.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    R : ndarray</span>
<span class="sd">        The distance of every Wigner-Seitz grid point measured from the center</span>
<span class="sd">        in angstrom.</span>
<span class="sd">    H : ndarray</span>
<span class="sd">        The maximum absolute value of the elements of the Hamiltonian matrix in</span>
<span class="sd">        rydberg.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">file</span><span class="p">)</span> <span class="k">as</span> <span class="n">f_decay</span><span class="p">:</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="n">f_decay</span><span class="o">.</span><span class="n">readlines</span><span class="p">()</span>

    <span class="n">R_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">H_list</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># read in lines with 2 entries:</span>
    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">lines</span><span class="p">)):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lines</span><span class="p">[</span><span class="n">line</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">())</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">R_str</span><span class="p">,</span> <span class="n">H_str</span> <span class="o">=</span> <span class="n">lines</span><span class="p">[</span><span class="n">line</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
            <span class="n">R_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">R_str</span><span class="p">))</span>
            <span class="n">H_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">H_str</span><span class="p">))</span>

    <span class="c1"># convert list to NumPy array:</span>
    <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">R_list</span><span class="p">)</span>
    <span class="n">H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">H_list</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">R</span><span class="p">,</span> <span class="n">H</span></div>


<div class="viewcode-block" id="decayH">
<a class="viewcode-back" href="../../modules/el.html#elphmod.el.decayH">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">decayH</span><span class="p">(</span><span class="n">seedname</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate the decay of the Hamiltonian.</span>

<span class="sd">    This function should yield the same data as :func:`read_decayH`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    seedname : str</span>
<span class="sd">        Prefix of Wannier90 output file.</span>

<span class="sd">    **kwargs</span>
<span class="sd">        Arguments for :func:`elphmod.bravais.primitives`: Choose the right</span>
<span class="sd">        Bravais lattice (``ibrav``) and lattice constants (``a, b, c, ...``).</span>

<span class="sd">        For a simple cubic lattice: ``decayH(seedname, ibrav=1, a=a)``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    R : ndarray</span>
<span class="sd">        The distance of every Wigner-Seitz grid point measured from the center</span>
<span class="sd">        in angstrom.</span>
<span class="sd">    H : ndarray</span>
<span class="sd">        The maximum absolute value of the elements of the Hamiltonian matrix in</span>
<span class="sd">        rydberg.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">bravais_vectors</span> <span class="o">=</span> <span class="n">elphmod</span><span class="o">.</span><span class="n">bravais</span><span class="o">.</span><span class="n">primitives</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="n">el</span> <span class="o">=</span> <span class="n">Model</span><span class="p">(</span><span class="n">seedname</span><span class="p">,</span> <span class="n">divide_ndegen</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">el</span><span class="o">.</span><span class="n">R</span><span class="p">))</span>
    <span class="n">H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">el</span><span class="o">.</span><span class="n">R</span><span class="p">))</span>

    <span class="c1"># loop over all Wigner-seitz grid points</span>
    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">el</span><span class="o">.</span><span class="n">R</span><span class="p">)):</span>

        <span class="n">distance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">xi</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
            <span class="n">distance</span><span class="p">[</span><span class="n">xi</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">el</span><span class="o">.</span><span class="n">R</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="n">xi</span><span class="p">]</span> <span class="o">*</span> <span class="n">bravais_vectors</span><span class="p">[</span><span class="n">xi</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">distance</span> <span class="o">=</span> <span class="n">distance</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="n">R</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">distance</span><span class="p">)</span>
        <span class="n">H</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">el</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">ii</span><span class="p">]))</span> <span class="o">/</span> <span class="n">elphmod</span><span class="o">.</span><span class="n">misc</span><span class="o">.</span><span class="n">Ry</span>

    <span class="k">return</span> <span class="n">R</span><span class="p">,</span> <span class="n">H</span></div>


<div class="viewcode-block" id="read_energy_contributions_scf_out">
<a class="viewcode-back" href="../../modules/el.html#elphmod.el.read_energy_contributions_scf_out">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">read_energy_contributions_scf_out</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Read energy contributions to the total energy ``scf`` output file.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    filename : str</span>
<span class="sd">        Name of Quantum ESPRESSO&#39;s ``scf`` output file.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dict</span>
<span class="sd">        Energy contributions.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">comm</span><span class="o">.</span><span class="n">rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">energies</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span> <span class="k">as</span> <span class="n">lines</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">lines</span><span class="p">:</span>
                <span class="n">words</span> <span class="o">=</span> <span class="p">[</span><span class="n">word</span>
                    <span class="k">for</span> <span class="n">column</span> <span class="ow">in</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
                    <span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">column</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;=&#39;</span><span class="p">)</span> <span class="k">if</span> <span class="n">word</span><span class="p">]</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="n">words</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="n">key</span> <span class="o">=</span> <span class="n">words</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>

                <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="s1">&#39;sum bands&#39;</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">words</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;sum&#39;</span><span class="p">:</span>
                        <span class="n">energies</span><span class="p">[</span><span class="s1">&#39;sum bands&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">words</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                <span class="k">elif</span> <span class="n">key</span> <span class="ow">in</span> <span class="s1">&#39;one-electron contribution&#39;</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">words</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;one-electron&#39;</span><span class="p">:</span>
                        <span class="n">energies</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">words</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                <span class="k">elif</span> <span class="n">key</span> <span class="ow">in</span> <span class="s1">&#39;hartree contribution&#39;</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">words</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;hartree&#39;</span><span class="p">:</span>
                        <span class="n">energies</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">words</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                <span class="k">elif</span> <span class="n">key</span> <span class="ow">in</span> <span class="s1">&#39;xc contribution&#39;</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">words</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;xc&#39;</span><span class="p">:</span>
                        <span class="n">energies</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">words</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                <span class="k">elif</span> <span class="n">key</span> <span class="ow">in</span> <span class="s1">&#39;ewald contribution&#39;</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">words</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;ewald&#39;</span><span class="p">:</span>
                        <span class="n">energies</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">words</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                <span class="k">elif</span> <span class="n">key</span> <span class="ow">in</span> <span class="s1">&#39;smearing contrib.&#39;</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">words</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;smearing&#39;</span><span class="p">:</span>
                        <span class="n">energies</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">words</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
                <span class="k">elif</span> <span class="n">key</span> <span class="ow">in</span> <span class="s1">&#39;!&#39;</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">words</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;!&#39;</span><span class="p">:</span>
                        <span class="n">energies</span><span class="p">[</span><span class="s1">&#39;total&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">words</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="n">energies</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="n">energies</span> <span class="o">=</span> <span class="n">comm</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">energies</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">energies</span></div>


<div class="viewcode-block" id="read_pp_density">
<a class="viewcode-back" href="../../modules/el.html#elphmod.el.read_pp_density">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">read_pp_density</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Read file *filout* with charge density generated by ``pp.x``.</span>

<span class="sd">    Calculate total charge</span>

<span class="sd">    .. math::</span>

<span class="sd">        Q = \int \rho(\vec r) dx dy dz =</span>
<span class="sd">            = \frac \Omega {n_1 n_2 n_3} \sum_{i j k} \rho_{i j k},</span>

<span class="sd">    where :math:`\Omega` is the unit-cell volume, :math:`n_r` are the FFT grid</span>
<span class="sd">    dimensions, and :math:`i, j, k` run over FFT real-space grid points.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    filename : str</span>
<span class="sd">        Filename.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    rho : ndarray</span>
<span class="sd">        Electronic charge density :math:`\rho_{i j k}` on FFT real-space grid</span>
<span class="sd">        points.</span>
<span class="sd">    tot_charge: float</span>
<span class="sd">        Total charge calculated from charge density :math:`\rho_{i j k}`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span> <span class="k">as</span> <span class="n">data</span><span class="p">:</span>
        <span class="c1"># read all words of current line:</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">cells</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
                <span class="n">words</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>

                <span class="k">if</span> <span class="n">words</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">words</span>

        <span class="c1"># read table:</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">table</span><span class="p">(</span><span class="n">rows</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="n">cells</span><span class="p">()))</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">rows</span><span class="p">)])</span>

        <span class="c1"># read FFT dimensions, ntyp, nat</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">cells</span><span class="p">()</span>
<span class="c1">#        FFT_dim = list(map(int, tmp[:3]))</span>
        <span class="n">FFT_dim</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">tmp</span><span class="p">[:</span><span class="mi">6</span><span class="p">]))</span>
        <span class="n">nat</span><span class="p">,</span> <span class="n">ntyp</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">tmp</span><span class="p">[</span><span class="mi">6</span><span class="p">:]))</span>

        <span class="c1"># read ibrav, celldm</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">cells</span><span class="p">()</span>
        <span class="n">ibrav</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">tmp</span><span class="p">[:</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">celldm</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="n">tmp</span><span class="p">[</span><span class="mi">1</span><span class="p">:]))</span>

        <span class="c1"># read unknown line</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">cells</span><span class="p">()</span>
        <span class="n">kin_energy_cutoff</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">tmp</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>

        <span class="c1"># calculate unit cell and brillouin zone volume</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">elphmod</span><span class="o">.</span><span class="n">bravais</span><span class="o">.</span><span class="n">primitives</span><span class="p">(</span><span class="n">ibrav</span><span class="p">)</span>
        <span class="n">A</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">celldm</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">uc_volume</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="o">*</span> <span class="n">celldm</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">**</span> <span class="mi">3</span>
<span class="c1">#        B1, B2, B3 = elphmod.bravais.reciprocals(*A)</span>
<span class="c1">#        B = np.stack((B1, B2, B3), axis=0)</span>
<span class="c1">#        print(B)</span>
<span class="c1">#        print(np.linalg.det(B) * (2 * np.pi / celldm[0]) ** 3)</span>

        <span class="c1"># read valence table</span>
        <span class="n">at</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">valence</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ntyp</span><span class="p">):</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">cells</span><span class="p">()</span>
            <span class="n">at</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tmp</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">valence</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">tmp</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>

        <span class="c1"># read tau table</span>
        <span class="n">tau</span> <span class="o">=</span> <span class="n">table</span><span class="p">(</span><span class="n">nat</span><span class="p">)[</span><span class="mi">0</span><span class="p">:</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span>

        <span class="c1"># read rho table</span>
        <span class="c1"># total number of real-space grid points:</span>
        <span class="n">nr_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">FFT_dim</span><span class="p">[:</span><span class="mi">3</span><span class="p">])</span>
        <span class="c1"># separated into columns of 5:</span>
        <span class="k">if</span> <span class="nb">divmod</span><span class="p">(</span><span class="n">nr_points</span><span class="p">,</span> <span class="mi">5</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Warning: Total number of grid points is not divisible by 5!&#39;</span><span class="p">)</span>
        <span class="n">rho</span> <span class="o">=</span> <span class="n">table</span><span class="p">(</span><span class="nb">divmod</span><span class="p">(</span><span class="n">nr_points</span><span class="p">,</span> <span class="mi">5</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>

        <span class="n">tot_charge</span> <span class="o">=</span> <span class="n">rho</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">/</span> <span class="n">nr_points</span> <span class="o">*</span> <span class="n">uc_volume</span>

        <span class="n">rho</span> <span class="o">=</span> <span class="n">rho</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">FFT_dim</span><span class="p">[:</span><span class="mi">3</span><span class="p">]))</span>

        <span class="k">return</span> <span class="n">rho</span><span class="p">,</span> <span class="n">tot_charge</span></div>


<div class="viewcode-block" id="read_rhoG_density">
<a class="viewcode-back" href="../../modules/el.html#elphmod.el.read_rhoG_density">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">read_rhoG_density</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">ibrav</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Read the charge density output from Quantum ESPRESSO.</span>

<span class="sd">    The purpose of :math:`\rho(\vec G)` is to calculate the charge density in</span>
<span class="sd">    real space :math:`\rho(\vec r)` or the Hartree energy ``ehart``.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    filename : str</span>
<span class="sd">        Filename.</span>
<span class="sd">    ibrav : integer</span>
<span class="sd">        Bravais lattice index (see ``pw.x`` input description).</span>
<span class="sd">    a, b, c : float</span>
<span class="sd">        Bravais lattice parameters.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    rho_g : ndarray</span>
<span class="sd">        Electronic charge density :math:`\rho(\vec G)` on reciprocal-space grid</span>
<span class="sd">        points.</span>
<span class="sd">    g_vect : ndarray</span>
<span class="sd">        Reciprocal lattice vectors :math:`\vec G`.</span>
<span class="sd">    ngm_g : integer</span>
<span class="sd">        Number of reciprocal lattice vectors.</span>
<span class="sd">    uc_volume : float</span>
<span class="sd">        Unit-cell volume.</span>
<span class="sd">    mill_g : ndarray</span>
<span class="sd">        Miller indices.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="c1"># Moves the cursor 4 bytes to the right</span>
        <span class="n">f</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>

        <span class="n">gamma_only</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">ngm_g</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">ispin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Move the cursor 8 byte to the right</span>
        <span class="n">f</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="n">b1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
        <span class="n">b2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
        <span class="n">b3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>

        <span class="c1"># Move the cursor 8 byte to the right</span>
        <span class="n">f</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="n">mill_g</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="mi">3</span> <span class="o">*</span> <span class="n">ngm_g</span><span class="p">)</span>
        <span class="n">mill_g</span> <span class="o">=</span> <span class="n">mill_g</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">ngm_g</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>

        <span class="c1"># Move the cursor 8 byte to the right</span>
        <span class="n">f</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="n">rho_g</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="n">ngm_g</span><span class="p">)</span>

        <span class="c1"># get primitive lattice vectors</span>
        <span class="c1"># (must be the same as scf output)</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">elphmod</span><span class="o">.</span><span class="n">bravais</span><span class="o">.</span><span class="n">primitives</span><span class="p">(</span><span class="n">ibrav</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">c</span><span class="p">)</span>
        <span class="n">A</span> <span class="o">/=</span> <span class="n">a</span>

        <span class="n">B1</span><span class="p">,</span> <span class="n">B2</span><span class="p">,</span> <span class="n">B3</span> <span class="o">=</span> <span class="n">elphmod</span><span class="o">.</span><span class="n">bravais</span><span class="o">.</span><span class="n">reciprocals</span><span class="p">(</span><span class="o">*</span><span class="n">A</span><span class="p">)</span>

        <span class="c1"># calculate unit cell volume (for Hartree energy)</span>
        <span class="n">uc_volume</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">a</span> <span class="o">/</span> <span class="n">elphmod</span><span class="o">.</span><span class="n">misc</span><span class="o">.</span><span class="n">a0</span><span class="p">)</span> <span class="o">**</span> <span class="mi">3</span>

        <span class="c1"># calculate reciprocal G vectors</span>
        <span class="n">g_vect</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">ngm_g</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ngm_g</span><span class="p">):</span>
            <span class="n">g_vect</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">mill_g</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">B1</span> <span class="o">+</span> <span class="n">mill_g</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">B2</span>
                <span class="o">+</span> <span class="n">mill_g</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">B3</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">rho_g</span><span class="p">,</span> <span class="n">g_vect</span><span class="p">,</span> <span class="n">ngm_g</span><span class="p">,</span> <span class="n">uc_volume</span><span class="p">,</span> <span class="n">mill_g</span></div>


<div class="viewcode-block" id="read_wfc">
<a class="viewcode-back" href="../../modules/el.html#elphmod.el.read_wfc">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">read_wfc</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">ibrav</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Read the wave function output from Quantum ESPRESSO.</span>

<span class="sd">    .. math::</span>

<span class="sd">        \psi_{n \vec k}(\vec r) = \frac 1 {\sqrt V} \sum_{\vec G}</span>
<span class="sd">            c_{n, \vec k + \vec G} \E^{\I (\vec k + \vec G) \vec r}</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    filename : str</span>
<span class="sd">        Filename.</span>
<span class="sd">    ibrav : integer</span>
<span class="sd">        Bravais lattice index (see ``pw.x`` input description).</span>
<span class="sd">    a, b, c : float</span>
<span class="sd">        Bravais lattice parameters.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    evc : ndarray</span>
<span class="sd">        Electronic wave function :math:`c_{n, \vec k + \vec G}`.</span>
<span class="sd">    igwx : integer</span>
<span class="sd">        Number of reciprocal lattice vectors.</span>
<span class="sd">    xk : ndarray</span>
<span class="sd">        k point.</span>
<span class="sd">    k_plus_G : ndarray</span>
<span class="sd">        k point plus reciprocal lattice vectors :math:`\vec G`.</span>
<span class="sd">    g_vect : ndarray</span>
<span class="sd">        Reciprocal lattice vectors :math:`\vec G`.</span>
<span class="sd">    mill_g : ndarray</span>
<span class="sd">        Miller indices.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="c1"># Moves the cursor 4 bytes to the right</span>
        <span class="n">f</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>

        <span class="n">ik</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">xk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
        <span class="n">ispin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">gamma_only</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">scalef</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Move the cursor 8 byte to the right</span>
        <span class="n">f</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="n">ngw</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">igwx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">npol</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">nbnd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Move the cursor 8 byte to the right</span>
        <span class="n">f</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="n">b1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
        <span class="n">b2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
        <span class="n">b3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>

        <span class="n">f</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="n">mill_g</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="mi">3</span> <span class="o">*</span> <span class="n">igwx</span><span class="p">)</span>
        <span class="n">mill_g</span> <span class="o">=</span> <span class="n">mill_g</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">igwx</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>

        <span class="n">evc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nbnd</span><span class="p">,</span> <span class="n">npol</span> <span class="o">*</span> <span class="n">igwx</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>

        <span class="n">f</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nbnd</span><span class="p">):</span>
            <span class="n">evc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="n">npol</span> <span class="o">*</span> <span class="n">igwx</span><span class="p">)</span>
            <span class="n">f</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="c1"># delta_mn = \sum_G \psi(m, G) * \psi(n, G)</span>
        <span class="c1"># print((evc[1, :].conj() * evc[0, :]).sum().real)</span>

        <span class="c1"># get primitive lattice vectors</span>
        <span class="c1"># (must be the same as scf output)</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">elphmod</span><span class="o">.</span><span class="n">bravais</span><span class="o">.</span><span class="n">primitives</span><span class="p">(</span><span class="n">ibrav</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">c</span><span class="p">)</span>
        <span class="n">A</span> <span class="o">/=</span> <span class="n">a</span>

        <span class="c1"># reciprocal lattice vectors for G</span>
        <span class="n">B1</span><span class="p">,</span> <span class="n">B2</span><span class="p">,</span> <span class="n">B3</span> <span class="o">=</span> <span class="n">elphmod</span><span class="o">.</span><span class="n">bravais</span><span class="o">.</span><span class="n">reciprocals</span><span class="p">(</span><span class="o">*</span><span class="n">A</span><span class="p">)</span>

        <span class="c1"># transform k point</span>
        <span class="n">alat</span> <span class="o">=</span> <span class="n">a</span> <span class="o">/</span> <span class="n">elphmod</span><span class="o">.</span><span class="n">misc</span><span class="o">.</span><span class="n">a0</span>
        <span class="n">xk</span> <span class="o">=</span> <span class="n">xk</span> <span class="o">*</span> <span class="n">alat</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>

<span class="c1">#        # normalize wfcs</span>
<span class="c1">#        uc_volume = np.linalg.det(A) * alat ** 3</span>
<span class="c1">#        evc /= np.sqrt(uc_volume)</span>

        <span class="c1"># calculate reciprocal G vectors</span>
        <span class="n">g_vect</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">igwx</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
        <span class="n">k_plus_G</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">igwx</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">igwx</span><span class="p">):</span>
            <span class="n">g_vect</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">mill_g</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">B1</span> <span class="o">+</span> <span class="n">mill_g</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">B2</span>
                <span class="o">+</span> <span class="n">mill_g</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">B3</span><span class="p">)</span>
<span class="c1">#            g_vect[ii] = (mill_g[ii, 0] * b1 + mill_g[ii, 1] * b2</span>
<span class="c1">#                + mill_g[ii, 2] * b3)</span>

            <span class="n">k_plus_G</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">xk</span> <span class="o">+</span> <span class="n">g_vect</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">evc</span><span class="p">,</span> <span class="n">igwx</span><span class="p">,</span> <span class="n">xk</span><span class="p">,</span> <span class="n">k_plus_G</span><span class="p">,</span> <span class="n">g_vect</span><span class="p">,</span> <span class="n">mill_g</span></div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2017-2025 elphmod Developers.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>