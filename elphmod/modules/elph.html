

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Electron–phonon &mdash; elphmod  documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../_static/style.css?v=6b874a89" />

  
      <script src="../_static/jquery.js?v=5d32c60e"></script>
      <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../_static/documentation_options.js?v=5929fcd5"></script>
      <script src="../_static/doctools.js?v=9bcbadda"></script>
      <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script type="text/x-mathjax-config">MathJax.Hub.Config({"TeX": {"Macros": {"D": ["\\mathrm{d}"], "E": ["\\mathrm{e}"], "I": ["\\mathrm{i}"], "bra": ["\\langle#1|", 1], "bracket": ["\\langle#1|#2\\rangle", 2], "ket": ["|#1\\rangle", 1], "sub": ["_{\\mathrm{#1}}", 1], "super": ["^{\\mathrm{#1}}", 1]}}})</script>
      <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Electron–electron" href="elel.html" />
    <link rel="prev" title="Phonon" href="ph.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: #e7f2fa" >

          
          
          <a href="../index.html">
            
              <img src="../_static/elphmod.svg" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Modules</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="el.html">Electron</a></li>
<li class="toctree-l1"><a class="reference internal" href="ph.html">Phonon</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Electron–phonon</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#elphmod.elph.Model"><code class="docutils literal notranslate"><span class="pre">Model</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="#elphmod.elph.Model.asr"><code class="docutils literal notranslate"><span class="pre">Model.asr()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#elphmod.elph.Model.clear"><code class="docutils literal notranslate"><span class="pre">Model.clear()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#elphmod.elph.Model.decay_epmate"><code class="docutils literal notranslate"><span class="pre">Model.decay_epmate()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#elphmod.elph.Model.decay_epmatp"><code class="docutils literal notranslate"><span class="pre">Model.decay_epmatp()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#elphmod.elph.Model.divide_degeneracy"><code class="docutils literal notranslate"><span class="pre">Model.divide_degeneracy()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#elphmod.elph.Model.g"><code class="docutils literal notranslate"><span class="pre">Model.g()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#elphmod.elph.Model.gR"><code class="docutils literal notranslate"><span class="pre">Model.gR()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#elphmod.elph.Model.g_lr"><code class="docutils literal notranslate"><span class="pre">Model.g_lr()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#elphmod.elph.Model.sample"><code class="docutils literal notranslate"><span class="pre">Model.sample()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#elphmod.elph.Model.sample_orig"><code class="docutils literal notranslate"><span class="pre">Model.sample_orig()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#elphmod.elph.Model.standardize"><code class="docutils literal notranslate"><span class="pre">Model.standardize()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#elphmod.elph.Model.supercell"><code class="docutils literal notranslate"><span class="pre">Model.supercell()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#elphmod.elph.Model.symmetrize"><code class="docutils literal notranslate"><span class="pre">Model.symmetrize()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#elphmod.elph.Model.to_epmatwp"><code class="docutils literal notranslate"><span class="pre">Model.to_epmatwp()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#elphmod.elph.Model.update_short_range"><code class="docutils literal notranslate"><span class="pre">Model.update_short_range()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#elphmod.elph.coupling"><code class="docutils literal notranslate"><span class="pre">coupling()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#elphmod.elph.ph2epw"><code class="docutils literal notranslate"><span class="pre">ph2epw()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#elphmod.elph.q2r"><code class="docutils literal notranslate"><span class="pre">q2r()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#elphmod.elph.read_EPW_output"><code class="docutils literal notranslate"><span class="pre">read_EPW_output()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#elphmod.elph.read_L"><code class="docutils literal notranslate"><span class="pre">read_L()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#elphmod.elph.read_data"><code class="docutils literal notranslate"><span class="pre">read_data()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#elphmod.elph.read_patterns"><code class="docutils literal notranslate"><span class="pre">read_patterns()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#elphmod.elph.read_prtgkk"><code class="docutils literal notranslate"><span class="pre">read_prtgkk()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#elphmod.elph.read_xml_files"><code class="docutils literal notranslate"><span class="pre">read_xml_files()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#elphmod.elph.sample"><code class="docutils literal notranslate"><span class="pre">sample()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#elphmod.elph.transform"><code class="docutils literal notranslate"><span class="pre">transform()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#elphmod.elph.write_data"><code class="docutils literal notranslate"><span class="pre">write_data()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#elphmod.elph.write_xml_files"><code class="docutils literal notranslate"><span class="pre">write_xml_files()</span></code></a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="elel.html">Electron–electron</a></li>
<li class="toctree-l1"><a class="reference internal" href="MPI.html">MPI</a></li>
<li class="toctree-l1"><a class="reference internal" href="bravais.html">Bravais</a></li>
<li class="toctree-l1"><a class="reference internal" href="dispersion.html">Dispersion</a></li>
<li class="toctree-l1"><a class="reference internal" href="dos.html">DOS</a></li>
<li class="toctree-l1"><a class="reference internal" href="diagrams.html">Diagrams</a></li>
<li class="toctree-l1"><a class="reference internal" href="occupations.html">Occupations</a></li>
<li class="toctree-l1"><a class="reference internal" href="md.html">MD</a></li>
<li class="toctree-l1"><a class="reference internal" href="eliashberg.html">Eliashberg</a></li>
<li class="toctree-l1"><a class="reference internal" href="plot.html">Plot</a></li>
<li class="toctree-l1"><a class="reference internal" href="misc.html">Miscellaneous</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Models</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="models/graphene.html">Graphene</a></li>
<li class="toctree-l1"><a class="reference internal" href="models/tas2.html">TaS₂</a></li>
<li class="toctree-l1"><a class="reference internal" href="models/chain.html">Chain</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">More</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../pages/changelog.html">Changelog</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pages/patches.html">Patches</a></li>
<li class="toctree-l1"><a class="reference internal" href="../genindex.html">Index</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu"  style="background: #e7f2fa" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">elphmod</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Electron–phonon</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/modules/elph.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="module-elphmod.elph">
<span id="electron-phonon"></span><h1>Electron–phonon<a class="headerlink" href="#module-elphmod.elph" title="Link to this heading"></a></h1>
<p>Electron-phonon coupling from EPW.</p>
<dl class="py class">
<dt class="sig sig-object py" id="elphmod.elph.Model">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">elphmod.elph.</span></span><span class="sig-name descname"><span class="pre">Model</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">epmatwp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">wigner</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">el</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ph</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Rk</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dk</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Rg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">old_ws</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">divide_mass</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">divide_ndegen</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shared_memory</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/elphmod/elph.html#Model"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#elphmod.elph.Model" title="Link to this definition"></a></dt>
<dd><p>Localized model for electron-phonon coupling.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>epmatwp</strong><span class="classifier">str</span></dt><dd><p>File with electron-phonon coupling in localized bases from EPW.</p>
</dd>
<dt><strong>wigner</strong><span class="classifier">str</span></dt><dd><p>File with definition of Wigner-Seitz supercells from EPW.</p>
</dd>
<dt><strong>el</strong><span class="classifier"><a class="reference internal" href="el.html#elphmod.el.Model" title="elphmod.el.Model"><code class="xref py py-class docutils literal notranslate"><span class="pre">elphmod.el.Model</span></code></a></span></dt><dd><p>Tight-binding model for the electrons.</p>
</dd>
<dt><strong>ph</strong><span class="classifier"><a class="reference internal" href="ph.html#elphmod.ph.Model" title="elphmod.ph.Model"><code class="xref py py-class docutils literal notranslate"><span class="pre">elphmod.ph.Model</span></code></a></span></dt><dd><p>Mass-spring model for the phonons.</p>
</dd>
<dt><strong>Rk, Rg</strong><span class="classifier">ndarray</span></dt><dd><p>Lattice vectors of Wigner-Seitz supercells if <cite>wigner</cite> is omitted.</p>
</dd>
<dt><strong>dk, dg</strong><span class="classifier">ndarray</span></dt><dd><p>Degeneracies of Wigner-Seitz points if <cite>wigner</cite> is omitted.</p>
</dd>
<dt><strong>old_ws</strong><span class="classifier">bool</span></dt><dd><p>Use previous definition of Wigner-Seitz cells? This is required if
<cite>patches/qe-6.3-backports.patch</cite> has been used.</p>
</dd>
<dt><strong>divide_mass</strong><span class="classifier">bool</span></dt><dd><p>Divide electron-phonon coupling by square root of atomic masses?</p>
</dd>
<dt><strong>divide_ndegen</strong><span class="classifier">bool</span></dt><dd><p>Divide real-space coupling by degeneracy of Wigner-Seitz point? Only
<code class="docutils literal notranslate"><span class="pre">True</span></code> yields correct couplings. <code class="docutils literal notranslate"><span class="pre">False</span></code> should only be used for
debugging.</p>
</dd>
<dt><strong>shared_memory</strong><span class="classifier">bool</span></dt><dd><p>Read coupling from EPW into shared memory?</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>el</strong><span class="classifier"><a class="reference internal" href="el.html#elphmod.el.Model" title="elphmod.el.Model"><code class="xref py py-class docutils literal notranslate"><span class="pre">elphmod.el.Model</span></code></a></span></dt><dd><p>Tight-binding model for the electrons.</p>
</dd>
<dt><strong>ph</strong><span class="classifier"><a class="reference internal" href="ph.html#elphmod.ph.Model" title="elphmod.ph.Model"><code class="xref py py-class docutils literal notranslate"><span class="pre">elphmod.ph.Model</span></code></a></span></dt><dd><p>Mass-spring model for the phonons.</p>
</dd>
<dt><strong>Rk, Rg</strong><span class="classifier">ndarray</span></dt><dd><p>Lattice vectors <span class="math notranslate nohighlight">\(\vec R', \vec R\)</span> of Wigner-Seitz supercells.</p>
</dd>
<dt><strong>dk, dg</strong><span class="classifier">ndarray</span></dt><dd><p>Degeneracies of Wigner-Seitz points.</p>
</dd>
<dt><strong>data</strong><span class="classifier">ndarray</span></dt><dd><p>Corresponding electron-phonon matrix elements in Ry<sup>3/2</sup>.</p>
<div class="math notranslate nohighlight">
\[g_{\vec R i \vec R' \alpha \beta} = \frac \hbar {\sqrt M_i}
    \bra{0 \alpha}
        \frac{\partial V}{\partial u_{\vec R i}}
    \ket{\vec R' \beta}\]</div>
<p>If not <code class="xref py py-attr docutils literal notranslate"><span class="pre">divide_mass</span></code>, the prefactor <span class="math notranslate nohighlight">\(\hbar / \sqrt{M_i}\)</span> is
absent and the units are Ry/bohr instead. If <code class="xref py py-attr docutils literal notranslate"><span class="pre">ph.lr</span></code>, this is only
the short-range component of the matrix elements.</p>
</dd>
<dt><strong>divide_mass</strong><span class="classifier">bool</span></dt><dd><p>Has real-space coupling been divided by atomic masses?</p>
</dd>
<dt><strong>divide_ndegen</strong><span class="classifier">bool</span></dt><dd><p>Has real-space coupling been divided by degeneracy of Wigner-Seitz
point?</p>
</dd>
<dt><strong>node, images</strong><span class="classifier">MPI.Intracomm</span></dt><dd><p>Communicators between processes that share memory or same <code class="docutils literal notranslate"><span class="pre">node.rank</span></code>
if <cite>shared_memory</cite>.</p>
</dd>
<dt><strong>q</strong><span class="classifier">ndarray</span></dt><dd><p>Previously sampled q point, if any.</p>
</dd>
<dt><strong>gq</strong><span class="classifier">ndarray</span></dt><dd><p>Rk-dependent coupling for above q point for possible reuse.</p>
</dd>
<dt><strong>cells</strong><span class="classifier">list of tuple of int, optional</span></dt><dd><p>Lattice vectors of unit cells if the model describes a supercell.</p>
</dd>
<dt><strong>g0</strong><span class="classifier">ndarray</span></dt><dd><p>Coupling on original q and k meshes.</p>
</dd>
<dt><strong>Rk0</strong><span class="classifier">int</span></dt><dd><p>Index of electronic lattice vector at origin.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="elphmod.elph.Model.asr">
<span class="sig-name descname"><span class="pre">asr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">report</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/elphmod/elph.html#Model.asr"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#elphmod.elph.Model.asr" title="Link to this definition"></a></dt>
<dd><p>Apply acoustic sum rule correction to electron-phonon coupling.</p>
<p>This will suppress all coupling of electrons to acoustic phonon modes.
The matrix elements are subject to a constant relative change so that
zeros remain zeros and the largest values change the most. There might
be a better way to accomplish this.</p>
<dl class="simple">
<dt>report<span class="classifier">bool</span></dt><dd><p>Print sums before and after correction?</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="elphmod.elph.Model.clear">
<span class="sig-name descname"><span class="pre">clear</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/elphmod/elph.html#Model.clear"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#elphmod.elph.Model.clear" title="Link to this definition"></a></dt>
<dd><p>Delete all lattice vectors and associated matrix elements.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="elphmod.elph.Model.decay_epmate">
<span class="sig-name descname"><span class="pre">decay_epmate</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/elphmod/elph.html#Model.decay_epmate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#elphmod.elph.Model.decay_epmate" title="Link to this definition"></a></dt>
<dd><p>Plot maximum matrix element as a function of hopping distance.</p>
<p>Use <code class="docutils literal notranslate"><span class="pre">divide_mass=False</span></code> to recreate EPW’s <em>decay.epmate</em> file.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt>ndarray</dt><dd><p>Distances.</p>
</dd>
<dt>ndarray</dt><dd><p>Maximum absolute matrix elements.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="elphmod.elph.Model.decay_epmatp">
<span class="sig-name descname"><span class="pre">decay_epmatp</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/elphmod/elph.html#Model.decay_epmatp"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#elphmod.elph.Model.decay_epmatp" title="Link to this definition"></a></dt>
<dd><p>Plot maximum matrix element as a function of displacement distance.</p>
<p>Use <code class="docutils literal notranslate"><span class="pre">divide_mass=False</span></code> to recreate EPW’s <em>decay.epmatp</em> file.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt>ndarray</dt><dd><p>Distances.</p>
</dd>
<dt>ndarray</dt><dd><p>Maximum absolute matrix elements.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="elphmod.elph.Model.divide_degeneracy">
<span class="sig-name descname"><span class="pre">divide_degeneracy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">g</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/elphmod/elph.html#Model.divide_degeneracy"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#elphmod.elph.Model.divide_degeneracy" title="Link to this definition"></a></dt>
<dd><p>Divide real-space coupling by degeneracy of Wigner-Seitz point.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>g</strong><span class="classifier">ndarray</span></dt><dd><p>Real-space coupling.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="elphmod.elph.Model.g">
<span class="sig-name descname"><span class="pre">g</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">q1=0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q2=0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q3=0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k1=0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k2=0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k3=0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">elbnd=False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">phbnd=False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">broadcast=True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">comm=&lt;elphmod.MPI.Communicator</span> <span class="pre">object&gt;</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/elphmod/elph.html#Model.g"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#elphmod.elph.Model.g" title="Link to this definition"></a></dt>
<dd><p>Calculate electron-phonon coupling for arbitary points k and k + q.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>q1, q2, q2</strong><span class="classifier">float, default 0.0</span></dt><dd><p>q point in crystal coordinates with period <span class="math notranslate nohighlight">\(2 \pi\)</span>.</p>
</dd>
<dt><strong>k1, k2, k3</strong><span class="classifier">float, default 0.0</span></dt><dd><p>Ingoing k point in crystal coordinates with period <span class="math notranslate nohighlight">\(2 \pi\)</span>.</p>
</dd>
<dt><strong>elbnd</strong><span class="classifier">bool</span></dt><dd><p>Transform to electronic band basis? Provided for convenience. Since
the Hamiltonian is diagonalized on the fly for each requested matrix
element, this option lacks efficiency and control of complex phases.
Consider the method <cite>sample</cite> of this class instead.</p>
</dd>
<dt><strong>phbnd</strong><span class="classifier">bool</span></dt><dd><p>Transform to phononic band basis? Provided for convenience. Since
the dynamical matrix is diagonalized on the fly for each requested
matrix element, this option lacks efficiency and control of complex
phases. Consider the method <cite>sample</cite> of this class instead.</p>
</dd>
<dt><strong>broadcast</strong><span class="classifier">bool</span></dt><dd><p>Broadcast result to all processors? If <code class="docutils literal notranslate"><span class="pre">False</span></code>, returns <code class="docutils literal notranslate"><span class="pre">None</span></code>
on all but the first processor.</p>
</dd>
<dt><strong>comm</strong><span class="classifier">MPI.Intracomm</span></dt><dd><p>Group of processors running this function (for parallelization of
Fourier transforms). Please note: To run this function serially,
e.g., when parallelizing over q or k points, use <code class="docutils literal notranslate"><span class="pre">elphmod.MPI.I</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>ndarray</dt><dd><p>Fourier transform of <code class="xref py py-attr docutils literal notranslate"><span class="pre">data</span></code>, possibly plus a long-range term
and transformed into the band basis.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="elphmod.elph.Model.gR">
<span class="sig-name descname"><span class="pre">gR</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Rq1</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Rq2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Rq3</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Rk1</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Rk2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Rk3</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/elphmod/elph.html#Model.gR"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#elphmod.elph.Model.gR" title="Link to this definition"></a></dt>
<dd><p>Get electron-phonon matrix elements for arbitrary lattice vectors.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>Rq1, Rq2, Rq3, Rk1, Rk2, Rk3</strong><span class="classifier">int, default 0</span></dt><dd><p>Lattice vectors in units of primitive vectors.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>ndarray</dt><dd><p>Element of <code class="xref py py-attr docutils literal notranslate"><span class="pre">data</span></code> or zero.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="elphmod.elph.Model.g_lr">
<span class="sig-name descname"><span class="pre">g_lr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">q1</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q3</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/elphmod/elph.html#Model.g_lr"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#elphmod.elph.Model.g_lr" title="Link to this definition"></a></dt>
<dd><p>Calculate long-range part of electron-phonon coupling.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="elphmod.elph.Model.sample">
<span class="sig-name descname"><span class="pre">sample</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/elphmod/elph.html#Model.sample"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#elphmod.elph.Model.sample" title="Link to this definition"></a></dt>
<dd><p>Sample coupling.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#elphmod.elph.sample" title="elphmod.elph.sample"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sample</span></code></a></dt><dd></dd>
</dl>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="elphmod.elph.Model.sample_orig">
<span class="sig-name descname"><span class="pre">sample_orig</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">shared_memory</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/elphmod/elph.html#Model.sample_orig"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#elphmod.elph.Model.sample_orig" title="Link to this definition"></a></dt>
<dd><p>Sample coupling on original q and k meshes.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="elphmod.elph.Model.standardize">
<span class="sig-name descname"><span class="pre">standardize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">eps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">symmetrize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/elphmod/elph.html#Model.standardize"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#elphmod.elph.Model.standardize" title="Link to this definition"></a></dt>
<dd><p>Standardize real-space coupling data.</p>
<ul class="simple">
<li><p>Keep only nonzero coupling matrices.</p></li>
<li><p>Sum over repeated lattice vectors.</p></li>
<li><p>Sort lattice vectors.</p></li>
<li><p>Optionally symmetrize coupling:</p></li>
</ul>
<div class="math notranslate nohighlight">
\[g_{\vec q, \vec k} = g_{-\vec q, \vec k + \vec q}^\dagger,
g_{\vec R, \vec R'} = g_{\vec R - \vec R', -\vec R'}^\dagger\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>eps</strong><span class="classifier">float</span></dt><dd><p>Threshold for “nonzero” matrix elements in units of the maximum
matrix element.</p>
</dd>
<dt><strong>symmetrize</strong><span class="classifier">bool</span></dt><dd><p>Symmetrize coupling?</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="elphmod.elph.Model.supercell">
<span class="sig-name descname"><span class="pre">supercell</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N1</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">N2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">N3</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shared_memory</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sparse</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/elphmod/elph.html#Model.supercell"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#elphmod.elph.Model.supercell" title="Link to this definition"></a></dt>
<dd><p>Map localized model for electron-phonon coupling onto supercell.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N1, N2, N3</strong><span class="classifier">tuple of int or int, default 1</span></dt><dd><p>Supercell lattice vectors in units of primitive lattice vectors.</p>
</dd>
<dt><strong>shared_memory</strong><span class="classifier">bool, default False</span></dt><dd><p>Store mapped coupling in shared memory?</p>
</dd>
<dt><strong>sparse</strong><span class="classifier">bool, default False</span></dt><dd><p>Only calculate q = k = 0 coupling as a list of sparse matrices to
save memory? The result, which is assumed to be real, is stored in
the attribute <code class="xref py py-attr docutils literal notranslate"><span class="pre">gs</span></code>. Consider using <a class="reference internal" href="#elphmod.elph.Model.standardize" title="elphmod.elph.Model.standardize"><code class="xref py py-meth docutils literal notranslate"><span class="pre">standardize()</span></code></a> with
nonzero <cite>eps</cite> and <cite>symmetrize</cite> before.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>object</dt><dd><p>Localized model for electron-phonon coupling for supercell.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="bravais.html#elphmod.bravais.supercell" title="elphmod.bravais.supercell"><code class="xref py py-obj docutils literal notranslate"><span class="pre">elphmod.bravais.supercell</span></code></a></dt><dd></dd>
</dl>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="elphmod.elph.Model.symmetrize">
<span class="sig-name descname"><span class="pre">symmetrize</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/elphmod/elph.html#Model.symmetrize"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#elphmod.elph.Model.symmetrize" title="Link to this definition"></a></dt>
<dd><p>Symmetrize electron-phonon coupling.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="elphmod.elph.Model.to_epmatwp">
<span class="sig-name descname"><span class="pre">to_epmatwp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">prefix</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/elphmod/elph.html#Model.to_epmatwp"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#elphmod.elph.Model.to_epmatwp" title="Link to this definition"></a></dt>
<dd><p>Save coupling to <em>.epmatwp</em> and <em>.wigner</em> files.</p>
<p>If <code class="xref py py-attr docutils literal notranslate"><span class="pre">divide_ndegen</span></code>, the division by the degeneracies of the
Wigner-Seitz points is not undone before writing the <em>.epmatwp</em> file.
Instead, all degeneracies in the <em>.wiger</em> file are set to one.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>prefix</strong><span class="classifier">str</span></dt><dd><p>Filename stem.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="elphmod.elph.Model.update_short_range">
<span class="sig-name descname"><span class="pre">update_short_range</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">shared_memory</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/elphmod/elph.html#Model.update_short_range"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#elphmod.elph.Model.update_short_range" title="Link to this definition"></a></dt>
<dd><p>Update short-range part of real-space coupling.</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="elphmod.elph.coupling">
<span class="sig-prename descclassname"><span class="pre">elphmod.elph.</span></span><span class="sig-name descname"><span class="pre">coupling</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filename</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nQ</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nmodes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nk</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bands</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Q</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nq</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">completion</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">complete_k</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">squeeze</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">status</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">phase</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/elphmod/elph.html#coupling"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#elphmod.elph.coupling" title="Link to this definition"></a></dt>
<dd><p>Read and complete electron-phonon matrix elements.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="elphmod.elph.ph2epw">
<span class="sig-prename descclassname"><span class="pre">elphmod.elph.</span></span><span class="sig-name descname"><span class="pre">ph2epw</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fildyn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'dyn'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">outdir</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'work'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dvscf_dir</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'save'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/elphmod/elph.html#ph2epw"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#elphmod.elph.ph2epw" title="Link to this definition"></a></dt>
<dd><p>Convert PHonon output to EPW input.</p>
<p>Based on script <cite>pp.py</cite> provided with EPW code (C) 2015 Samuel Ponce.</p>
<p>All arguments can be overwritten by environment variables of the same name.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dyn</strong><span class="classifier">str</span></dt><dd><p>Prefix of dynamical-matrix files.</p>
</dd>
<dt><strong>outdir</strong><span class="classifier">str</span></dt><dd><p>QE output directory.</p>
</dd>
<dt><strong>dvscf_dir</strong><span class="classifier">str</span></dt><dd><p>EPW input directory.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="elphmod.elph.q2r">
<span class="sig-prename descclassname"><span class="pre">elphmod.elph.</span></span><span class="sig-name descname"><span class="pre">q2r</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">elph</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nk</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">g</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">divide_mass</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shared_memory</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/elphmod/elph.html#q2r"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#elphmod.elph.q2r" title="Link to this definition"></a></dt>
<dd><p>Fourier-transform electron-phonon coupling from reciprocal to real space.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>elph</strong><span class="classifier"><a class="reference internal" href="#elphmod.elph.Model" title="elphmod.elph.Model"><code class="xref py py-class docutils literal notranslate"><span class="pre">Model</span></code></a></span></dt><dd><p>Localized model for electron-phonon coupling.</p>
</dd>
<dt><strong>nq, nk</strong><span class="classifier">tuple of int</span></dt><dd><p>Number of q and k points along axes, i.e., shapes of uniform meshes.</p>
</dd>
<dt><strong>g</strong><span class="classifier">ndarray</span></dt><dd><p>Electron-phonon coupling on complete uniform q- and k-point meshes.</p>
</dd>
<dt><strong>r</strong><span class="classifier">ndarray, optional</span></dt><dd><p>Positions of orbital centers. If given, the Wigner-Seitz lattice vectors
are determined again, whereby the distances to the displaced atom and
the initial orbital are are both measured from the final orbital in the
unit cell at the origin (first orbital index). This argument is required
when changing <cite>nq</cite> or <cite>nk</cite>.</p>
</dd>
<dt><strong>divide_mass</strong><span class="classifier">bool, default True</span></dt><dd><p>Has input coupling been divided by square root of atomic mass? This is
independent of <code class="docutils literal notranslate"><span class="pre">elph.divide_mass</span></code>, which is always respected.</p>
</dd>
<dt><strong>shared_memory</strong><span class="classifier">bool, default False</span></dt><dd><p>Store real-space coupling in shared memory?</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="elphmod.elph.read_EPW_output">
<span class="sig-prename descclassname"><span class="pre">elphmod.elph.</span></span><span class="sig-name descname"><span class="pre">read_EPW_output</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">epw_out</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nmodes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nk</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bands</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0001</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">squeeze</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">status</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">epf</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">defpot</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/elphmod/elph.html#read_EPW_output"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#elphmod.elph.read_EPW_output" title="Link to this definition"></a></dt>
<dd><p>Read electron-phonon coupling from EPW output file (using <code class="docutils literal notranslate"><span class="pre">prtgkk</span></code>).</p>
<p>Currently, the coupling must be defined on a uniform 2D k mesh
(corresponding to triangular or square lattice).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>epw_out</strong><span class="classifier">str</span></dt><dd><p>Name of EPW output file.</p>
</dd>
<dt><strong>q</strong><span class="classifier">list of int</span></dt><dd><p>List of q points as integer recriprocal lattice units.</p>
</dd>
<dt><strong>nq</strong><span class="classifier">int</span></dt><dd><p>Number of q points per dimension.</p>
</dd>
<dt><strong>nmodes</strong><span class="classifier">int</span></dt><dd><p>Number of phonon modes.</p>
</dd>
<dt><strong>nk</strong><span class="classifier">int</span></dt><dd><p>Number of k points per dimension.</p>
</dd>
<dt><strong>bands</strong><span class="classifier">int</span></dt><dd><p>Number of electronic bands.</p>
</dd>
<dt><strong>eps</strong><span class="classifier">float</span></dt><dd><p>Tolerance for q and k points.</p>
</dd>
<dt><strong>squeeze</strong><span class="classifier">bool</span></dt><dd><p>In single-band case, skip dimensions of output arrary corresponding to
electronic bands?</p>
</dd>
<dt><strong>status</strong><span class="classifier">bool</span></dt><dd><p>Report currently processed q point?</p>
</dd>
<dt><strong>epf</strong><span class="classifier">bool</span></dt><dd><p>Read real and imaginary part of the coupling of dimension energy to the
power of 2/3 from last two columns? A modified version of EPW is needed.
Otherwise, the modulus of the coupling of dimension energy is read.</p>
</dd>
<dt><strong>defpot</strong><span class="classifier">bool</span></dt><dd><p>Multiply coupling by square root of twice the phonon energy to obtain a
quantity of dimension energy to the power of 2/3?</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="elphmod.elph.read_L">
<span class="sig-prename descclassname"><span class="pre">elphmod.elph.</span></span><span class="sig-name descname"><span class="pre">read_L</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">epw_out</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/elphmod/elph.html#read_L"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#elphmod.elph.read_L" title="Link to this definition"></a></dt>
<dd><p>Read range-separation parameter from EPW output</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>epw_out</strong><span class="classifier">str</span></dt><dd><p>Name of EPW output file.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>float</dt><dd><p>Range-separation parameter if found, <code class="docutils literal notranslate"><span class="pre">None</span></code> otherwise.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="elphmod.elph.read_data">
<span class="sig-prename descclassname"><span class="pre">elphmod.elph.</span></span><span class="sig-name descname"><span class="pre">read_data</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filename</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/elphmod/elph.html#read_data"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#elphmod.elph.read_data" title="Link to this definition"></a></dt>
<dd><p>Read array from ASCII file.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="elphmod.elph.read_patterns">
<span class="sig-prename descclassname"><span class="pre">elphmod.elph.</span></span><span class="sig-name descname"><span class="pre">read_patterns</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filename</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nrep</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">status</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/elphmod/elph.html#read_patterns"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#elphmod.elph.read_patterns" title="Link to this definition"></a></dt>
<dd><p>Read XML files with displacement patterns from QE.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="elphmod.elph.read_prtgkk">
<span class="sig-prename descclassname"><span class="pre">elphmod.elph.</span></span><span class="sig-name descname"><span class="pre">read_prtgkk</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">epw_out</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nmodes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nk</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nbnd</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/elphmod/elph.html#read_prtgkk"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#elphmod.elph.read_prtgkk" title="Link to this definition"></a></dt>
<dd><p>Read frequencies and coupling from EPW output (using <code class="docutils literal notranslate"><span class="pre">prtgkk</span></code>).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>epw_out</strong><span class="classifier">str</span></dt><dd><p>Name of EPW output file.</p>
</dd>
<dt><strong>nq</strong><span class="classifier">int</span></dt><dd><p>Number of q points.</p>
</dd>
<dt><strong>nmodes</strong><span class="classifier">int</span></dt><dd><p>Number of phonon modes.</p>
</dd>
<dt><strong>nk</strong><span class="classifier">int</span></dt><dd><p>Number of k points.</p>
</dd>
<dt><strong>nbnd</strong><span class="classifier">int</span></dt><dd><p>Number of electronic bands.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>ndarray</dt><dd><p>Phonon frequencies (meV).</p>
</dd>
<dt>ndarray</dt><dd><p>Electron-phonon coupling (meV).</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="elphmod.elph.read_xml_files">
<span class="sig-prename descclassname"><span class="pre">elphmod.elph.</span></span><span class="sig-name descname"><span class="pre">read_xml_files</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filename</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rep</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bands</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nbands</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nk</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">squeeze</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">status</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">angle</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">120</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">angle0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">old</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/elphmod/elph.html#read_xml_files"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#elphmod.elph.read_xml_files" title="Link to this definition"></a></dt>
<dd><p>Read XML files with coupling in displacement basis from QE (<em>nosym</em>).</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="elphmod.elph.sample">
<span class="sig-prename descclassname"><span class="pre">elphmod.elph.</span></span><span class="sig-name descname"><span class="pre">sample</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">g</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nk</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">U</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">u</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">squared</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">broadcast</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shared_memory</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/elphmod/elph.html#sample"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#elphmod.elph.sample" title="Link to this definition"></a></dt>
<dd><p>Sample coupling for given q and k points and transform to band basis.</p>
<p>One purpose of this routine is full control of the complex phase.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>g</strong><span class="classifier">function</span></dt><dd><p>Electron-phonon coupling in the basis of electronic orbitals and
Cartesian ionic displacements as a function of q and k in crystal
coordinates with period <span class="math notranslate nohighlight">\(2 \pi\)</span>.</p>
</dd>
<dt><strong>q</strong><span class="classifier">list of tuple</span></dt><dd><p>List of q points in crystal coordinates <span class="math notranslate nohighlight">\(q_i \in [0, 2 \pi)\)</span>.</p>
</dd>
<dt><strong>nk</strong><span class="classifier">int or tuple of int</span></dt><dd><p>Number of k points per dimension, i.e., size of uniform mesh. Different
numbers of k points along different axes can be specified via a tuple.
Alternatively, <cite>nk</cite> is inferred from the shape of <cite>U</cite>.</p>
</dd>
<dt><strong>U</strong><span class="classifier">ndarray, optional</span></dt><dd><p>Electron eigenvectors for given k mesh.
If present, transform from orbital to band basis.</p>
</dd>
<dt><strong>u</strong><span class="classifier">ndarray, optional</span></dt><dd><p>Phonon eigenvectors for given q points.
If present, transform from displacement to band basis.</p>
</dd>
<dt><strong>squared</strong><span class="classifier">bool</span></dt><dd><p>Sample squared complex modulus instead? This is more memory-efficient
than sampling the complex coupling and taking the squared modulus later.</p>
</dd>
<dt><strong>broadcast</strong><span class="classifier">bool</span></dt><dd><p>Broadcast result from rank 0 to all processes?</p>
</dd>
<dt><strong>shared_memory</strong><span class="classifier">bool, optional</span></dt><dd><p>Store transformed coupling in shared memory?</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="elphmod.elph.transform">
<span class="sig-prename descclassname"><span class="pre">elphmod.elph.</span></span><span class="sig-name descname"><span class="pre">transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">g</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nk</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">U</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">u</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">squared</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">broadcast</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shared_memory</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/elphmod/elph.html#transform"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#elphmod.elph.transform" title="Link to this definition"></a></dt>
<dd><p>Transform q- and k-dependent coupling to band basis.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#elphmod.elph.sample" title="elphmod.elph.sample"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sample</span></code></a></dt><dd></dd>
</dl>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="elphmod.elph.write_data">
<span class="sig-prename descclassname"><span class="pre">elphmod.elph.</span></span><span class="sig-name descname"><span class="pre">write_data</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filename</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/elphmod/elph.html#write_data"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#elphmod.elph.write_data" title="Link to this definition"></a></dt>
<dd><p>Write array to ASCII file.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="elphmod.elph.write_xml_files">
<span class="sig-prename descclassname"><span class="pre">elphmod.elph.</span></span><span class="sig-name descname"><span class="pre">write_xml_files</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filename</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">angle</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">120</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">angle0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/elphmod/elph.html#write_xml_files"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#elphmod.elph.write_xml_files" title="Link to this definition"></a></dt>
<dd><p>Write XML files with coupling in displacement basis.</p>
</dd></dl>

</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="ph.html" class="btn btn-neutral float-left" title="Phonon" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="elel.html" class="btn btn-neutral float-right" title="Electron–electron" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2017-2025 elphmod Developers.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>