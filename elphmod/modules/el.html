<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Electron &mdash; elphmod  documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=19f00094" />

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../_static/jquery.js?v=5d32c60e"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../_static/documentation_options.js?v=5929fcd5"></script>
        <script src="../_static/doctools.js?v=888ff710"></script>
        <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
        <script type="text/x-mathjax-config">MathJax.Hub.Config({"TeX": {"Macros": {"D": ["\\mathrm{d}"], "E": ["\\mathrm{e}"], "I": ["\\mathrm{i}"], "bra": ["\\langle#1|", 1], "bracket": ["\\langle#1|#2\\rangle", 2], "ket": ["|#1\\rangle", 1]}}})</script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Phonon" href="ph.html" />
    <link rel="prev" title="Python modules for electron-phonon models" href="../index.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            elphmod
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">Electron</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#elphmod.el.Model"><code class="docutils literal notranslate"><span class="pre">Model</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="#elphmod.el.Model.H"><code class="docutils literal notranslate"><span class="pre">Model.H()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#elphmod.el.Model.order_orbitals"><code class="docutils literal notranslate"><span class="pre">Model.order_orbitals()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#elphmod.el.Model.shift_orbitals"><code class="docutils literal notranslate"><span class="pre">Model.shift_orbitals()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#elphmod.el.Model.standardize"><code class="docutils literal notranslate"><span class="pre">Model.standardize()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#elphmod.el.Model.supercell"><code class="docutils literal notranslate"><span class="pre">Model.supercell()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#elphmod.el.Model.symmetrize"><code class="docutils literal notranslate"><span class="pre">Model.symmetrize()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#elphmod.el.Model.t"><code class="docutils literal notranslate"><span class="pre">Model.t()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#elphmod.el.Model.to_hrdat"><code class="docutils literal notranslate"><span class="pre">Model.to_hrdat()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#elphmod.el.Model.unit_cell"><code class="docutils literal notranslate"><span class="pre">Model.unit_cell()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#elphmod.el.decayH"><code class="docutils literal notranslate"><span class="pre">decayH()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#elphmod.el.demet_from_qe_pwo"><code class="docutils literal notranslate"><span class="pre">demet_from_qe_pwo()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#elphmod.el.eband"><code class="docutils literal notranslate"><span class="pre">eband()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#elphmod.el.k2r"><code class="docutils literal notranslate"><span class="pre">k2r()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#elphmod.el.proj_sum"><code class="docutils literal notranslate"><span class="pre">proj_sum()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#elphmod.el.read_Fermi_level"><code class="docutils literal notranslate"><span class="pre">read_Fermi_level()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#elphmod.el.read_atomic_projections"><code class="docutils literal notranslate"><span class="pre">read_atomic_projections()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#elphmod.el.read_atomic_projections_old"><code class="docutils literal notranslate"><span class="pre">read_atomic_projections_old()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#elphmod.el.read_bands"><code class="docutils literal notranslate"><span class="pre">read_bands()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#elphmod.el.read_bands_plot"><code class="docutils literal notranslate"><span class="pre">read_bands_plot()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#elphmod.el.read_decayH"><code class="docutils literal notranslate"><span class="pre">read_decayH()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#elphmod.el.read_energy_contributions_scf_out"><code class="docutils literal notranslate"><span class="pre">read_energy_contributions_scf_out()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#elphmod.el.read_eps_nk_from_qe_pwo"><code class="docutils literal notranslate"><span class="pre">read_eps_nk_from_qe_pwo()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#elphmod.el.read_hrdat"><code class="docutils literal notranslate"><span class="pre">read_hrdat()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#elphmod.el.read_pp_density"><code class="docutils literal notranslate"><span class="pre">read_pp_density()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#elphmod.el.read_projwfc_out"><code class="docutils literal notranslate"><span class="pre">read_projwfc_out()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#elphmod.el.read_pwo"><code class="docutils literal notranslate"><span class="pre">read_pwo()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#elphmod.el.read_rhoG_density"><code class="docutils literal notranslate"><span class="pre">read_rhoG_density()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#elphmod.el.read_symmetry_points"><code class="docutils literal notranslate"><span class="pre">read_symmetry_points()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#elphmod.el.read_wannier90_eig_file"><code class="docutils literal notranslate"><span class="pre">read_wannier90_eig_file()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#elphmod.el.read_wfc"><code class="docutils literal notranslate"><span class="pre">read_wfc()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#elphmod.el.read_wsvecdat"><code class="docutils literal notranslate"><span class="pre">read_wsvecdat()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#elphmod.el.write_bands"><code class="docutils literal notranslate"><span class="pre">write_bands()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#elphmod.el.write_hrdat"><code class="docutils literal notranslate"><span class="pre">write_hrdat()</span></code></a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="ph.html">Phonon</a></li>
<li class="toctree-l1"><a class="reference internal" href="elph.html">Electron–phonon</a></li>
<li class="toctree-l1"><a class="reference internal" href="elel.html">Electron–electron</a></li>
<li class="toctree-l1"><a class="reference internal" href="MPI.html">MPI</a></li>
<li class="toctree-l1"><a class="reference internal" href="bravais.html">Bravais</a></li>
<li class="toctree-l1"><a class="reference internal" href="dispersion.html">Dispersion</a></li>
<li class="toctree-l1"><a class="reference internal" href="dos.html">DOS</a></li>
<li class="toctree-l1"><a class="reference internal" href="diagrams.html">Diagrams</a></li>
<li class="toctree-l1"><a class="reference internal" href="occupations.html">Occupations</a></li>
<li class="toctree-l1"><a class="reference internal" href="md.html">MD</a></li>
<li class="toctree-l1"><a class="reference internal" href="eliashberg.html">Eliashberg</a></li>
<li class="toctree-l1"><a class="reference internal" href="plot.html">Plot</a></li>
<li class="toctree-l1"><a class="reference internal" href="misc.html">Miscellaneous</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">elphmod</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Electron</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/modules/el.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="module-elphmod.el">
<span id="electron"></span><h1>Electron<a class="headerlink" href="#module-elphmod.el" title="Link to this heading"></a></h1>
<p>Tight-binding models from Wannier90.</p>
<dl class="py class">
<dt class="sig sig-object py" id="elphmod.el.Model">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">elphmod.el.</span></span><span class="sig-name descname"><span class="pre">Model</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">seedname</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">N</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">divide_ndegen</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">read_xsf</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalize_wf</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">buffer_wf</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check_ortho</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rydberg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shared_memory</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#elphmod.el.Model" title="Link to this definition"></a></dt>
<dd><p>Tight-binding model for the electrons.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>seedname</strong><span class="classifier">str</span></dt><dd><p>Common prefix of Wannier90 output files: <em>seedname_hr.dat</em> with the
Hamiltonian in the Wannier basis and, optionally, <em>seedname_wsvec.dat</em>
with superlattice vectors used to symmetrize the long-range hopping.
Alternatively, <em>dat.h_mat_r</em> from RESPACK can be used.</p>
</dd>
<dt><strong>N</strong><span class="classifier">tuple of int, optional</span></dt><dd><p>Numbers of unit cells per direction on which RESPACK data is defined.
This can be omitted if all numbers are even.</p>
</dd>
<dt><strong>a</strong><span class="classifier">ndarray, optional</span></dt><dd><p>Bravais lattice vectors used to map RESPACK data to Wigner-Seitz cell.
By default, a cubic cell is assumed.</p>
</dd>
<dt><strong>r</strong><span class="classifier">ndarray, optional</span></dt><dd><p>Positions of orbital centers used to map RESPACK data to Wigner-Seitz
cell. By default, all orbitals are assumed to be located at the origin
of the unit cell.</p>
</dd>
<dt><strong>divide_ndegen</strong><span class="classifier">bool, default True</span></dt><dd><p>Divide hopping by degeneracy of Wigner-Seitz point and apply the
abovementioned correction? Only <code class="docutils literal notranslate"><span class="pre">True</span></code> yields correct bands.
<code class="docutils literal notranslate"><span class="pre">False</span></code> is only used in combination with <a class="reference internal" href="#elphmod.el.decayH" title="elphmod.el.decayH"><code class="xref py py-func docutils literal notranslate"><span class="pre">decayH()</span></code></a>.</p>
</dd>
<dt><strong>read_xsf</strong><span class="classifier">bool, default False</span></dt><dd><p>Read Wannier functions in position representation in the XCrySDen
structure format (XSF)?</p>
</dd>
<dt><strong>normalize_wf</strong><span class="classifier">bool, default False</span></dt><dd><p>Normalize Wannier functions? This is only recommended if a single and
complete image of each Wannier function is contained in the supercell
written to the XSF file. This may not be the case for a small number of
k points along one direction (e.g., a single k point in the out-of-plane
direction in the case of 2D materials), especially in combination with a
large supercell.</p>
</dd>
<dt><strong>buffer_wf</strong><span class="classifier">bool, default False</span></dt><dd><p>After reading XSF files, store Wannier functions and corresponding
real-space mesh in binary files, which will be read next time? Since
reading the XSF files is slow, this can save a lot of time for large
systems. Make sure to delete the binary files <em>seedname_wf.npy</em> and
<em>seedname_xyz.npy</em> whensoever the XSF files change.</p>
</dd>
<dt><strong>check_ortho</strong><span class="classifier">bool, default False</span></dt><dd><p>Check if Wannier functions are orthogonal?</p>
</dd>
<dt><strong>rydberg</strong><span class="classifier">bool, default False</span></dt><dd><p>Convert energies from eV to Ry?</p>
</dd>
<dt><strong>shared_memory</strong><span class="classifier">bool, default False</span></dt><dd><p>Store Wannier functions in shared memory?</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>R</strong><span class="classifier">ndarray</span></dt><dd><p>Lattice vectors of Wigner-Seitz supercell.</p>
</dd>
<dt><strong>data</strong><span class="classifier">ndarray</span></dt><dd><p>Corresponding on-site energies and hoppings.</p>
</dd>
<dt><strong>size</strong><span class="classifier">int</span></dt><dd><p>Number of Wannier functions/bands.</p>
</dd>
<dt><strong>nk</strong><span class="classifier">tuple of int</span></dt><dd><p>Guessed shape of original k-point mesh.</p>
</dd>
<dt><strong>cells</strong><span class="classifier">list of tuple of int, optional</span></dt><dd><p>Lattice vectors of unit cells if the model describes a supercell.</p>
</dd>
<dt><strong>N</strong><span class="classifier">list of tuple of int, optional</span></dt><dd><p>Primitive vectors of supercell if the model describes a supercell.</p>
</dd>
<dt><strong>W</strong><span class="classifier">ndarray, optional</span></dt><dd><p>Wannier functions in position representation if <cite>read_xsf</cite>.</p>
</dd>
<dt><strong>r</strong><span class="classifier">ndarray, optional</span></dt><dd><p>Cartesian positions belonging to Wannier functions if <cite>read_xsf</cite>.</p>
</dd>
<dt><strong>tau</strong><span class="classifier">ndarray, optional</span></dt><dd><p>Positions of basis atoms if <cite>read_xsf</cite>.</p>
</dd>
<dt><strong>atom_order</strong><span class="classifier">list of str, optional</span></dt><dd><p>Ordered list of atoms if <cite>read_xsf</cite>.</p>
</dd>
<dt><strong>dV</strong><span class="classifier">float, optional</span></dt><dd><p>Volume element/voxel volume belonging to <cite>r</cite> if <cite>read_xsf</cite>.</p>
</dd>
<dt><strong>divide_ndegen</strong><span class="classifier">bool</span></dt><dd><p>Have hoppings been divided by degeneracy of Wigner-Seitz point?</p>
</dd>
<dt><strong>rydberg</strong><span class="classifier">bool</span></dt><dd><p>Have energies been converted from eV to Ry?</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="elphmod.el.Model.H">
<span class="sig-name descname"><span class="pre">H</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">k1</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k3</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#elphmod.el.Model.H" title="Link to this definition"></a></dt>
<dd><p>Set up Hamilton operator for arbitrary k point.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="elphmod.el.Model.order_orbitals">
<span class="sig-name descname"><span class="pre">order_orbitals</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">order</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#elphmod.el.Model.order_orbitals" title="Link to this definition"></a></dt>
<dd><p>Reorder Wannier functions.</p>
<p>Warning: Wannier functions in position representation and related
attributes remain unchanged!</p>
<p>Together with <a class="reference internal" href="#elphmod.el.Model.shift_orbitals" title="elphmod.el.Model.shift_orbitals"><code class="xref py py-func docutils literal notranslate"><span class="pre">shift_orbitals()</span></code></a>, this function helps reconcile
inconsistent definitions of the basis/motif of the Bravais lattice.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>*order</strong><span class="classifier">int</span></dt><dd><p>New order of Wannier functions.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="elphmod.el.Model.shift_orbitals">
<span class="sig-name descname"><span class="pre">shift_orbitals</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">s</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">S</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#elphmod.el.Model.shift_orbitals" title="Link to this definition"></a></dt>
<dd><p>Move selected Wannier functions across unit-cell boundary.</p>
<p>Warning: Wannier functions in position representation and related
attributes remain unchanged!</p>
<p>Together with <a class="reference internal" href="#elphmod.el.Model.order_orbitals" title="elphmod.el.Model.order_orbitals"><code class="xref py py-func docutils literal notranslate"><span class="pre">order_orbitals()</span></code></a>, this function helps reconcile
inconsistent definitions of the basis/motif of the Bravais lattice.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>s</strong><span class="classifier">slice</span></dt><dd><p>Slice of orbital indices corresponding to selected basis atom(s).</p>
</dd>
<dt><strong>S</strong><span class="classifier">tuple of int</span></dt><dd><p>Shift of as multiple of primitive lattice vectors.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="elphmod.el.Model.standardize">
<span class="sig-name descname"><span class="pre">standardize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">eps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">symmetrize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#elphmod.el.Model.standardize" title="Link to this definition"></a></dt>
<dd><p>Standardize tight-binding data.</p>
<ul class="simple">
<li><p>Keep only nonzero hopping matrices.</p></li>
<li><p>Sum over repeated lattice vectors.</p></li>
<li><p>Sort lattice vectors.</p></li>
<li><p>Optionally symmetrize hopping:</p></li>
</ul>
<div class="math notranslate nohighlight">
\[H_{\vec k} = H_{\vec k}^\dagger,
H_{\vec R} = H_{-\vec R}^\dagger\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>eps</strong><span class="classifier">float</span></dt><dd><p>Threshold for “nonzero” matrix elements in units of the maximum
matrix element.</p>
</dd>
<dt><strong>symmetrize</strong><span class="classifier">bool</span></dt><dd><p>Symmetrize hopping?</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="elphmod.el.Model.supercell">
<span class="sig-name descname"><span class="pre">supercell</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N1</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">N2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">N3</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sparse</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#elphmod.el.Model.supercell" title="Link to this definition"></a></dt>
<dd><p>Map tight-binding model onto supercell.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N1, N2, N3</strong><span class="classifier">tuple of int or int, default 1</span></dt><dd><p>Supercell lattice vectors in units of primitive lattice vectors.</p>
</dd>
<dt><strong>sparse</strong><span class="classifier">bool, default False</span></dt><dd><p>Only calculate k = 0 Hamiltonian as a sparse matrix to save memory?
The result, which is assumed to be real, is stored in the attribute
<code class="xref py py-attr docutils literal notranslate"><span class="pre">Hs</span></code>. Consider using <a class="reference internal" href="#elphmod.el.Model.standardize" title="elphmod.el.Model.standardize"><code class="xref py py-meth docutils literal notranslate"><span class="pre">standardize()</span></code></a> with nonzero <cite>eps</cite>
and <cite>symmetrize</cite> before.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>object</dt><dd><p>Tight-binding model for supercell.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">bravais.supercell</span></code></dt><dd></dd>
</dl>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="elphmod.el.Model.symmetrize">
<span class="sig-name descname"><span class="pre">symmetrize</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#elphmod.el.Model.symmetrize" title="Link to this definition"></a></dt>
<dd><p>Symmetrize Hamiltonian.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="elphmod.el.Model.t">
<span class="sig-name descname"><span class="pre">t</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">R1</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">R2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">R3</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#elphmod.el.Model.t" title="Link to this definition"></a></dt>
<dd><p>Get on-site or hopping energy for arbitrary lattice vector.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="elphmod.el.Model.to_hrdat">
<span class="sig-name descname"><span class="pre">to_hrdat</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">seedname</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#elphmod.el.Model.to_hrdat" title="Link to this definition"></a></dt>
<dd><p>Save tight-binding model to <em>_hr.dat</em> file.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>seedname</strong><span class="classifier">str</span></dt><dd><p>Common prefix of Wannier90 input and output files.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="elphmod.el.Model.unit_cell">
<span class="sig-name descname"><span class="pre">unit_cell</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#elphmod.el.Model.unit_cell" title="Link to this definition"></a></dt>
<dd><p>Map tight-binding model back to unit cell.</p>
<p>Original idea by Bin Shao.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#elphmod.el.Model.supercell" title="elphmod.el.Model.supercell"><code class="xref py py-obj docutils literal notranslate"><span class="pre">supercell</span></code></a></dt><dd></dd>
</dl>
</div>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="elphmod.el.decayH">
<span class="sig-prename descclassname"><span class="pre">elphmod.el.</span></span><span class="sig-name descname"><span class="pre">decayH</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">seedname</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#elphmod.el.decayH" title="Link to this definition"></a></dt>
<dd><p>Calculate the decay of the Hamiltonian.</p>
<p>This function should yield the same data as <a class="reference internal" href="#elphmod.el.read_decayH" title="elphmod.el.read_decayH"><code class="xref py py-func docutils literal notranslate"><span class="pre">read_decayH()</span></code></a>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>seedname</strong><span class="classifier">str</span></dt><dd><p>Prefix of Wannier90 output file.</p>
</dd>
<dt><strong>**kwargs</strong></dt><dd><p>Arguments for <code class="xref py py-func docutils literal notranslate"><span class="pre">bravais.primitives()</span></code>: Choose the right Bravais
lattice (<code class="docutils literal notranslate"><span class="pre">ibrav</span></code>) and lattice constants (<code class="docutils literal notranslate"><span class="pre">a,</span> <span class="pre">b,</span> <span class="pre">c,</span> <span class="pre">...</span></code>).</p>
<p>For a simple cubic lattice: <code class="docutils literal notranslate"><span class="pre">decayH(seedname,</span> <span class="pre">ibrav=1,</span> <span class="pre">a=a)</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>R</strong><span class="classifier">ndarray</span></dt><dd><p>The distance of every Wigner-Seitz grid point measured from the center
in angstrom.</p>
</dd>
<dt><strong>H</strong><span class="classifier">ndarray</span></dt><dd><p>The maximum absolute value of the elements of the Hamiltonian matrix in
rydberg.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="elphmod.el.demet_from_qe_pwo">
<span class="sig-prename descclassname"><span class="pre">elphmod.el.</span></span><span class="sig-name descname"><span class="pre">demet_from_qe_pwo</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pw_scf_out</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">subset</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#elphmod.el.demet_from_qe_pwo" title="Link to this definition"></a></dt>
<dd><p>Calculate the entropy contribution <span class="math notranslate nohighlight">\(-TS\)</span> to the total free energy.</p>
<p>In Quantum ESPRESSO <code class="docutils literal notranslate"><span class="pre">demet</span></code> is calculated in <code class="docutils literal notranslate"><span class="pre">gweights.f90</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>pw_scf_out</strong><span class="classifier">str</span></dt><dd><p>The name of the output file (typically <code class="docutils literal notranslate"><span class="pre">'pw.out'</span></code>).</p>
</dd>
<dt><strong>subset</strong><span class="classifier">list or array</span></dt><dd><p>List of indices to pick only a subset of the bands for the integration.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>demet</strong><span class="classifier">float</span></dt><dd><p>The <span class="math notranslate nohighlight">\(-TS\)</span> contribution to the total free energy.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="elphmod.el.eband">
<span class="sig-prename descclassname"><span class="pre">elphmod.el.</span></span><span class="sig-name descname"><span class="pre">eband</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pw_scf_out</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">subset</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#elphmod.el.eband" title="Link to this definition"></a></dt>
<dd><p>Calculate <code class="docutils literal notranslate"><span class="pre">eband</span></code> part of one-electron energy.</p>
<p>The ‘one-electron contribution’ energy in the Quantum ESPRESSO PWscf output
is a sum <code class="docutils literal notranslate"><span class="pre">eband</span> <span class="pre">+</span> <span class="pre">deband</span></code>. Here, we can calculate the <code class="docutils literal notranslate"><span class="pre">eband</span></code> part.</p>
<p>To compare it with the Quantum ESPRESSO result, you need to modify
the <code class="docutils literal notranslate"><span class="pre">SUBROUTINE</span> <span class="pre">print_energies</span> <span class="pre">(</span> <span class="pre">printout</span> <span class="pre">)</span></code> from <em>electrons.f90</em>.</p>
<p>Change:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">WRITE</span><span class="p">(</span> <span class="n">stdout</span><span class="p">,</span> <span class="mi">9062</span> <span class="p">)</span> <span class="p">(</span><span class="n">eband</span> <span class="o">+</span> <span class="n">deband</span><span class="p">),</span> <span class="n">ehart</span><span class="p">,</span> <span class="p">(</span> <span class="n">etxc</span> <span class="o">-</span> <span class="n">etxcc</span> <span class="p">),</span> <span class="n">ewld</span>
</pre></div>
</div>
<p>to:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">WRITE</span><span class="p">(</span> <span class="n">stdout</span><span class="p">,</span> <span class="mi">9062</span> <span class="p">)</span> <span class="n">eband</span><span class="p">,</span> <span class="o">&amp;</span>
   <span class="p">(</span><span class="n">eband</span> <span class="o">+</span> <span class="n">deband</span><span class="p">),</span> <span class="n">ehart</span><span class="p">,</span> <span class="p">(</span> <span class="n">etxc</span> <span class="o">-</span> <span class="n">etxcc</span> <span class="p">),</span> <span class="n">ewld</span>
</pre></div>
</div>
<p>and:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">9062</span> <span class="n">FORMAT</span><span class="p">(</span> <span class="s1">&#39;     one-electron contribution =&#39;</span><span class="p">,</span><span class="n">F17</span><span class="mf">.8</span><span class="p">,</span><span class="s1">&#39; Ry&#39;</span> <span class="o">&amp;</span>
</pre></div>
</div>
<p>to:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">9062</span> <span class="n">FORMAT</span><span class="p">(</span> <span class="s1">&#39;     sum bands                 =&#39;</span><span class="p">,</span><span class="n">F17</span><span class="mf">.8</span><span class="p">,</span><span class="s1">&#39; Ry&#39;</span> <span class="o">&amp;</span>
            <span class="o">/</span><span class="s1">&#39;     one-electron contribution =&#39;</span><span class="p">,</span><span class="n">F17</span><span class="mf">.8</span><span class="p">,</span><span class="s1">&#39; Ry&#39;</span> <span class="o">&amp;</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>pw_scf_out</strong><span class="classifier">str</span></dt><dd><p>Name of the output file (typically <code class="docutils literal notranslate"><span class="pre">'pw.out'</span></code> or <code class="docutils literal notranslate"><span class="pre">'scf.out'</span></code>).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>eband</strong><span class="classifier">float</span></dt><dd><p>The band energy.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="elphmod.el.k2r">
<span class="sig-prename descclassname"><span class="pre">elphmod.el.</span></span><span class="sig-name descname"><span class="pre">k2r</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">el</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">H</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fft</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#elphmod.el.k2r" title="Link to this definition"></a></dt>
<dd><p>Interpolate Hamilontian matrices on uniform k-point mesh.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>el</strong><span class="classifier">object</span></dt><dd><p>Tight-binding model.</p>
</dd>
<dt><strong>H</strong><span class="classifier">ndarray</span></dt><dd><p>Hamiltonian matrices on complete uniform k-point mesh.</p>
</dd>
<dt><strong>a</strong><span class="classifier">ndarray</span></dt><dd><p>Bravais lattice vectors.</p>
</dd>
<dt><strong>r</strong><span class="classifier">ndarray</span></dt><dd><p>Positions of orbital centers.</p>
</dd>
<dt><strong>fft</strong><span class="classifier">bool</span></dt><dd><p>Perform Fourier transform? If <code class="docutils literal notranslate"><span class="pre">False</span></code>, only the mapping to the
Wigner-Seitz cell is performed.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="elphmod.el.proj_sum">
<span class="sig-prename descclassname"><span class="pre">elphmod.el.</span></span><span class="sig-name descname"><span class="pre">proj_sum</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">proj</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">orbitals</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">groups</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#elphmod.el.proj_sum" title="Link to this definition"></a></dt>
<dd><p>Sum over selected atomic projections.</p>
<p>Example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">proj</span> <span class="o">=</span> <span class="n">read_atomic_projections</span><span class="p">(</span><span class="s1">&#39;atomic_proj.xml&#39;</span><span class="p">)</span>
<span class="n">orbitals</span> <span class="o">=</span> <span class="n">read_projwf_out</span><span class="p">(</span><span class="s1">&#39;projwfc.out&#39;</span><span class="p">)</span>
<span class="n">proj</span> <span class="o">=</span> <span class="n">proj_sum</span><span class="p">(</span><span class="n">proj</span><span class="p">,</span> <span class="n">orbitals</span><span class="p">,</span> <span class="s1">&#39;S-p&#39;</span><span class="p">,</span> <span class="s1">&#39;Ta-d{z2, x2-y2, xy}&#39;</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>proj</strong><span class="classifier">ndarray</span></dt><dd><p>Atomic projections from <a class="reference internal" href="#elphmod.el.read_atomic_projections" title="elphmod.el.read_atomic_projections"><code class="xref py py-func docutils literal notranslate"><span class="pre">read_atomic_projections()</span></code></a>.</p>
</dd>
<dt><strong>orbitals</strong><span class="classifier">list of str</span></dt><dd><p>Names of all orbitals from <a class="reference internal" href="#elphmod.el.read_projwfc_out" title="elphmod.el.read_projwfc_out"><code class="xref py py-func docutils literal notranslate"><span class="pre">read_projwfc_out()</span></code></a>.</p>
</dd>
<dt><strong>*groups</strong></dt><dd><p>Comma-separated lists of names of selected orbitals. Omitted name
components are summed over. Curly braces are expanded.</p>
</dd>
<dt><strong>other</strong><span class="classifier">bool, default False</span></dt><dd><p>Return remaining orbital weight too?</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>ndarray</dt><dd><p>Summed-over atomic projections.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="elphmod.el.read_Fermi_level">
<span class="sig-prename descclassname"><span class="pre">elphmod.el.</span></span><span class="sig-name descname"><span class="pre">read_Fermi_level</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pw_scf_out</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#elphmod.el.read_Fermi_level" title="Link to this definition"></a></dt>
<dd><p>Read Fermi level from output of self-consistent PW run.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="elphmod.el.read_atomic_projections">
<span class="sig-prename descclassname"><span class="pre">elphmod.el.</span></span><span class="sig-name descname"><span class="pre">read_atomic_projections</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">atomic_proj_xml</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">from_fermi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">order_kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#elphmod.el.read_atomic_projections" title="Link to this definition"></a></dt>
<dd><p>Read projected bands from <em>outdir/prefix.save/atomic_proj.xml</em>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>atomic_proj_xml</strong><span class="classifier">str</span></dt><dd><p>XML file with atomic projections generated by <code class="docutils literal notranslate"><span class="pre">projwfc.x</span></code>.</p>
</dd>
<dt><strong>order</strong><span class="classifier">bool</span></dt><dd><p>Order/disentangle bands via their k-local character?</p>
</dd>
<dt><strong>from_fermi</strong><span class="classifier">bool</span></dt><dd><p>Subtract Fermi level from electronic energies?</p>
</dd>
<dt><strong>other</strong><span class="classifier">bool</span></dt><dd><p>Estimate projection onto “other” orbitals as difference of band weights
to one?</p>
</dd>
<dt><strong>**order_kwargs</strong></dt><dd><p>Keyword arguments passed to <code class="xref py py-func docutils literal notranslate"><span class="pre">band_order()</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>ndarray</dt><dd><p>k points.</p>
</dd>
<dt>ndarray</dt><dd><p>Cumulative path distance.</p>
</dd>
<dt>ndarray</dt><dd><p>Electronic energies.</p>
</dd>
<dt>ndarray</dt><dd><p>Projections onto (pseudo) atomic orbitals.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="elphmod.el.read_atomic_projections_old">
<span class="sig-prename descclassname"><span class="pre">elphmod.el.</span></span><span class="sig-name descname"><span class="pre">read_atomic_projections_old</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">atomic_proj_xml</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">from_fermi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">order_kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#elphmod.el.read_atomic_projections_old" title="Link to this definition"></a></dt>
<dd><p>Read projected bands from <em>outdir/prefix.save/atomic_proj.xml</em>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="elphmod.el.read_bands">
<span class="sig-prename descclassname"><span class="pre">elphmod.el.</span></span><span class="sig-name descname"><span class="pre">read_bands</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filband</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#elphmod.el.read_bands" title="Link to this definition"></a></dt>
<dd><p>Read bands from <em>filband</em> just like Quantum ESRESSO’s <code class="docutils literal notranslate"><span class="pre">plotband.x</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>filband</strong><span class="classifier">str</span></dt><dd><p>Filename.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>k</strong><span class="classifier">ndarray</span></dt><dd><p>k points in Cartesian coordiantes.</p>
</dd>
<dt><strong>bands</strong><span class="classifier">ndarray</span></dt><dd><p>Band energies.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="elphmod.el.read_bands_plot">
<span class="sig-prename descclassname"><span class="pre">elphmod.el.</span></span><span class="sig-name descname"><span class="pre">read_bands_plot</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filbandgnu</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bands</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#elphmod.el.read_bands_plot" title="Link to this definition"></a></dt>
<dd><p>Read bands from <em>filband.gnu</em> produced by Quantum ESPRESSO’s <code class="docutils literal notranslate"><span class="pre">bands.x</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>filbandgnu</strong><span class="classifier">str</span></dt><dd><p>Name of file with plotted bands.</p>
</dd>
<dt><strong>bands</strong><span class="classifier">int</span></dt><dd><p>Number of bands.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>ndarray</dt><dd><p>Cumulative reciprocal distance.</p>
</dd>
<dt>ndarray</dt><dd><p>Band energies.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="elphmod.el.read_decayH">
<span class="sig-prename descclassname"><span class="pre">elphmod.el.</span></span><span class="sig-name descname"><span class="pre">read_decayH</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#elphmod.el.read_decayH" title="Link to this definition"></a></dt>
<dd><p>Read <em>decay.H</em> output from EPW.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>file</strong><span class="classifier">str</span></dt><dd><p>The name of the <em>decay.H</em> output from EPW.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>R</strong><span class="classifier">ndarray</span></dt><dd><p>The distance of every Wigner-Seitz grid point measured from the center
in angstrom.</p>
</dd>
<dt><strong>H</strong><span class="classifier">ndarray</span></dt><dd><p>The maximum absolute value of the elements of the Hamiltonian matrix in
rydberg.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="elphmod.el.read_energy_contributions_scf_out">
<span class="sig-prename descclassname"><span class="pre">elphmod.el.</span></span><span class="sig-name descname"><span class="pre">read_energy_contributions_scf_out</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filename</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#elphmod.el.read_energy_contributions_scf_out" title="Link to this definition"></a></dt>
<dd><p>Read energy contributions to the total energy <code class="docutils literal notranslate"><span class="pre">scf</span></code> output file.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>filename</strong><span class="classifier">str</span></dt><dd><p>Name of Quantum ESPRESSO’s <code class="docutils literal notranslate"><span class="pre">scf</span></code> output file.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>dict</dt><dd><p>Energy contributions.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="elphmod.el.read_eps_nk_from_qe_pwo">
<span class="sig-prename descclassname"><span class="pre">elphmod.el.</span></span><span class="sig-name descname"><span class="pre">read_eps_nk_from_qe_pwo</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pw_scf_out</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#elphmod.el.read_eps_nk_from_qe_pwo" title="Link to this definition"></a></dt>
<dd><p>Read electronic eigenenergies and k points and calculate the occupations.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>pw_scf_out</strong><span class="classifier">str</span></dt><dd><p>Name of the output file (typically <code class="docutils literal notranslate"><span class="pre">'pw.out'</span></code> or <code class="docutils literal notranslate"><span class="pre">'scf.out'</span></code>).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>energies</strong><span class="classifier">ndarray</span></dt><dd><p>Electronic eigenenergies (<code class="docutils literal notranslate"><span class="pre">eps_nk</span></code>) from <code class="docutils literal notranslate"><span class="pre">scf</span></code> output, shape <code class="docutils literal notranslate"><span class="pre">(nk,</span>
<span class="pre">nbnd)</span></code>.</p>
</dd>
<dt><strong>kpoints</strong><span class="classifier">ndarray</span></dt><dd><p>k points and weights from <code class="docutils literal notranslate"><span class="pre">scf</span></code> output, shape <code class="docutils literal notranslate"><span class="pre">(nk,</span> <span class="pre">4)</span></code>, where the
4th column contains the weights.</p>
</dd>
<dt><strong>f_occ</strong><span class="classifier">ndarray</span></dt><dd><p>Occupations of <code class="docutils literal notranslate"><span class="pre">eps_nk</span></code> (same shape as <cite>energies</cite>).</p>
</dd>
<dt><strong>smearing_type</strong><span class="classifier">str</span></dt><dd><p>Type of smearing (for example <code class="docutils literal notranslate"><span class="pre">'Fermi-Dirac'</span></code>).</p>
</dd>
<dt><strong>mu</strong><span class="classifier">float</span></dt><dd><p>Chemical potential in eV.</p>
</dd>
<dt><strong>kT</strong><span class="classifier">float</span></dt><dd><p>Value of smearing (<code class="docutils literal notranslate"><span class="pre">degauss</span></code>) in eV.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="elphmod.el.read_hrdat">
<span class="sig-prename descclassname"><span class="pre">elphmod.el.</span></span><span class="sig-name descname"><span class="pre">read_hrdat</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">seedname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">divide_ndegen</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#elphmod.el.read_hrdat" title="Link to this definition"></a></dt>
<dd><p>Read <em>_hr.dat</em> (or <em>_tb.dat</em>) file from Wannier90.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>seedname</strong><span class="classifier">str</span></dt><dd><p>Common prefix of Wannier90 input and output files.</p>
</dd>
<dt><strong>divide_ndegen</strong><span class="classifier">bool</span></dt><dd><p>Divide hopping by degeneracy of Wigner-Seitz point?</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>ndarray</dt><dd><p>Lattice vectors.</p>
</dd>
<dt>ndarray</dt><dd><p>On-site and hopping parameters.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="elphmod.el.read_pp_density">
<span class="sig-prename descclassname"><span class="pre">elphmod.el.</span></span><span class="sig-name descname"><span class="pre">read_pp_density</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filename</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#elphmod.el.read_pp_density" title="Link to this definition"></a></dt>
<dd><p>Read file <em>filout</em> with charge density generated by <code class="docutils literal notranslate"><span class="pre">pp.x</span></code>.</p>
<p>Calculate total charge</p>
<div class="math notranslate nohighlight">
\[Q = \int \rho(\vec r) dx dy dz =
    = \frac \Omega {n_1 n_2 n_3} \sum_{i j k} \rho_{i j k},\]</div>
<p>where <span class="math notranslate nohighlight">\(\Omega\)</span> is the unit-cell volume, <span class="math notranslate nohighlight">\(n_r\)</span> are the FFT grid
dimensions, and <span class="math notranslate nohighlight">\(i, j, k\)</span> run over FFT real-space grid points.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>filename</strong><span class="classifier">str</span></dt><dd><p>Filename.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>rho</strong><span class="classifier">ndarray</span></dt><dd><p>Electronic charge density <span class="math notranslate nohighlight">\(\rho_{i j k}\)</span> on FFT real-space grid
points.</p>
</dd>
<dt>tot_charge: float</dt><dd><p>Total charge calculated from charge density <span class="math notranslate nohighlight">\(\rho_{i j k}\)</span>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="elphmod.el.read_projwfc_out">
<span class="sig-prename descclassname"><span class="pre">elphmod.el.</span></span><span class="sig-name descname"><span class="pre">read_projwfc_out</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">projwfc_out</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#elphmod.el.read_projwfc_out" title="Link to this definition"></a></dt>
<dd><p>Identify orbitals in <em>atomic_proj.xml</em> via output of <code class="docutils literal notranslate"><span class="pre">projwfc.x</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>projwfc_out</strong><span class="classifier">str</span></dt><dd><p>Output file of <code class="docutils literal notranslate"><span class="pre">projwfc.x</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>list of str</dt><dd><p>Common names of (pseudo) atomic orbitals listed in <cite>projwfc_out</cite> (in
that order).</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="elphmod.el.read_pwo">
<span class="sig-prename descclassname"><span class="pre">elphmod.el.</span></span><span class="sig-name descname"><span class="pre">read_pwo</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pw_scf_out</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#elphmod.el.read_pwo" title="Link to this definition"></a></dt>
<dd><p>Read energies from PW output file.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="elphmod.el.read_rhoG_density">
<span class="sig-prename descclassname"><span class="pre">elphmod.el.</span></span><span class="sig-name descname"><span class="pre">read_rhoG_density</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filename</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ibrav</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#elphmod.el.read_rhoG_density" title="Link to this definition"></a></dt>
<dd><p>Read the charge density output from Quantum ESPRESSO.</p>
<p>The purpose of <span class="math notranslate nohighlight">\(\rho(\vec G)\)</span> is to calculate the charge density in
real space <span class="math notranslate nohighlight">\(\rho(\vec r)\)</span> or the Hartree energy <code class="docutils literal notranslate"><span class="pre">ehart</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>filename</strong><span class="classifier">str</span></dt><dd><p>Filename.</p>
</dd>
<dt><strong>ibrav</strong><span class="classifier">integer</span></dt><dd><p>Bravais lattice index (see <code class="docutils literal notranslate"><span class="pre">pw.x</span></code> input description).</p>
</dd>
<dt><strong>a, b, c</strong><span class="classifier">float</span></dt><dd><p>Bravais lattice parameters.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>rho_g</strong><span class="classifier">ndarray</span></dt><dd><p>Electronic charge density <span class="math notranslate nohighlight">\(\rho(\vec G)\)</span> on reciprocal-space grid
points.</p>
</dd>
<dt><strong>g_vect</strong><span class="classifier">ndarray</span></dt><dd><p>Reciprocal lattice vectors <span class="math notranslate nohighlight">\(\vec G\)</span>.</p>
</dd>
<dt><strong>ngm_g</strong><span class="classifier">integer</span></dt><dd><p>Number of reciprocal lattice vectors.</p>
</dd>
<dt><strong>uc_volume</strong><span class="classifier">float</span></dt><dd><p>Unit-cell volume.</p>
</dd>
<dt><strong>mill_g</strong><span class="classifier">ndarray</span></dt><dd><p>Miller indices.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="elphmod.el.read_symmetry_points">
<span class="sig-prename descclassname"><span class="pre">elphmod.el.</span></span><span class="sig-name descname"><span class="pre">read_symmetry_points</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bandsout</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#elphmod.el.read_symmetry_points" title="Link to this definition"></a></dt>
<dd><p>Read positions of symmetry points along path.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>bandsout</strong><span class="classifier">str</span></dt><dd><p>File with standard output from Quantum ESPRESSO’s <code class="docutils literal notranslate"><span class="pre">bands.x</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>list</dt><dd><p>Positions of symmetry points.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="elphmod.el.read_wannier90_eig_file">
<span class="sig-prename descclassname"><span class="pre">elphmod.el.</span></span><span class="sig-name descname"><span class="pre">read_wannier90_eig_file</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">seedname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_bands</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nkpts</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#elphmod.el.read_wannier90_eig_file" title="Link to this definition"></a></dt>
<dd><p>Read Kohn-Sham energies (eV) from the Wannier90 output seedname.eig file.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>seedname</strong><span class="classifier">str</span></dt><dd><p>For example ‘tas2’, if the file is named ‘tas2.eig’.</p>
</dd>
<dt><strong>num_bands</strong><span class="classifier">int</span></dt><dd><p>Number of bands in your pseudopotential.</p>
</dd>
<dt><strong>nkpts</strong><span class="classifier">int</span></dt><dd><p>Number of k points in your Wannier90 calculations.
For example 1296 for 36x36x1.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>ndarray</dt><dd><p>Kohn-Sham energies: <code class="docutils literal notranslate"><span class="pre">eig[num_bands,</span> <span class="pre">nkpts]</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="elphmod.el.read_wfc">
<span class="sig-prename descclassname"><span class="pre">elphmod.el.</span></span><span class="sig-name descname"><span class="pre">read_wfc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filename</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ibrav</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#elphmod.el.read_wfc" title="Link to this definition"></a></dt>
<dd><p>Read the wave function output from Quantum ESPRESSO.</p>
<div class="math notranslate nohighlight">
\[\psi_{n \vec k}(\vec r) = \frac 1 {\sqrt V} \sum_{\vec G}
    c_{n, \vec k + \vec G} \E^{\I (\vec k + \vec G) \vec r}\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>filename</strong><span class="classifier">str</span></dt><dd><p>Filename.</p>
</dd>
<dt><strong>ibrav</strong><span class="classifier">integer</span></dt><dd><p>Bravais lattice index (see <code class="docutils literal notranslate"><span class="pre">pw.x</span></code> input description).</p>
</dd>
<dt><strong>a, b, c</strong><span class="classifier">float</span></dt><dd><p>Bravais lattice parameters.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>evc</strong><span class="classifier">ndarray</span></dt><dd><p>Electronic wave function <span class="math notranslate nohighlight">\(c_{n, \vec k + \vec G}\)</span>.</p>
</dd>
<dt><strong>igwx</strong><span class="classifier">integer</span></dt><dd><p>Number of reciprocal lattice vectors.</p>
</dd>
<dt><strong>xk</strong><span class="classifier">ndarray</span></dt><dd><p>k point.</p>
</dd>
<dt><strong>k_plus_G</strong><span class="classifier">ndarray</span></dt><dd><p>k point plus reciprocal lattice vectors <span class="math notranslate nohighlight">\(\vec G\)</span>.</p>
</dd>
<dt><strong>g_vect</strong><span class="classifier">ndarray</span></dt><dd><p>Reciprocal lattice vectors <span class="math notranslate nohighlight">\(\vec G\)</span>.</p>
</dd>
<dt><strong>mill_g</strong><span class="classifier">ndarray</span></dt><dd><p>Miller indices.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="elphmod.el.read_wsvecdat">
<span class="sig-prename descclassname"><span class="pre">elphmod.el.</span></span><span class="sig-name descname"><span class="pre">read_wsvecdat</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">wsvecdat</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#elphmod.el.read_wsvecdat" title="Link to this definition"></a></dt>
<dd><p>Read <em>_wsvec.dat</em> file from Wannier90.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="elphmod.el.write_bands">
<span class="sig-prename descclassname"><span class="pre">elphmod.el.</span></span><span class="sig-name descname"><span class="pre">write_bands</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filband</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bands</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fmt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'%8.3f'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cols</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#elphmod.el.write_bands" title="Link to this definition"></a></dt>
<dd><p>Write bands to <em>filband</em> just like Quantum ESPRESSO’s <code class="docutils literal notranslate"><span class="pre">plotband.x</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>filband</strong><span class="classifier">str</span></dt><dd><p>Filename.</p>
</dd>
<dt><strong>k</strong><span class="classifier">ndarray</span></dt><dd><p>k points in Cartesian coordiantes.</p>
</dd>
<dt><strong>bands</strong><span class="classifier">ndarray</span></dt><dd><p>Band energies.</p>
</dd>
<dt><strong>fmt</strong><span class="classifier">str</span></dt><dd><p>Format string for band energies.</p>
</dd>
<dt><strong>cols</strong><span class="classifier">int</span></dt><dd><p>Number of band energies per line.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="elphmod.el.write_hrdat">
<span class="sig-prename descclassname"><span class="pre">elphmod.el.</span></span><span class="sig-name descname"><span class="pre">write_hrdat</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">seedname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">R</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">H</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ndegen</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#elphmod.el.write_hrdat" title="Link to this definition"></a></dt>
<dd><p>Write <em>_hr.dat</em> file as generated by Wannier90.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>seedname</strong><span class="classifier">str</span></dt><dd><p>Common prefix of Wannier90 input and output files.</p>
</dd>
<dt><strong>R</strong><span class="classifier">ndarray</span></dt><dd><p>Lattice vectors of Wigner-Seitz supercell.</p>
</dd>
<dt><strong>H</strong><span class="classifier">ndarray</span></dt><dd><p>Corresponding on-site energies and hoppings.</p>
</dd>
<dt><strong>ndegen</strong><span class="classifier">list of int</span></dt><dd><p>Degeneracies of Wigner-Seitz lattice vectors. This is just what is
written to the file header, and it is not used to further modify <cite>H</cite>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="../index.html" class="btn btn-neutral float-left" title="Python modules for electron-phonon models" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="ph.html" class="btn btn-neutral float-right" title="Phonon" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2017-2024 elphmod Developers.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>